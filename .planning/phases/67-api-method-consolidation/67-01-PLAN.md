---
phase: 67-api-method-consolidation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/scenes/gym_scene.py
autonomous: true

must_haves:
  truths:
    - "GymScene has a runtime() method that accepts only browser execution params (run_through_pyodide, environment_initialization_code, environment_initialization_code_filepath, on_game_step_code, packages_to_install, restart_pyodide)"
    - "GymScene has a multiplayer() method that accepts sync params (multiplayer, server_authoritative, state_broadcast_interval, realtime_mode, input_buffer_size, input_delay, input_confirmation_timeout_ms) AND matchmaking params AND player_grouping params AND continuous_monitoring params AND exclusion_callbacks params AND reconnection_config params AND partner_disconnect_message_config params AND focus_loss_config params"
    - "All old methods (pyodide, matchmaking, player_grouping, continuous_monitoring, exclusion_callbacks, reconnection_config, partner_disconnect_message_config, focus_loss_config, player_pairing) still exist and work unchanged"
    - "runtime() and multiplayer() return self for method chaining"
    - "All validation logic from old methods is preserved in new methods"
  artifacts:
    - path: "interactive_gym/scenes/gym_scene.py"
      provides: "runtime() and multiplayer() builder methods"
      contains: "def runtime"
    - path: "interactive_gym/scenes/gym_scene.py"
      provides: "multiplayer() builder method"
      contains: "def multiplayer"
  key_links:
    - from: "multiplayer() method param 'multiplayer'"
      to: "self.pyodide_multiplayer"
      via: "conditional assignment"
      pattern: "self\\.pyodide_multiplayer = multiplayer"
    - from: "multiplayer() method param 'max_rtt'"
      to: "self.matchmaking_max_rtt"
      via: "conditional assignment"
      pattern: "self\\.matchmaking_max_rtt = max_rtt"
    - from: "multiplayer() method param 'continuous_callback'"
      to: "self.continuous_exclusion_callback"
      via: "conditional assignment"
      pattern: "self\\.continuous_exclusion_callback = continuous_callback"
    - from: "multiplayer() method param 'matchmaker'"
      to: "self._matchmaker"
      via: "conditional assignment with type check"
      pattern: "self\\._matchmaker = matchmaker"
---

<objective>
Add `runtime()` and `multiplayer()` builder methods to GymScene.

Purpose: APIC-01 (rename pyodide to runtime), APIC-02 (move sync params to multiplayer), APIC-03 (merge 7 methods into multiplayer). These new methods are added ALONGSIDE old methods -- old methods are NOT removed (that is Phase 68).

Output: `gym_scene.py` with two new builder methods that co-exist with the old ones.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/67-api-method-consolidation/67-RESEARCH.md

# Primary source file
@interactive_gym/scenes/gym_scene.py
@interactive_gym/scenes/utils.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add runtime() method</name>
  <files>interactive_gym/scenes/gym_scene.py</files>
  <action>
Add a new `runtime()` method to GymScene. Place it AFTER the `pyodide()` method (around line 713).

The method accepts ONLY browser execution params (the 6 params that are NOT sync/multiplayer related from the current `pyodide()` method):

```python
def runtime(
    self,
    run_through_pyodide: bool = NotProvided,
    environment_initialization_code: str = NotProvided,
    environment_initialization_code_filepath: str = NotProvided,
    on_game_step_code: str = NotProvided,
    packages_to_install: list[str] = NotProvided,
    restart_pyodide: bool = NotProvided,
):
    """Configure browser runtime (Pyodide) settings.

    This method configures the Pyodide runtime that allows Python environments
    to run directly in the participant's browser.

    :param run_through_pyodide: Whether to run the environment through Pyodide, defaults to NotProvided
    :type run_through_pyodide: bool, optional
    :param environment_initialization_code: Python code to initialize the environment in Pyodide, defaults to NotProvided
    :type environment_initialization_code: str, optional
    :param environment_initialization_code_filepath: Path to a file containing initialization code, defaults to NotProvided
    :type environment_initialization_code_filepath: str, optional
    :param on_game_step_code: Python code to run on each game step, defaults to NotProvided
    :type on_game_step_code: str, optional
    :param packages_to_install: List of packages to install in Pyodide, defaults to NotProvided
    :type packages_to_install: list[str], optional
    :param restart_pyodide: Whether to restart Pyodide between scenes, defaults to NotProvided
    :type restart_pyodide: bool, optional
    :return: This scene object
    :rtype: GymScene
    """
```

Copy the EXACT logic from `pyodide()` for these 6 params. Specifically:
- `run_through_pyodide`: assert isinstance bool, set `self.run_through_pyodide`
- `environment_initialization_code`: set `self.environment_initialization_code`
- `environment_initialization_code_filepath`: assert environment_initialization_code is NotProvided, open file, set `self.environment_initialization_code`
- `packages_to_install`: set `self.packages_to_install`, append DEFAULT_IG_PACKAGE if missing
- `restart_pyodide`: set `self.restart_pyodide`
- `on_game_step_code`: set `self.on_game_step_code`

Return `self` at the end.

Do NOT modify the existing `pyodide()` method. Do NOT remove any old methods.
  </action>
  <verify>
Run: `python -c "from interactive_gym.scenes.gym_scene import GymScene; s = GymScene(); s.runtime(run_through_pyodide=True, packages_to_install=['numpy']); assert s.run_through_pyodide == True; assert 'numpy' in s.packages_to_install; print('runtime() OK')"` -- should print "runtime() OK".

Also verify chaining: `python -c "from interactive_gym.scenes.gym_scene import GymScene; s = GymScene(); result = s.runtime(run_through_pyodide=True); assert result is s; print('chaining OK')"`

Also verify old method still works: `python -c "from interactive_gym.scenes.gym_scene import GymScene; s = GymScene(); s.pyodide(run_through_pyodide=True); assert s.run_through_pyodide == True; print('old pyodide() still works')"`
  </verify>
  <done>
- `runtime()` method exists on GymScene
- Accepts exactly 6 browser execution params
- All validation logic matches `pyodide()` for those params
- Returns self for chaining
- Old `pyodide()` method is untouched and still works
  </done>
</task>

<task type="auto">
  <name>Task 2: Add multiplayer() method</name>
  <files>interactive_gym/scenes/gym_scene.py</files>
  <action>
Add a new `multiplayer()` method to GymScene. Place it AFTER the `runtime()` method (just added in Task 1).

This method merges ALL multiplayer-related params from:
1. `pyodide()` sync params (7 params)
2. `matchmaking()` (3 params)
3. `player_grouping()` (2 params)
4. `continuous_monitoring()` (6 params)
5. `exclusion_callbacks()` (2 params)
6. `reconnection_config()` (1 param)
7. `partner_disconnect_message_config()` (2 params)
8. `focus_loss_config()` (3 params)

Plus one NEW explicit param: `continuous_monitoring_enabled: bool = NotProvided`

Full method signature (use these EXACT parameter names):

```python
def multiplayer(
    self,
    # Sync/rollback params (from pyodide)
    multiplayer: bool = NotProvided,
    server_authoritative: bool = NotProvided,
    state_broadcast_interval: int = NotProvided,
    realtime_mode: bool = NotProvided,
    input_buffer_size: int = NotProvided,
    input_delay: int = NotProvided,
    input_confirmation_timeout_ms: int = NotProvided,
    # Matchmaking params (from matchmaking)
    hide_lobby_count: bool = NotProvided,
    max_rtt: int = NotProvided,
    matchmaker: "Matchmaker" = NotProvided,
    # Player grouping params (from player_grouping)
    wait_for_known_group: bool = NotProvided,
    group_wait_timeout: int = NotProvided,
    # Continuous monitoring params (from continuous_monitoring)
    continuous_monitoring_enabled: bool = NotProvided,
    continuous_max_ping: int = NotProvided,
    continuous_ping_violation_window: int = NotProvided,
    continuous_ping_required_violations: int = NotProvided,
    continuous_tab_warning_ms: int = NotProvided,
    continuous_tab_exclude_ms: int = NotProvided,
    continuous_exclusion_messages: dict[str, str] = NotProvided,
    # Exclusion callback params (from exclusion_callbacks)
    continuous_callback: Callable = NotProvided,
    continuous_callback_interval_frames: int = NotProvided,
    # Reconnection params (from reconnection_config)
    reconnection_timeout_ms: int = NotProvided,
    # Partner disconnect params (from partner_disconnect_message_config)
    partner_disconnect_message: str = NotProvided,
    partner_disconnect_show_completion_code: bool = NotProvided,
    # Focus loss params (from focus_loss_config)
    focus_loss_timeout_ms: int = NotProvided,
    focus_loss_message: str = NotProvided,
    pause_on_partner_background: bool = NotProvided,
):
```

CRITICAL PARAMETER-TO-ATTRIBUTE MAPPINGS (do NOT change attribute names):
- `multiplayer` param -> `self.pyodide_multiplayer` (NOT self.multiplayer!)
- `max_rtt` param -> `self.matchmaking_max_rtt` (NOT self.max_rtt!)
- `matchmaker` param -> `self._matchmaker` (private, with runtime Matchmaker import and isinstance check)
- `continuous_callback` param -> `self.continuous_exclusion_callback` (NOT self.continuous_callback!)
- All other params map to `self.<same_name>` (e.g., `server_authoritative` -> `self.server_authoritative`)

VALIDATION LOGIC TO PRESERVE (copy exactly from old methods):
- `multiplayer`: `assert isinstance(multiplayer, bool)`
- `server_authoritative`: `assert isinstance(server_authoritative, bool)`
- `state_broadcast_interval`: `assert isinstance(..., int) and ... > 0`
- `realtime_mode`: `assert isinstance(realtime_mode, bool)`
- `input_buffer_size`: `assert isinstance(..., int) and ... > 0`
- `input_delay`: `assert isinstance(..., int) and ... >= 0`
- `input_confirmation_timeout_ms`: `if not isinstance(..., int) or ... < 0: raise ValueError(...)`
- `max_rtt`: `if max_rtt is not None and max_rtt <= 0: raise ValueError(...)`
- `matchmaker`: runtime import `from interactive_gym.server.matchmaker import Matchmaker as MatchmakerABC`, then `if not isinstance(matchmaker, MatchmakerABC): raise TypeError(...)`
- `wait_for_known_group`: `assert isinstance(..., bool)`
- `group_wait_timeout`: `assert isinstance(..., int) and ... > 0`
- `continuous_max_ping`: `assert max_ping is None or (isinstance(max_ping, int) and max_ping > 0)` -- use `continuous_max_ping` as the variable name in the assertion message
- `continuous_ping_violation_window`: `assert isinstance(..., int) and ... >= 1`
- `continuous_ping_required_violations`: `assert isinstance(..., int) and ... >= 1`
- `continuous_tab_warning_ms`: `assert ... is None or (isinstance(..., int) and ... >= 0)`
- `continuous_tab_exclude_ms`: `assert ... is None or (isinstance(..., int) and ... >= 0)`
- `continuous_exclusion_messages`: `assert isinstance(..., dict)`, then merge: `self.continuous_exclusion_messages = {**self.continuous_exclusion_messages, **continuous_exclusion_messages}`
- `continuous_callback`: `if ... is not None and not callable(...): raise ValueError(...)`
- `continuous_callback_interval_frames`: `if not isinstance(..., int) or ... < 1: raise ValueError(...)`
- `reconnection_timeout_ms`: `if not isinstance(..., int) or ... <= 0: raise ValueError(...)`
- `focus_loss_timeout_ms`: `if not isinstance(..., int) or ... < 0: raise ValueError(...)`

CONTINUOUS MONITORING SIDE EFFECT:
- If `continuous_monitoring_enabled` param is provided, set `self.continuous_monitoring_enabled` to that value
- ALSO: If any continuous monitoring param (continuous_max_ping, continuous_ping_violation_window, continuous_ping_required_violations, continuous_tab_warning_ms, continuous_tab_exclude_ms, continuous_exclusion_messages) is provided AND continuous_monitoring_enabled was NOT explicitly set, auto-enable: `self.continuous_monitoring_enabled = True`
- After all assignments, perform the cross-validation: `if self.continuous_ping_required_violations > self.continuous_ping_violation_window: raise ValueError(...)`

DOCSTRING: Write a comprehensive docstring with sections grouping the params:
- Sync/Rollback Configuration
- Matchmaking
- Player Grouping
- Continuous Monitoring
- Exclusion Callbacks
- Reconnection
- Partner Disconnect
- Focus Loss

Return `self` at the end.

Do NOT modify any existing old methods.
  </action>
  <verify>
Run these verification commands:

1. Basic sync params: `python -c "from interactive_gym.scenes.gym_scene import GymScene; s = GymScene(); s.multiplayer(multiplayer=True, server_authoritative=True, input_delay=2); assert s.pyodide_multiplayer == True; assert s.server_authoritative == True; assert s.input_delay == 2; print('sync params OK')"`

2. Matchmaking params: `python -c "from interactive_gym.scenes.gym_scene import GymScene; s = GymScene(); s.multiplayer(hide_lobby_count=True, max_rtt=50); assert s.hide_lobby_count == True; assert s.matchmaking_max_rtt == 50; print('matchmaking OK')"`

3. Monitoring auto-enable: `python -c "from interactive_gym.scenes.gym_scene import GymScene; s = GymScene(); s.multiplayer(continuous_max_ping=200); assert s.continuous_monitoring_enabled == True; assert s.continuous_max_ping == 200; print('monitoring auto-enable OK')"`

4. Focus loss: `python -c "from interactive_gym.scenes.gym_scene import GymScene; s = GymScene(); s.multiplayer(focus_loss_timeout_ms=20000, pause_on_partner_background=True); assert s.focus_loss_timeout_ms == 20000; assert s.pause_on_partner_background == True; print('focus loss OK')"`

5. Chaining: `python -c "from interactive_gym.scenes.gym_scene import GymScene; s = GymScene(); result = s.multiplayer(multiplayer=True); assert result is s; print('chaining OK')"`

6. All old methods still work: `python -c "from interactive_gym.scenes.gym_scene import GymScene; s = GymScene(); s.matchmaking(hide_lobby_count=True); s.player_grouping(wait_for_known_group=True); s.continuous_monitoring(max_ping=200); s.exclusion_callbacks(); s.reconnection_config(timeout_ms=5000); s.partner_disconnect_message_config(message='bye'); s.focus_loss_config(timeout_ms=10000); print('all old methods still work')"`

7. Run existing tests: `cd /Users/chasemcd/Repositories/interactive-gym && python -m pytest tests/ -x -q 2>&1 | tail -5`
  </verify>
  <done>
- `multiplayer()` method exists on GymScene with ~26 params (24 from old methods + continuous_monitoring_enabled + original 7 sync params)
- Every parameter maps to the CORRECT instance attribute (especially the 4 non-obvious mappings)
- All validation logic from all 8 source methods is preserved
- continuous_monitoring_enabled auto-enables when monitoring params are provided
- Cross-validation (required_violations <= window) is preserved
- matchmaker runtime import and isinstance check preserved
- Returns self for chaining
- All old methods are untouched
  </done>
</task>

</tasks>

<verification>
After both tasks, verify the full surface:

1. `python -c "from interactive_gym.scenes.gym_scene import GymScene; s = GymScene(); print([m for m in dir(s) if not m.startswith('_') and callable(getattr(s, m))])"` -- should include BOTH old methods (pyodide, matchmaking, player_grouping, continuous_monitoring, exclusion_callbacks, reconnection_config, partner_disconnect_message_config, focus_loss_config) AND new methods (runtime, multiplayer).

2. `python -m pytest tests/ -x -q` -- all existing tests pass.

3. Verify method chaining works across old and new:
   `python -c "from interactive_gym.scenes.gym_scene import GymScene; s = GymScene().runtime(run_through_pyodide=True).multiplayer(multiplayer=True, server_authoritative=True); assert s.run_through_pyodide and s.pyodide_multiplayer and s.server_authoritative; print('cross-method chaining OK')"`
</verification>

<success_criteria>
- APIC-01: `runtime()` method exists with only 6 browser execution params
- APIC-02: Sync/rollback params available via `multiplayer()` method
- APIC-03: All 7 old method params merged into single `multiplayer()` method
- APIC-06: `policies()` and `gameplay()` are unchanged (verify they were not touched)
- All old methods still work (Phase 68 removes them, not Phase 67)
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/67-api-method-consolidation/67-01-SUMMARY.md`
</output>
