---
phase: 33-session-list
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/static/js/pyodide_multiplayer_game.js
  - interactive_gym/server/app.py
  - interactive_gym/server/admin/aggregator.py
  - interactive_gym/server/admin/templates/dashboard.html
  - interactive_gym/server/admin/static/admin.js
  - interactive_gym/server/admin/static/admin.css
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Each active session shows current episode number"
    - "Each session shows connection type (P2P direct / TURN relay / SocketIO fallback)"
    - "Each session shows current peer latency in milliseconds"
    - "Sessions display health indicator (healthy / degraded / reconnecting)"
    - "Problem sessions are visually distinguished from healthy ones"
  artifacts:
    - path: "interactive_gym/server/static/js/pyodide_multiplayer_game.js"
      provides: "P2P health reporting to server via SocketIO"
      contains: "emit.*p2p_health_report"
    - path: "interactive_gym/server/app.py"
      provides: "Handler for p2p_health_report event"
      contains: "on_p2p_health_report"
    - path: "interactive_gym/server/admin/aggregator.py"
      provides: "P2P health data storage and retrieval"
      contains: "_p2p_health_cache"
    - path: "interactive_gym/server/admin/templates/dashboard.html"
      provides: "Session list UI structure"
      contains: "session-list-container"
    - path: "interactive_gym/server/admin/static/admin.js"
      provides: "Session list rendering with health indicators"
      contains: "updateSessionList"
  key_links:
    - from: "pyodide_multiplayer_game.js"
      to: "app.py"
      via: "SocketIO p2p_health_report event"
      pattern: "emit.*p2p_health_report"
    - from: "app.py"
      to: "aggregator.py"
      via: "receive_p2p_health() method call"
      pattern: "aggregator\\.receive_p2p_health"
    - from: "aggregator.py"
      to: "admin.js"
      via: "state_update event includes p2p_health in multiplayer_games"
      pattern: "p2p_health"
---

<objective>
Add P2P health monitoring to the session list so researchers can see what's happening in each active game and quickly identify problem sessions.

Purpose: Enable real-time monitoring of P2P connection health during experiments - researchers need to know when sessions have degraded connections or reconnection issues.

Output:
- Client-side P2P health reporting (connection type, latency, status)
- Server-side collection and aggregation of P2P health data
- Dashboard session list showing health indicators with visual problem flagging
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-dashboard-summary/32-01-SUMMARY.md

# Existing P2P infrastructure
@interactive_gym/server/static/js/webrtc_manager.js
@interactive_gym/server/static/js/pyodide_multiplayer_game.js
@interactive_gym/server/admin/aggregator.py
@interactive_gym/server/admin/static/admin.js
@interactive_gym/server/admin/templates/dashboard.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add P2P health reporting from client to server</name>
  <files>
    interactive_gym/server/static/js/pyodide_multiplayer_game.js
    interactive_gym/server/app.py
    interactive_gym/server/admin/aggregator.py
  </files>
  <action>
    **In pyodide_multiplayer_game.js:**

    1. Add a `_reportP2PHealth()` method to the multiplayer game class that collects P2P metrics:
       - Connection type from `this.webrtc.getConnectionType()` (already exists)
       - Current latency from `this.latencyTelemetry.getStats()` (already exists)
       - Connection status derived from:
         - 'healthy' if latency < 150ms and ICE state is connected/completed
         - 'degraded' if latency >= 150ms or ICE state is checking
         - 'reconnecting' if `this.webrtc.iceRestartAttempts > 0` or reconnection_in_progress
       - Current episode number from `this.currentEpisode` (or track if not already tracked)
       - Game ID from `this.gameId`
       - Player ID from `this.myPlayerId`

    2. Call `this.socket.emit('p2p_health_report', {...})` with the collected data

    3. Set up a periodic reporter (every 2 seconds) that runs while game is active:
       - Start in `_onDataChannelOpen()` or when game starts
       - Stop when game ends or on cleanup
       - Use `setInterval` with ID stored for cleanup

    4. Track current episode number if not already tracked:
       - Initialize `this.currentEpisode = 0` in constructor
       - Increment in episode end handler

    **In app.py:**

    1. Add SocketIO handler `@socketio.on("p2p_health_report")`:
       ```python
       @socketio.on("p2p_health_report")
       def on_p2p_health_report(data):
           """Receive P2P health report from client."""
           if ADMIN_AGGREGATOR:
               ADMIN_AGGREGATOR.receive_p2p_health(
                   game_id=data.get('game_id'),
                   player_id=data.get('player_id'),
                   health_data={
                       'connection_type': data.get('connection_type'),
                       'latency_ms': data.get('latency_ms'),
                       'status': data.get('status'),
                       'episode': data.get('episode'),
                       'timestamp': time.time()
                   }
               )
       ```

    **In aggregator.py:**

    1. Add `_p2p_health_cache: dict` to `__init__()` - maps game_id -> {player_id -> health_data}

    2. Add `receive_p2p_health(self, game_id, player_id, health_data)` method:
       - Store in `_p2p_health_cache[game_id][player_id] = health_data`
       - Auto-expire entries older than 10 seconds (set timestamp, check on read)

    3. Modify `_get_multiplayer_games_state()` to include p2p_health:
       - For each game, lookup `_p2p_health_cache.get(game_id, {})`
       - Add to game dict: `'p2p_health': {player_id: health_data, ...}`
       - Derive overall session health: 'healthy' if all players healthy, 'degraded' if any degraded, 'reconnecting' if any reconnecting
       - Add `'current_episode'`: use max episode from player health reports
  </action>
  <verify>
    1. Start the server and open admin dashboard
    2. Start a multiplayer game (or use existing test setup)
    3. Open browser console on admin page and look for state_update events
    4. Confirm multiplayer_games array includes p2p_health objects with connection_type, latency_ms, status
  </verify>
  <done>
    - Multiplayer game clients emit p2p_health_report every 2 seconds
    - Server receives and stores P2P health data in aggregator cache
    - Admin state_update includes p2p_health data for each active game
  </done>
</task>

<task type="auto">
  <name>Task 2: Update session list UI to display P2P health indicators</name>
  <files>
    interactive_gym/server/admin/templates/dashboard.html
    interactive_gym/server/admin/static/admin.js
    interactive_gym/server/admin/static/admin.css
  </files>
  <action>
    **In dashboard.html:**

    1. Rename "Multiplayer Games" section to "Active Sessions" (reflects Phase 33's purpose)

    2. Update the section header to include a legend for health status colors:
       ```html
       <div class="flex items-center justify-between p-4 border-b border-base-200">
           <h2 class="text-lg font-semibold">Active Sessions</h2>
           <div class="flex items-center gap-3">
               <span class="health-legend"><span class="health-dot health-healthy"></span>Healthy</span>
               <span class="health-legend"><span class="health-dot health-degraded"></span>Degraded</span>
               <span class="health-legend"><span class="health-dot health-reconnecting"></span>Reconnecting</span>
               <span class="badge badge-ghost badge-sm" id="games-count">0 active</span>
           </div>
       </div>
       ```

    **In admin.js:**

    1. Rename `updateMultiplayerGames()` to `updateSessionList()` (update call site in `updateDashboard()`)

    2. Rewrite the function to render expanded session cards:
       ```javascript
       function updateSessionList(games) {
           const container = document.getElementById('multiplayer-games-container');
           const countBadge = document.getElementById('games-count');
           if (!container) return;

           if (countBadge) {
               countBadge.textContent = `${games?.length || 0} active`;
           }

           if (!games || games.length === 0) {
               container.innerHTML = `<div class="empty-state-sm">
                   <p class="text-base-content/50 text-sm">No active sessions</p>
               </div>`;
               return;
           }

           // Sort: problem sessions first (reconnecting > degraded > healthy)
           const sorted = [...games].sort((a, b) => {
               const priority = { 'reconnecting': 0, 'degraded': 1, 'healthy': 2 };
               const aStatus = a.session_health || 'healthy';
               const bStatus = b.session_health || 'healthy';
               return (priority[aStatus] || 2) - (priority[bStatus] || 2);
           });

           container.innerHTML = sorted.map(game => renderSessionCard(game)).join('');
       }
       ```

    3. Add `renderSessionCard(game)` function:
       ```javascript
       function renderSessionCard(game) {
           const health = game.session_health || 'healthy';
           const hasProblem = health !== 'healthy';
           const p2pHealth = game.p2p_health || {};

           // Get connection type (use first player's data, both should match)
           const firstPlayerHealth = Object.values(p2pHealth)[0] || {};
           const connectionType = firstPlayerHealth.connection_type || 'unknown';
           const connectionTypeLabel = getConnectionTypeLabel(connectionType);

           // Get latency (average of both players if available)
           const latencies = Object.values(p2pHealth).map(h => h.latency_ms).filter(l => l != null);
           const avgLatency = latencies.length > 0 ? Math.round(latencies.reduce((a,b) => a+b, 0) / latencies.length) : null;

           // Get episode
           const episode = game.current_episode ?? '--';

           return `
               <div class="session-card ${hasProblem ? 'session-problem' : ''}">
                   <div class="session-card-header">
                       <div class="session-card-title">
                           <span class="health-indicator health-${health}"></span>
                           <span class="session-id" title="${escapeHtml(game.game_id)}">
                               Session ${truncateId(game.game_id)}
                           </span>
                       </div>
                       <span class="badge badge-xs ${game.is_server_authoritative ? 'badge-warning' : 'badge-success'}">
                           ${game.is_server_authoritative ? 'Server Auth' : 'P2P'}
                       </span>
                   </div>
                   <div class="session-card-metrics">
                       <div class="session-metric">
                           <span class="session-metric-label">Episode</span>
                           <span class="session-metric-value">${episode}</span>
                       </div>
                       <div class="session-metric">
                           <span class="session-metric-label">Connection</span>
                           <span class="session-metric-value">${connectionTypeLabel}</span>
                       </div>
                       <div class="session-metric">
                           <span class="session-metric-label">Latency</span>
                           <span class="session-metric-value ${avgLatency && avgLatency > 150 ? 'text-warning' : ''}">
                               ${avgLatency != null ? avgLatency + 'ms' : '--'}
                           </span>
                       </div>
                       <div class="session-metric">
                           <span class="session-metric-label">Status</span>
                           <span class="session-metric-value session-status-${health}">
                               ${health.charAt(0).toUpperCase() + health.slice(1)}
                           </span>
                       </div>
                   </div>
                   <div class="session-card-players">
                       ${game.players.map(player => `
                           <span class="session-player ${player === game.host_id ? 'host' : ''}">
                               ${escapeHtml(truncateId(String(player)))}
                               ${player === game.host_id ? '<span class="host-badge">Host</span>' : ''}
                           </span>
                       `).join('')}
                   </div>
               </div>
           `;
       }
       ```

    4. Add `getConnectionTypeLabel(type)` helper:
       ```javascript
       function getConnectionTypeLabel(type) {
           if (!type || type === 'unknown') return 'Unknown';
           if (type === 'relay') return 'TURN Relay';
           if (type === 'direct') return 'P2P Direct';
           return type;
       }
       ```

    **In admin.css:**

    1. Add session card styles:
       ```css
       /* Session cards */
       .session-card {
           background: var(--fallback-b1,oklch(var(--b1)));
           border: 1px solid var(--fallback-b3,oklch(var(--b3)));
           border-radius: 0.5rem;
           padding: 0.75rem;
           margin-bottom: 0.5rem;
       }

       .session-card.session-problem {
           border-color: var(--fallback-wa,oklch(var(--wa)));
           background: var(--fallback-wa,oklch(var(--wa)/0.05));
       }

       .session-card-header {
           display: flex;
           justify-content: space-between;
           align-items: center;
           margin-bottom: 0.5rem;
       }

       .session-card-title {
           display: flex;
           align-items: center;
           gap: 0.5rem;
           font-weight: 500;
       }

       .health-indicator {
           width: 8px;
           height: 8px;
           border-radius: 50%;
           display: inline-block;
       }

       .health-indicator.health-healthy,
       .health-dot.health-healthy {
           background-color: var(--fallback-su,oklch(var(--su)));
       }

       .health-indicator.health-degraded,
       .health-dot.health-degraded {
           background-color: var(--fallback-wa,oklch(var(--wa)));
       }

       .health-indicator.health-reconnecting,
       .health-dot.health-reconnecting {
           background-color: var(--fallback-er,oklch(var(--er)));
           animation: pulse 1s infinite;
       }

       @keyframes pulse {
           0%, 100% { opacity: 1; }
           50% { opacity: 0.5; }
       }

       .session-card-metrics {
           display: grid;
           grid-template-columns: repeat(4, 1fr);
           gap: 0.5rem;
           margin-bottom: 0.5rem;
           font-size: 0.75rem;
       }

       .session-metric {
           display: flex;
           flex-direction: column;
       }

       .session-metric-label {
           color: var(--fallback-bc,oklch(var(--bc)/0.5));
           font-size: 0.65rem;
           text-transform: uppercase;
       }

       .session-metric-value {
           font-weight: 500;
       }

       .session-status-healthy { color: var(--fallback-su,oklch(var(--su))); }
       .session-status-degraded { color: var(--fallback-wa,oklch(var(--wa))); }
       .session-status-reconnecting { color: var(--fallback-er,oklch(var(--er))); }

       .session-card-players {
           display: flex;
           flex-wrap: wrap;
           gap: 0.25rem;
           font-size: 0.7rem;
       }

       .session-player {
           background: var(--fallback-b2,oklch(var(--b2)));
           padding: 0.125rem 0.375rem;
           border-radius: 0.25rem;
       }

       .session-player.host {
           background: var(--fallback-p,oklch(var(--p)/0.1));
       }

       .host-badge {
           font-size: 0.6rem;
           margin-left: 0.25rem;
           opacity: 0.7;
       }

       /* Health legend */
       .health-legend {
           display: flex;
           align-items: center;
           gap: 0.25rem;
           font-size: 0.65rem;
           color: var(--fallback-bc,oklch(var(--bc)/0.6));
       }

       .health-dot {
           width: 6px;
           height: 6px;
           border-radius: 50%;
           display: inline-block;
       }
       ```
  </action>
  <verify>
    1. Open admin dashboard
    2. Confirm "Active Sessions" section appears (renamed from "Multiplayer Games")
    3. With active sessions, verify each card shows:
       - Health indicator dot (colored based on status)
       - Episode number
       - Connection type (P2P Direct or TURN Relay)
       - Latency in ms
       - Status text
       - Player list
    4. Verify problem sessions (degraded/reconnecting) are visually highlighted
    5. Verify legend appears in header
  </verify>
  <done>
    - Session list shows episode number for each active game (LIST-01)
    - Session list shows connection type (LIST-02)
    - Session list shows latency (LIST-03)
    - Session list shows health indicator (LIST-04)
    - Problem sessions visually distinguished (LIST-05)
  </done>
</task>

<task type="auto">
  <name>Task 3: Handle SocketIO fallback indication</name>
  <files>
    interactive_gym/server/static/js/pyodide_multiplayer_game.js
    interactive_gym/server/admin/static/admin.js
  </files>
  <action>
    The requirements mention "SocketIO fallback" as a connection type. This happens when P2P fails entirely and the game falls back to server-relayed communication. Need to handle this edge case.

    **In pyodide_multiplayer_game.js:**

    1. In `_reportP2PHealth()`, check if WebRTC is not available or failed:
       ```javascript
       _reportP2PHealth() {
           if (!this.socket || !this.gameId) return;

           let connectionType = 'socketio_fallback';  // Default if no P2P
           let latencyMs = null;
           let status = 'healthy';  // SocketIO fallback still works

           if (this.webrtc && this.webrtc.isReady()) {
               // Get actual P2P data
               const connInfo = this.webrtc.connectionType;
               connectionType = connInfo?.connectionType || 'unknown';

               // Get latency
               if (this.latencyTelemetry) {
                   const stats = this.latencyTelemetry.getStats();
                   latencyMs = stats?.medianMs ?? stats?.meanMs ?? null;
               }

               // Determine status
               const iceState = this.webrtc.peerConnection?.iceConnectionState;
               if (this.webrtc.iceRestartAttempts > 0 || this._reconnectionInProgress) {
                   status = 'reconnecting';
               } else if (latencyMs && latencyMs > 150) {
                   status = 'degraded';
               } else if (iceState === 'connected' || iceState === 'completed') {
                   status = 'healthy';
               } else if (iceState === 'checking' || iceState === 'disconnected') {
                   status = 'degraded';
               }
           }

           this.socket.emit('p2p_health_report', {
               game_id: this.gameId,
               player_id: this.myPlayerId,
               connection_type: connectionType,
               latency_ms: latencyMs,
               status: status,
               episode: this.currentEpisode || 0
           });
       }
       ```

    **In admin.js:**

    1. Update `getConnectionTypeLabel()` to handle socketio_fallback:
       ```javascript
       function getConnectionTypeLabel(type) {
           if (!type || type === 'unknown') return 'Unknown';
           if (type === 'relay') return 'TURN Relay';
           if (type === 'direct') return 'P2P Direct';
           if (type === 'socketio_fallback') return 'SocketIO';
           return type;
       }
       ```

    2. Consider SocketIO fallback as 'degraded' for session_health calculation in aggregator:
       - If any player has `connection_type === 'socketio_fallback'`, mark session as degraded
  </action>
  <verify>
    1. If possible, test with P2P disabled (or in an environment where P2P fails)
    2. Verify session shows "SocketIO" as connection type
    3. Verify the label displays correctly in the UI
  </verify>
  <done>
    - SocketIO fallback connection type handled and displayed
    - All three connection types (P2P Direct, TURN Relay, SocketIO) properly labeled
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Data flow verification:**
   - Open browser dev tools on a client page in a multiplayer game
   - Verify p2p_health_report emitted every ~2 seconds
   - Verify server receives and stores the data (check server logs or admin state)

2. **UI verification:**
   - Open admin dashboard
   - Start a multiplayer game
   - Verify session appears with all metrics (episode, connection type, latency, status)
   - Verify health indicator shows correct color

3. **Problem highlighting:**
   - Simulate high latency or reconnection (if possible)
   - Verify session card gets highlighted border/background
   - Verify problem sessions sort to top of list

4. **Requirements check:**
   - LIST-01: Episode number visible
   - LIST-02: Connection type visible (P2P Direct / TURN Relay / SocketIO)
   - LIST-03: Latency in ms visible
   - LIST-04: Health status visible with color coding
   - LIST-05: Problem sessions visually distinguished
</verification>

<success_criteria>
- P2P health data flows from client -> server -> admin dashboard
- Each active session displays: episode, connection type, latency, health status
- Health status is color-coded (green/yellow/red)
- Problem sessions have highlighted card styling
- Session list sorts problem sessions to top
- All 5 LIST-* requirements satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/33-session-list/33-01-SUMMARY.md`
</output>
