---
phase: 04-turn-and-resilience
plan: 02
type: execute
wave: 2
depends_on: [04-01]
files_modified:
  - interactive_gym/configurations/remote_config.py
  - interactive_gym/server/pyodide_game_coordinator.py
  - interactive_gym/server/static/js/pyodide_multiplayer_game.js
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "TURN credentials configured in server can reach WebRTCManager"
    - "Environment variables provide TURN credentials to server"
    - "WebRTCManager receives TURN options and generates TURN candidates"
  artifacts:
    - path: "interactive_gym/configurations/remote_config.py"
      provides: "TURN credential configuration fields"
      contains: "turn_username"
    - path: "interactive_gym/server/pyodide_game_coordinator.py"
      provides: "TURN config passthrough in pyodide_game_ready event"
      contains: "turn_username"
    - path: "interactive_gym/server/static/js/pyodide_multiplayer_game.js"
      provides: "TURN credentials passed to WebRTCManager constructor"
      contains: "turnUsername"
  key_links:
    - from: "remote_config.py"
      to: "pyodide_game_coordinator.py"
      via: "game configuration"
      pattern: "turn_username"
    - from: "pyodide_game_coordinator.py"
      to: "pyodide_multiplayer_game.js"
      via: "pyodide_game_ready socket event"
      pattern: "turn_config"
    - from: "pyodide_multiplayer_game.js"
      to: "WebRTCManager constructor"
      via: "options parameter"
      pattern: "turnUsername.*turnCredential"
---

<objective>
Wire TURN credentials from server configuration through to WebRTCManager constructor.

Purpose: Close the gap identified in verification - WebRTCManager has TURN support implemented but credentials are never provided, so TURN fallback (WEBRTC-03) cannot work.

Output:
- Server-side TURN configuration in RemoteConfig
- TURN config passed via pyodide_game_ready event
- WebRTCManager instantiated with TURN options
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-turn-and-resilience/04-VERIFICATION.md
@.planning/phases/04-turn-and-resilience/04-01-SUMMARY.md

# Key files to modify
@interactive_gym/configurations/remote_config.py
@interactive_gym/server/pyodide_game_coordinator.py
@interactive_gym/server/static/js/pyodide_multiplayer_game.js
@interactive_gym/server/static/js/webrtc_manager.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TURN configuration to RemoteConfig</name>
  <files>interactive_gym/configurations/remote_config.py</files>
  <action>
Add TURN server configuration fields to the RemoteConfig class:

1. **Add TURN fields to __init__()** (around line 93, near the pyodide config):
```python
# webrtc / turn server configuration
self.turn_username: str | None = None
self.turn_credential: str | None = None
self.force_turn_relay: bool = False  # For testing TURN without direct P2P
```

2. **Add a webrtc() configuration method** (after the pyodide method or near end of class):
```python
def webrtc(
    self,
    turn_username: str | None = None,
    turn_credential: str | None = None,
    force_relay: bool = False,
):
    """
    Configure WebRTC settings for P2P multiplayer.

    Args:
        turn_username: TURN server username (from metered.ca or similar)
        turn_credential: TURN server credential/password
        force_relay: Force relay mode (for testing TURN without direct P2P)
    """
    if turn_username is not None:
        self.turn_username = turn_username
    if turn_credential is not None:
        self.turn_credential = turn_credential
    self.force_turn_relay = force_relay
    return self
```

The TURN credentials come from Open Relay Project (metered.ca) - users sign up and get a username/credential pair.
  </action>
  <verify>
Code check:
```bash
grep -n "turn_username" interactive_gym/configurations/remote_config.py
grep -n "def webrtc" interactive_gym/configurations/remote_config.py
```
  </verify>
  <done>
RemoteConfig has turn_username, turn_credential, and force_turn_relay fields with a webrtc() configuration method.
  </done>
</task>

<task type="auto">
  <name>Task 2: Pass TURN config through pyodide_game_ready event</name>
  <files>interactive_gym/server/pyodide_game_coordinator.py</files>
  <action>
Modify PyodideGameCoordinator to pass TURN configuration to clients:

1. **Update create_game() to accept TURN config** (around line 84):
Add parameters:
```python
def create_game(
    self,
    game_id: str,
    num_players: int,
    server_authoritative: bool = False,
    environment_code: str | None = None,
    state_broadcast_interval: int = 30,
    fps: int = 30,
    default_action: int = 0,
    action_population_method: str = "previous_submitted_action",
    realtime_mode: bool = True,
    input_buffer_size: int = 300,
    max_episodes: int = 1,
    max_steps: int = 10000,
    # New TURN config
    turn_username: str | None = None,
    turn_credential: str | None = None,
    force_turn_relay: bool = False,
) -> PyodideGameState:
```

2. **Add TURN config to PyodideGameState dataclass** (around line 27):
Add fields after the existing ones:
```python
# WebRTC TURN configuration
turn_username: str | None = None
turn_credential: str | None = None
force_turn_relay: bool = False
```

3. **Store TURN config when creating game state** (in create_game body):
```python
game = PyodideGameState(
    # ... existing fields ...
    turn_username=turn_username,
    turn_credential=turn_credential,
    force_turn_relay=force_turn_relay,
)
```

4. **Include TURN config in pyodide_game_ready event** (around line 275):
Update the emit call to include turn_config:
```python
self.sio.emit('pyodide_game_ready',
             {
                 'game_id': game_id,
                 'players': list(game.players.keys()),
                 'player_subjects': game.player_subjects,
                 'server_authoritative': game.server_authoritative,
                 # Add TURN config
                 'turn_config': {
                     'username': game.turn_username,
                     'credential': game.turn_credential,
                     'force_relay': game.force_turn_relay,
                 } if game.turn_username else None,
             },
             room=game_id)
```

Note: Only include turn_config if username is set. Client will handle None gracefully.
  </action>
  <verify>
Code check:
```bash
grep -n "turn_username" interactive_gym/server/pyodide_game_coordinator.py
grep -n "turn_config" interactive_gym/server/pyodide_game_coordinator.py
```
  </verify>
  <done>
PyodideGameCoordinator stores TURN config in game state and passes it via pyodide_game_ready event.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire TURN config to WebRTCManager in multiplayer game</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Modify MultiplayerPyodideGame to read TURN config and pass to WebRTCManager:

1. **Store TURN config from pyodide_game_ready** (around line 465 in the socket handler):
After receiving pyodide_game_ready, store the turn_config:
```javascript
socket.on('pyodide_game_ready', (data) => {
    console.log(`[MultiplayerPyodide] Game ${data.game_id} ready with players:`, data.players);

    // Store TURN configuration for P2P
    this.turnConfig = data.turn_config || null;
    if (this.turnConfig) {
        console.log('[MultiplayerPyodide] TURN config received');
    }

    // ... rest of existing handler ...
});
```

2. **Pass TURN options to WebRTCManager** (around line 2496 in _initP2PConnection):
Change from:
```javascript
this.webrtcManager = new WebRTCManager(socket, this.gameId, this.myPlayerId);
```
To:
```javascript
// Build WebRTC options with TURN config if available
const webrtcOptions = {};
if (this.turnConfig) {
    webrtcOptions.turnUsername = this.turnConfig.username;
    webrtcOptions.turnCredential = this.turnConfig.credential;
    webrtcOptions.forceRelay = this.turnConfig.force_relay || false;
    console.log('[MultiplayerPyodide] Initializing WebRTC with TURN support');
}

this.webrtcManager = new WebRTCManager(socket, this.gameId, this.myPlayerId, webrtcOptions);
```

3. **Initialize turnConfig in constructor** (around line 310):
Add after existing state initialization:
```javascript
// TURN server configuration (populated by pyodide_game_ready)
this.turnConfig = null;
```

This wires the TURN credentials from server config through to WebRTCManager, where `_getIceServers()` will add the TURN server URLs when credentials are present.
  </action>
  <verify>
Code check:
```bash
grep -n "turnConfig" interactive_gym/server/static/js/pyodide_multiplayer_game.js
grep -n "turnUsername" interactive_gym/server/static/js/pyodide_multiplayer_game.js
grep -n "WebRTCManager.*webrtcOptions" interactive_gym/server/static/js/pyodide_multiplayer_game.js
```

Manual test (if TURN credentials available):
1. Configure experiment with TURN credentials via remote_config.webrtc()
2. Start multiplayer game
3. Check console for "[MultiplayerPyodide] TURN config received"
4. Check console for "[WebRTC] TURN servers configured" (from webrtc_manager.js)
  </verify>
  <done>
MultiplayerPyodideGame reads TURN config from pyodide_game_ready event and passes to WebRTCManager constructor. TURN credentials flow from server config to WebRTC ICE configuration.
  </done>
</task>

</tasks>

<verification>
**Gap Closure Verification:**

The original gap was: "WebRTCManager created without options - no TURN credentials passed"

After this plan:
1. Server config has TURN fields (remote_config.py)
2. Game coordinator passes TURN config via socket event (pyodide_game_coordinator.py)
3. Game reads config and passes to WebRTCManager (pyodide_multiplayer_game.js)
4. WebRTCManager's `_getIceServers()` will now receive credentials and add TURN servers

**Requirement Coverage:**
- WEBRTC-03 (TURN server fallback): Now fully wired - credentials can reach WebRTCManager

**Test Commands:**
```bash
# Verify configuration flow
grep -n "turn_username" interactive_gym/configurations/remote_config.py
grep -n "turn_config" interactive_gym/server/pyodide_game_coordinator.py
grep -n "turnUsername" interactive_gym/server/static/js/pyodide_multiplayer_game.js

# Verify WebRTCManager receives options
grep -n "new WebRTCManager.*webrtcOptions" interactive_gym/server/static/js/pyodide_multiplayer_game.js
```

**End-to-end Test (requires TURN credentials):**
1. Get credentials from metered.ca/tools/openrelay
2. Configure experiment:
```python
config.webrtc(
    turn_username="your-username",
    turn_credential="your-credential"
)
```
3. Start multiplayer game between two browsers
4. Check console for TURN configuration logs
5. With `force_relay=True`, verify connection type is 'relay'
</verification>

<success_criteria>
- [ ] RemoteConfig has turn_username, turn_credential, force_turn_relay fields
- [ ] RemoteConfig has webrtc() configuration method
- [ ] PyodideGameState dataclass has TURN config fields
- [ ] create_game() accepts TURN config parameters
- [ ] pyodide_game_ready event includes turn_config object
- [ ] MultiplayerPyodideGame stores turnConfig from event
- [ ] WebRTCManager created with webrtcOptions containing TURN credentials
- [ ] Console shows "[WebRTC] TURN servers configured" when credentials provided
</success_criteria>

<output>
After completion, create `.planning/phases/04-turn-and-resilience/04-02-SUMMARY.md` using the summary template.
</output>
