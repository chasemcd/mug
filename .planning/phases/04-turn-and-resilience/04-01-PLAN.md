---
phase: 04-turn-and-resilience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/static/js/webrtc_manager.js
  - interactive_gym/server/static/js/pyodide_multiplayer_game.js
autonomous: true
user_setup:
  - service: Open Relay Project (Metered.ca)
    why: "Free TURN relay server for NAT traversal"
    env_vars: []
    dashboard_config:
      - task: "Sign up at metered.ca/tools/openrelay for free API key (optional - static credentials work initially)"
        location: "https://www.metered.ca/tools/openrelay/"

must_haves:
  truths:
    - "TURN relay candidates are generated when TURN credentials provided"
    - "Connection type (direct vs relay) is detected after connection"
    - "Connection type is logged in session data for research"
    - "Quality degradation triggers warning callback"
    - "ICE restart attempted when connection fails"
  artifacts:
    - path: "interactive_gym/server/static/js/webrtc_manager.js"
      provides: "TURN configuration, getConnectionType(), ConnectionQualityMonitor, ICE restart"
      exports: ["WebRTCManager"]
    - path: "interactive_gym/server/static/js/pyodide_multiplayer_game.js"
      provides: "Connection type logging integration"
      contains: "_logConnectionType"
  key_links:
    - from: "webrtc_manager.js"
      to: "RTCPeerConnection.getStats()"
      via: "getConnectionType method"
      pattern: "peerConnection\\.getStats\\(\\)"
    - from: "pyodide_multiplayer_game.js"
      to: "webrtcManager.connectionType"
      via: "connection type logging"
      pattern: "connectionType"
---

<objective>
Add TURN server fallback for NAT traversal and connection type detection for research analytics.

Purpose: Ensure P2P connections succeed even when direct connections fail (symmetric NAT, corporate firewalls), and log connection type for research data analysis.

Output:
- WebRTCManager with TURN server configuration
- Connection type detection via getStats() API
- ConnectionQualityMonitor for degradation warnings
- ICE restart for connection recovery
- Connection type logged in session data
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-turn-and-resilience/04-RESEARCH.md

# Prior phase context
@.planning/phases/03-ggpo-p2p-integration/03-01-SUMMARY.md

# Key files
@interactive_gym/server/static/js/webrtc_manager.js
@interactive_gym/server/static/js/pyodide_multiplayer_game.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TURN configuration and connection type detection to WebRTCManager</name>
  <files>interactive_gym/server/static/js/webrtc_manager.js</files>
  <action>
Modify WebRTCManager class:

1. **Update constructor** to accept options object (4th parameter):
```javascript
constructor(socket, gameId, myPlayerId, options = {}) {
    // ... existing properties ...

    // TURN configuration
    this.turnUsername = options.turnUsername || null;
    this.turnCredential = options.turnCredential || null;
    this.forceRelay = options.forceRelay || false;

    // Connection monitoring
    this.connectionType = null;
    this.iceRestartAttempts = 0;
    this.maxIceRestarts = 3;
    this.disconnectTimeoutId = null;

    // Callbacks
    this.onConnectionTypeDetected = null;
    this.onQualityDegraded = null;
}
```

2. **Add `_getIceServers()` method** returning array with STUN + TURN servers:
- Always include Google STUN servers
- If turnUsername and turnCredential provided, add 4 TURN server URLs:
  - `turn:a.relay.metered.ca:80` (UDP)
  - `turn:a.relay.metered.ca:80?transport=tcp` (TCP)
  - `turn:a.relay.metered.ca:443` (UDP on 443)
  - `turns:a.relay.metered.ca:443?transport=tcp` (TLS)

3. **Modify `_createPeerConnection()`**:
- Call `_getIceServers()` for iceServers config
- If `forceRelay` is true, set `iceTransportPolicy: 'relay'`
- Add connection type detection on 'connected' state

4. **Add `getConnectionType()` async method**:
- Uses getStats() to find selected candidate pair
- Checks candidateType for 'relay' on local or remote candidate
- Returns object: `{ connectionType: 'direct'|'relay', localCandidateType, remoteCandidateType, protocol, relayProtocol }`
- See RESEARCH.md Pattern 2 for implementation

5. **Add `_detectConnectionType()` private method**:
- Calls getConnectionType()
- Sets this.connectionType
- Invokes this.onConnectionTypeDetected callback if set
- Log: `[WebRTC] Connection type: { direct|relay, details }`

Key patterns from RESEARCH.md:
- Use transport stats `selectedCandidatePairId` to find active pair
- Check `candidateType === 'relay'` on either local or remote candidate
- Handle missing properties gracefully (null checks)
  </action>
  <verify>
Manual test:
1. Start multiplayer game, observe console for `[WebRTC] Connection type:` log
2. Test with `forceRelay: true` in constructor options, verify relay candidates appear
3. Verify getConnectionType() returns expected structure

Code check:
- grep for `_getIceServers` in webrtc_manager.js
- grep for `getConnectionType` in webrtc_manager.js
  </verify>
  <done>
WebRTCManager accepts TURN credentials, includes TURN servers in ICE config, and detects connection type after connection established. getConnectionType() returns 'direct' or 'relay' based on active candidate pair.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ConnectionQualityMonitor and ICE restart recovery</name>
  <files>interactive_gym/server/static/js/webrtc_manager.js</files>
  <action>
Add connection quality monitoring and ICE restart for resilience:

1. **Add `ConnectionQualityMonitor` class** (before WebRTCManager class):
```javascript
class ConnectionQualityMonitor {
    constructor(peerConnection, options = {}) {
        this.pc = peerConnection;
        this.pollInterval = options.pollInterval || 2000;
        this.warningLatencyMs = options.warningLatency || 150;
        this.criticalLatencyMs = options.criticalLatency || 300;
        this.lastStats = null;
        this.intervalId = null;

        // Callbacks
        this.onQualityChange = null;
        this.onDegradation = null;
    }

    start() { ... }  // Start polling interval
    stop() { ... }   // Clear interval
    async _poll() { ... }  // Get stats, extract metrics, check thresholds
    _extractQualityMetrics(stats) { ... }  // RTT, bytes, packets from candidate-pair
    _checkThresholds(quality) { ... }  // Compare RTT to thresholds, invoke callbacks
}
```
See RESEARCH.md Pattern 3 for full implementation.

2. **Add ICE restart handling to WebRTCManager**:
- Modify `oniceconnectionstatechange` handler:
  - On 'failed': call `_handleIceFailure()`
  - On 'disconnected': start 5-second timeout, then try restart
  - On 'connected'/'completed': cancel timeout, log connection type, start quality monitoring

3. **Add `_handleIceFailure()` method**:
- Check if iceRestartAttempts >= maxIceRestarts
- If max reached: log error, invoke onConnectionFailed
- Otherwise: increment attempts, call `peerConnection.restartIce()`
- Log: `[WebRTC] ICE restart attempt N/3`

4. **Add `_startDisconnectTimeout()` and `_cancelDisconnectTimeout()` methods**:
- Start 5-second timeout on 'disconnected' state
- If still disconnected after timeout, call `_handleIceFailure()`
- Cancel timeout if state changes to 'connected'

5. **Add `_startQualityMonitoring()` method** in WebRTCManager:
- Create ConnectionQualityMonitor instance
- Set onDegradation callback to invoke this.onQualityDegraded
- Call start()
- Store reference: this.qualityMonitor

6. **Update `close()` method**:
- Stop quality monitor: `this.qualityMonitor?.stop()`
- Cancel disconnect timeout
- Clear qualityMonitor reference

Export ConnectionQualityMonitor alongside WebRTCManager.
  </action>
  <verify>
Code check:
- grep for `ConnectionQualityMonitor` in webrtc_manager.js
- grep for `restartIce` in webrtc_manager.js
- grep for `_handleIceFailure` in webrtc_manager.js

Manual test:
1. Start game, verify no errors
2. Check console for quality polling logs (if any)
3. Simulate disconnect (if possible) to verify ICE restart logs
  </verify>
  <done>
ConnectionQualityMonitor class polls getStats() for RTT metrics and invokes callbacks on degradation. ICE restart attempted on failure with max 3 attempts. Disconnect timeout gives 5 seconds before treating as failure.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate connection type logging into game flow</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Wire up connection type detection and logging in MultiplayerPyodideGame:

1. **Add connection type callback** in `_initP2P()` after WebRTCManager creation:
```javascript
this.webrtcManager.onConnectionTypeDetected = (connInfo) => {
    this._logConnectionType(connInfo);
};

this.webrtcManager.onQualityDegraded = (info) => {
    console.warn('[P2P Quality] Degraded:', info);
    // Optionally trigger UI warning or SocketIO fallback
};
```

2. **Add `_logConnectionType(connInfo)` method**:
```javascript
_logConnectionType(connInfo) {
    console.log('[P2P] Connection type:', connInfo.connectionType, connInfo);

    // Store in p2pMetrics for episode summary
    this.p2pMetrics.connectionType = connInfo.connectionType;
    this.p2pMetrics.connectionDetails = {
        localCandidateType: connInfo.localCandidateType,
        remoteCandidateType: connInfo.remoteCandidateType,
        protocol: connInfo.localProtocol || connInfo.protocol,
        relayProtocol: connInfo.relayProtocol,
        detectedAtFrame: this.frameNumber,
        timestamp: Date.now()
    };

    // Emit to server for research data persistence
    this.socket.emit('p2p_connection_type', {
        game_id: this.gameId,
        player_id: this.myPlayerId,
        connection_type: connInfo.connectionType,
        details: this.p2pMetrics.connectionDetails
    });
}
```

3. **Update episode summary** to include connection type:
Find the episode summary logging (around `[Episode]` log) and add:
```javascript
const p2pType = this.p2pMetrics.connectionType || 'unknown';
console.log(`[Episode] ... P2P type: ${p2pType}`);
```

4. **Ensure p2pMetrics initialization** includes connectionType field:
In p2pMetrics initialization, add:
```javascript
connectionType: null,
connectionDetails: null
```

Note: The server-side `p2p_connection_type` event handler is optional for Phase 4. The console logging alone satisfies WEBRTC-04 for research analytics. Server persistence can be added in Phase 5 if needed.
  </action>
  <verify>
Manual test:
1. Start multiplayer game
2. Observe console for `[P2P] Connection type: direct` or `[P2P] Connection type: relay`
3. Complete episode, verify episode summary includes P2P type

Code check:
- grep for `_logConnectionType` in pyodide_multiplayer_game.js
- grep for `connectionType` in pyodide_multiplayer_game.js
- grep for `p2p_connection_type` in pyodide_multiplayer_game.js
  </verify>
  <done>
Connection type logged to console and stored in p2pMetrics. Episode summary includes P2P connection type. Socket event emitted for server-side persistence (handler optional).
  </done>
</task>

</tasks>

<verification>
**Requirement Coverage:**
- WEBRTC-03 (TURN fallback): TURN servers configured in `_getIceServers()`, relay candidates generated
- WEBRTC-04 (Connection type detection): `getConnectionType()` detects direct vs relay, logged in session

**Success Criteria Verification:**
1. TURN credentials configured: `_getIceServers()` includes TURN URLs with credentials
2. Connection type detected via getStats(): `getConnectionType()` method implemented
3. Logged for research: `_logConnectionType()` emits socket event + console log
4. Quality degradation warnings: `ConnectionQualityMonitor.onDegradation` callback
5. ICE restart recovery: `_handleIceFailure()` with max 3 attempts

**Test Commands:**
```bash
# Verify code structure
grep -n "_getIceServers" interactive_gym/server/static/js/webrtc_manager.js
grep -n "getConnectionType" interactive_gym/server/static/js/webrtc_manager.js
grep -n "ConnectionQualityMonitor" interactive_gym/server/static/js/webrtc_manager.js
grep -n "_logConnectionType" interactive_gym/server/static/js/pyodide_multiplayer_game.js
```

**Manual Testing:**
1. Start game without TURN credentials -> connection should work (direct P2P)
2. Start game with `forceRelay: true` -> should fail (no TURN creds) or use relay (with creds)
3. Check browser console for connection type logs
4. Complete episode, verify P2P type in summary
</verification>

<success_criteria>
- [ ] WebRTCManager constructor accepts options with turnUsername, turnCredential, forceRelay
- [ ] `_getIceServers()` returns STUN + TURN servers when credentials provided
- [ ] `getConnectionType()` returns { connectionType: 'direct'|'relay', ... } via getStats()
- [ ] `ConnectionQualityMonitor` class polls RTT and invokes callbacks on degradation
- [ ] ICE restart attempted on failure, max 3 attempts before giving up
- [ ] Connection type logged to console: `[P2P] Connection type: direct|relay`
- [ ] p2pMetrics includes connectionType in episode summary
- [ ] Socket event `p2p_connection_type` emitted for server persistence
</success_criteria>

<output>
After completion, create `.planning/phases/04-turn-and-resilience/04-01-SUMMARY.md` using the summary template.
</output>
