---
phase: 12-p2p-hash-exchange
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/static/js/pyodide_multiplayer_game.js
autonomous: true

must_haves:
  truths:
    - "State hashes sent via P2P DataChannel after frame confirmation"
    - "Hash exchange does not block game loop or frame advancement"
    - "Received peer hashes stored for later comparison (Phase 13)"
    - "Hash data structures cleared on rollback for affected frames"
    - "Binary message format uses exactly 13 bytes"
  artifacts:
    - path: "interactive_gym/server/static/js/pyodide_multiplayer_game.js"
      provides: "P2P hash exchange protocol"
      contains: "P2P_MSG_STATE_HASH"
  key_links:
    - from: "_computeAndStoreConfirmedHash"
      to: "pendingHashExchange"
      via: "array push after hash computation"
      pattern: "this\\.pendingHashExchange\\.push"
    - from: "step loop"
      to: "_exchangePendingHashes"
      via: "method call after _updateConfirmedFrame"
      pattern: "_exchangePendingHashes"
    - from: "onDataChannelMessage"
      to: "pendingPeerHashes"
      via: "P2P_MSG_STATE_HASH handler"
      pattern: "case P2P_MSG_STATE_HASH"
---

<objective>
Implement P2P binary hash exchange protocol over DataChannel for sync validation.

Purpose: Enable peers to exchange state hashes after frame confirmation so desync detection (Phase 13) can compare local and remote hashes to identify non-determinism.

Output: Working hash exchange protocol - hashes queued on confirmation, sent via P2P, received and stored in pendingPeerHashes map for later comparison.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-hash-infrastructure/11-01-SUMMARY.md
@interactive_gym/server/static/js/pyodide_multiplayer_game.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add P2P_MSG_STATE_HASH constant and encode/decode functions</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Add the P2P_MSG_STATE_HASH constant and encode/decode functions at the top of the file, after the existing P2P message constants (around line 45).

1. Add constant after P2P_MSG_EPISODE_READY:
```javascript
const P2P_MSG_STATE_HASH = 0x07;  // State hash for sync validation
```

2. Add encodeStateHash function after encodeEpisodeReady (around line 220):
```javascript
/**
 * Encode a state hash message for P2P transmission.
 * Used for sync validation - peers exchange hashes of confirmed frames.
 * Format: 13 bytes
 *   Byte 0: Message type (0x07)
 *   Bytes 1-4: Frame number (uint32, big-endian)
 *   Bytes 5-12: Hash value (8 bytes from 16 hex chars)
 *
 * @param {number} frameNumber - Frame this hash corresponds to
 * @param {string} hash - 16-char hex hash (SHA-256 truncated)
 * @returns {ArrayBuffer} Encoded packet (13 bytes)
 */
function encodeStateHash(frameNumber, hash) {
    const buffer = new ArrayBuffer(13);
    const view = new DataView(buffer);
    view.setUint8(0, P2P_MSG_STATE_HASH);
    view.setUint32(1, frameNumber, false);  // big-endian
    // Write 8 bytes of hash (16 hex chars = 8 bytes)
    for (let i = 0; i < 8; i++) {
        const hexPair = hash.substring(i * 2, i * 2 + 2);
        view.setUint8(5 + i, parseInt(hexPair, 16));
    }
    return buffer;
}
```

3. Add decodeStateHash function after encodeStateHash:
```javascript
/**
 * Decode a state hash message from P2P transmission.
 *
 * @param {ArrayBuffer} buffer - Received packet
 * @returns {{frameNumber: number, hash: string}|null} Decoded data or null if wrong type
 */
function decodeStateHash(buffer) {
    const view = new DataView(buffer);
    const type = view.getUint8(0);
    if (type !== P2P_MSG_STATE_HASH) return null;

    const frameNumber = view.getUint32(1, false);
    // Read 8 bytes and convert back to 16-char hex string
    let hash = '';
    for (let i = 0; i < 8; i++) {
        const byte = view.getUint8(5 + i);
        hash += byte.toString(16).padStart(2, '0');
    }
    return { frameNumber, hash };
}
```

Note: The hash encoding converts 16 hex chars to 8 bytes (each hex pair = 1 byte), which is more compact than the 8-char ASCII encoding used by encodeEpisodeReady. This matches the architecture spec for binary efficiency.
  </action>
  <verify>
Search for P2P_MSG_STATE_HASH in the file to confirm constant exists.
Search for encodeStateHash and decodeStateHash to confirm functions exist.
Verify buffer size is 13 bytes in the encodeStateHash function.
  </verify>
  <done>
P2P_MSG_STATE_HASH = 0x07 constant defined.
encodeStateHash() creates 13-byte binary packet (type + frame + hash).
decodeStateHash() parses packet back to {frameNumber, hash}.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add hash exchange data structures and queue on confirmation</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Add data structures in constructor and modify _computeAndStoreConfirmedHash to queue hashes.

1. In the MultiplayerPyodideGame constructor, after confirmedHashHistoryMaxSize (around line 514), add:
```javascript
// Pending hash exchange: hashes computed but not yet sent to peer
// [{frame: number, hash: string}, ...]
this.pendingHashExchange = [];

// Pending peer hashes: hashes received from peer awaiting comparison (Phase 13)
// Map<frameNumber, hash>
this.pendingPeerHashes = new Map();
```

2. Modify _computeAndStoreConfirmedHash to queue hash for exchange after storing it.
After the line `this.confirmedHashHistory.set(frameNumber, hash);` (around line 1991), add:
```javascript
// Queue hash for P2P exchange (EXCH-02: async, non-blocking)
this.pendingHashExchange.push({ frame: frameNumber, hash: hash });
```

This ensures hashes are queued asynchronously without blocking - they will be sent in the next step loop iteration via _exchangePendingHashes().
  </action>
  <verify>
Search for "pendingHashExchange" to confirm array initialization in constructor.
Search for "pendingPeerHashes" to confirm Map initialization in constructor.
Search for "pendingHashExchange.push" to confirm queue operation in _computeAndStoreConfirmedHash.
  </verify>
  <done>
pendingHashExchange array initialized in constructor for outbound hash queue.
pendingPeerHashes Map initialized in constructor for inbound hash storage.
_computeAndStoreConfirmedHash queues hashes for exchange after storing.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add _exchangePendingHashes method and call from step loop</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Add the exchange method and integrate into the step loop.

1. Add _exchangePendingHashes method after _pruneConfirmedHashHistory (around line 2022):
```javascript
/**
 * Send pending state hashes to peer via P2P DataChannel.
 * Called from step loop after _updateConfirmedFrame completes.
 * Skipped during rollback to avoid sending hashes from mid-replay state.
 * (EXCH-01: P2P DataChannel, EXCH-02: non-blocking, EXCH-04: binary format)
 */
_exchangePendingHashes() {
    // Skip if rollback in progress (hash would be from mid-replay state)
    if (this.rollbackInProgress) {
        return;
    }

    // Skip if no P2P connection ready
    if (!this.webrtcManager?.isReady()) {
        // Keep hashes queued - will send when connection recovers
        return;
    }

    // Drain pending hash queue
    while (this.pendingHashExchange.length > 0) {
        const { frame, hash } = this.pendingHashExchange.shift();

        // Encode and send via P2P
        const packet = encodeStateHash(frame, hash);
        const sent = this.webrtcManager.send(packet);

        if (sent) {
            p2pLog.debug(`Sent hash for frame ${frame}: ${hash}`);
        } else {
            // Send failed (buffer full) - re-queue at front and stop
            // Better to delay than to lose hash data
            this.pendingHashExchange.unshift({ frame, hash });
            p2pLog.debug(`Hash send buffer full, re-queued frame ${frame}`);
            break;
        }
    }
}
```

2. In the step() method, add call to _exchangePendingHashes after the _updateConfirmedFrame call.
Find the line (around 1447):
```javascript
await this._updateConfirmedFrame();
```

Add immediately after it:
```javascript
// Exchange any pending hashes with peer (EXCH-01, EXCH-02)
this._exchangePendingHashes();
```

This placement ensures:
- Hashes are sent AFTER confirmation logic runs (so newly confirmed frames get queued)
- Non-blocking (synchronous drain of queue, async send)
- After rollback completes (if any), so we're not in mid-replay state
  </action>
  <verify>
Search for "_exchangePendingHashes" to confirm method exists.
Search for "this._exchangePendingHashes()" to confirm it's called in step loop.
Verify the call is after _updateConfirmedFrame in the step method.
  </verify>
  <done>
_exchangePendingHashes() method drains queue and sends hashes via P2P.
Method skips during rollback to avoid invalid state hashes.
Method called in step loop after _updateConfirmedFrame().
  </done>
</task>

<task type="auto">
  <name>Task 4: Add P2P_MSG_STATE_HASH handler and rollback invalidation</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Add message handler for received hashes and invalidation logic for rollback.

1. Add handler method after _exchangePendingHashes:
```javascript
/**
 * Handle received state hash from peer.
 * Stores hash in pendingPeerHashes for later comparison (Phase 13: DETECT-02).
 * @param {ArrayBuffer} buffer - Received P2P message
 */
_handleStateHash(buffer) {
    const decoded = decodeStateHash(buffer);
    if (!decoded) {
        p2pLog.warn('Failed to decode state hash message');
        return;
    }

    const { frameNumber, hash } = decoded;

    // Store for later comparison (Phase 13 will implement comparison logic)
    this.pendingPeerHashes.set(frameNumber, hash);

    p2pLog.debug(`Received peer hash for frame ${frameNumber}: ${hash}`);
}
```

2. Add case to the switch statement in _handleDataChannelMessage (around line 3488).
After the P2P_MSG_EPISODE_READY case, add:
```javascript
case P2P_MSG_STATE_HASH:
    this._handleStateHash(buffer);
    break;
```

3. In performRollback, add invalidation of pendingPeerHashes after confirmedHashHistory invalidation.
Find the block (around line 2841-2846):
```javascript
for (const frame of this.confirmedHashHistory.keys()) {
    if (frame >= targetFrame) {
        this.confirmedHashHistory.delete(frame);
    }
}
p2pLog.debug(`Invalidated confirmed hashes >= frame ${targetFrame}`);
```

Add immediately after:
```javascript
// Invalidate pending peer hashes from rollback point onward (EXCH-03)
// These will be re-received when peer re-confirms after their rollback
for (const frame of this.pendingPeerHashes.keys()) {
    if (frame >= targetFrame) {
        this.pendingPeerHashes.delete(frame);
    }
}

// Clear outbound queue - these hashes are for states being overwritten
this.pendingHashExchange = this.pendingHashExchange.filter(h => h.frame < targetFrame);
```

4. In clearGGPOState, add clearing of hash exchange structures.
After the line `this.confirmedHashHistory.clear();` (around line 3207), add:
```javascript
// Clear hash exchange structures for new episode (EXCH-03)
this.pendingHashExchange = [];
this.pendingPeerHashes.clear();
```
  </action>
  <verify>
Search for "_handleStateHash" to confirm method exists.
Search for "case P2P_MSG_STATE_HASH" to confirm switch case exists.
Search for "pendingPeerHashes.delete" to confirm rollback invalidation.
Search for "pendingHashExchange = \[\]" in clearGGPOState to confirm reset.
  </verify>
  <done>
_handleStateHash() stores received peer hashes in pendingPeerHashes.
P2P_MSG_STATE_HASH case added to message handler switch.
performRollback() invalidates pendingPeerHashes and pendingHashExchange for frames >= target.
clearGGPOState() clears both hash exchange structures on episode reset.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Code verification - search for all new elements:
   - P2P_MSG_STATE_HASH constant (0x07)
   - encodeStateHash function
   - decodeStateHash function
   - pendingHashExchange array in constructor
   - pendingPeerHashes Map in constructor
   - _exchangePendingHashes method
   - _handleStateHash method
   - P2P_MSG_STATE_HASH case in switch
   - Invalidation in performRollback
   - Clearing in clearGGPOState

2. Integration verification:
   - _exchangePendingHashes called after _updateConfirmedFrame in step()
   - pendingHashExchange.push in _computeAndStoreConfirmedHash

3. Manual test (if game is runnable):
   - Start 2-player game
   - Open browser console on both clients
   - Look for "Sent hash for frame" and "Received peer hash for frame" log messages
   - Verify hashes are exchanged after frames confirm
</verification>

<success_criteria>
- EXCH-01: P2P_MSG_STATE_HASH (0x07) sent via webrtcManager.send()
- EXCH-02: _exchangePendingHashes is synchronous drain, doesn't await, called from step loop
- EXCH-03: pendingPeerHashes and pendingHashExchange invalidated in performRollback() for frames >= target
- EXCH-04: encodeStateHash creates exactly 13 bytes (1 + 4 + 8)
</success_criteria>

<output>
After completion, create `.planning/phases/12-p2p-hash-exchange/12-01-SUMMARY.md`
</output>
