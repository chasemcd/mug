---
phase: 73-production-bug-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/static/js/pyodide_multiplayer_game.js
autonomous: true

must_haves:
  truths:
    - "Active input parity test passes with zero divergences (test_active_input_parity)"
    - "Active input with 100ms latency passes with zero divergences (test_active_input_with_latency[100])"
    - "Active input with packet loss passes with zero divergences (test_active_input_with_packet_loss)"
    - "All previously-passing parity tests continue to pass (idle, latency, focus loss)"
    - "Rollback mechanism still functions correctly (test_packet_loss_triggers_rollback passes)"
  artifacts:
    - path: "interactive_gym/server/static/js/pyodide_multiplayer_game.js"
      provides: "Fixed dual-buffer promotion logic with rollback guards"
      contains: "pendingRollbackFrame !== null"
  key_links:
    - from: "_promoteConfirmedFrames()"
      to: "pendingRollbackFrame"
      via: "guard check at function entry"
      pattern: "if.*pendingRollbackFrame.*return"
    - from: "_waitForInputConfirmation()"
      to: "performRollback()"
      via: "execute pending rollback before promoting"
      pattern: "pendingRollbackFrame.*performRollback"
    - from: "_updateConfirmedFrame()"
      to: "rollbackInProgress"
      via: "guard check prevents mid-rollback confirmation advancement"
      pattern: "if.*rollbackInProgress.*return"
---

<objective>
Fix the rollback/promotion race condition in the dual-buffer data recording system that causes active input data parity divergences between peers.

Purpose: Three E2E tests fail because speculative frame data with predicted Noop actions gets promoted to the canonical buffer before rollback can correct it. The v1.16 Worker migration made env stepping async, introducing timing gaps where promotion races with rollback. This is the only production bug blocking v1.17 E2E test reliability.

Output: Fixed `pyodide_multiplayer_game.js` where all promotion paths respect pending rollbacks, verified by 3 previously-failing tests passing with zero divergences.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/73-production-bug-fixes/73-RESEARCH.md
@.planning/phases/71-test-audit/71-AUDIT.md
@.planning/phases/72-test-infrastructure-fixes/72-01-SUMMARY.md
@interactive_gym/server/static/js/pyodide_multiplayer_game.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix rollback/promotion race condition in dual-buffer system</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Apply four coordinated fixes to the dual-buffer data recording in `pyodide_multiplayer_game.js`. All fixes address the same root cause: speculative frame data with predicted Noop actions gets promoted to the canonical buffer before rollback can correct it.

**Fix A: Guard `_promoteConfirmedFrames()` against pending rollback (safety net)**

At the top of `_promoteConfirmedFrames()` (currently line ~2830), add a guard that skips promotion when a rollback is pending:

```javascript
_promoteConfirmedFrames() {
    // Phase 73: Guard against promoting uncorrected speculative data
    // If a rollback is pending, the speculative buffer may contain frames with
    // predicted (wrong) actions that haven't been corrected yet by replay.
    // Skip promotion until rollback completes and data is corrected.
    if (this.pendingRollbackFrame !== null || this.rollbackInProgress) {
        p2pLog.debug(`PROMOTE_GUARD: Skipping promotion - ` +
            `pendingRollback=${this.pendingRollbackFrame} rollbackInProgress=${this.rollbackInProgress}`);
        return;
    }
    // ... existing promotion logic unchanged
}
```

This is the primary safety net: no promotion path can ever promote uncorrected data, regardless of which code path calls it.

**Fix B: Guard `_updateConfirmedFrame()` during rollback**

At the top of `async _updateConfirmedFrame()` (currently line ~2787), add a guard that prevents confirmedFrame advancement while rollback is in progress:

```javascript
async _updateConfirmedFrame() {
    // Phase 73: Don't advance confirmedFrame during rollback
    // The rollback will clear and re-store frame data; advancing confirmedFrame
    // here could promote frames with uncorrected predicted actions.
    if (this.rollbackInProgress) {
        return;
    }
    // ... existing logic unchanged
}
```

This prevents the mid-rollback promotion path. Even though `_processQueuedInputs` already checks `rollbackInProgress`, `_updateConfirmedFrame` does NOT, and it's called from `_waitForInputConfirmation` which runs outside the step function's rollback-then-promote ordering.

**Fix C: Execute pending rollback in `_waitForInputConfirmation()` before promoting**

In `_waitForInputConfirmation()` (currently line ~2858), add rollback execution inside the polling loop. When `_processQueuedInputs()` sets `pendingRollbackFrame` (because newly-arrived inputs differ from predictions), execute the rollback BEFORE calling `_updateConfirmedFrame()`:

```javascript
async _waitForInputConfirmation(timeoutMs) {
    // ... existing skip checks unchanged ...

    const targetFrame = (this.p2pEpisodeSync.syncedTerminationFrame ?? this.frameNumber) - 1;
    const humanPlayerIds = this._getHumanPlayerIds();

    if (humanPlayerIds.length === 0) {
        return true;
    }

    // Check if already confirmed
    if (this._hasAllInputsForFrame(targetFrame, humanPlayerIds)) {
        // Phase 73: Execute any pending rollback before promoting
        if (this.pendingRollbackFrame !== null) {
            const rollbackFrame = this.pendingRollbackFrame;
            this.pendingRollbackFrame = null;
            await this.performRollback(rollbackFrame, humanPlayerIds);
        }
        await this._updateConfirmedFrame();
        p2pLog.debug(`[Input Confirmation] Already confirmed up to frame ${targetFrame}`);
        return true;
    }

    p2pLog.info(`[Input Confirmation] Waiting for inputs on frame ${targetFrame} ` +
        `(confirmedFrame=${this.confirmedFrame}, timeout=${timeoutMs}ms)`);

    const startTime = performance.now();

    while (performance.now() - startTime < timeoutMs) {
        this._processQueuedInputs();

        // Phase 73: Execute any pending rollback triggered by newly-arrived inputs
        // This is critical: _processQueuedInputs -> storeRemoteInput may detect that
        // we predicted wrong actions and set pendingRollbackFrame. We MUST replay
        // with correct actions before promoting frames to canonical buffer.
        if (this.pendingRollbackFrame !== null) {
            const rollbackFrame = this.pendingRollbackFrame;
            this.pendingRollbackFrame = null;
            p2pLog.info(`[Input Confirmation] Executing pending rollback to frame ${rollbackFrame}`);
            await this.performRollback(rollbackFrame, humanPlayerIds);
        }

        if (this._hasAllInputsForFrame(targetFrame, humanPlayerIds)) {
            await this._updateConfirmedFrame();
            const elapsed = Math.round(performance.now() - startTime);
            p2pLog.info(`[Input Confirmation] Confirmed after ${elapsed}ms`);
            return true;
        }

        await new Promise(resolve => setTimeout(resolve, 10));
    }

    // Timeout - execute any final pending rollback before proceeding
    if (this.pendingRollbackFrame !== null) {
        const rollbackFrame = this.pendingRollbackFrame;
        this.pendingRollbackFrame = null;
        p2pLog.info(`[Input Confirmation] Timeout - executing final rollback to frame ${rollbackFrame}`);
        await this.performRollback(rollbackFrame, humanPlayerIds);
    }

    console.warn(`[Input Confirmation] Timeout after ${timeoutMs}ms. ` +
        `confirmedFrame=${this.confirmedFrame}, target=${targetFrame}. ` +
        `Proceeding with episode export (data may diverge).`);
    return false;
}
```

**Fix D: Execute pending rollback before `_promoteRemainingAtBoundary()` in `signalEpisodeComplete()`**

In `signalEpisodeComplete()` (currently line ~3608), before calling `_promoteRemainingAtBoundary()`, execute any pending rollback to ensure the speculative buffer contains corrected data:

```javascript
signalEpisodeComplete() {
    // Phase 73: Execute any pending rollback before promoting remaining frames
    // At episode end, there may be frames in speculativeFrameData that were
    // predicted with wrong actions. Rollback corrects them before promotion.
    // Note: This is a synchronous-ish safety check. If pendingRollbackFrame is set,
    // we log a warning. The actual rollback should have been executed by
    // _waitForInputConfirmation in _checkEpisodeSyncAndReset, but this is a safety net.
    if (this.pendingRollbackFrame !== null) {
        console.warn(`[Episode Complete] WARNING: pendingRollbackFrame=${this.pendingRollbackFrame} ` +
            `still set at episode complete. Rollback should have been handled by _waitForInputConfirmation.`);
    }

    // Phase 38 (EDGE-02): Promote any remaining unconfirmed frames before export
    this._promoteRemainingAtBoundary();
    // ... rest unchanged
}
```

**Important things to NOT change:**
- Do NOT modify `performRollback()` itself -- it correctly clears both buffers and replays with corrected data
- Do NOT modify `storeFrameData()` -- it correctly writes to speculativeFrameData
- Do NOT modify `clearFrameDataFromRollback()` -- it correctly clears both buffers
- Do NOT modify the step function's main flow (lines 2135-2359) -- its ordering (process inputs -> rollback -> promote -> step) is already correct
- Do NOT modify `storeRemoteInput()` -- it correctly detects mispredictions and sets pendingRollbackFrame
- Do NOT add any new data structures or buffer mechanisms -- the dual-buffer design is sound, only the timing/ordering needs fixing

**Why this works:** The root cause is that promotion can happen without rollback correction. Fix A is a universal safety net (no promotion during pending rollback). Fix B prevents mid-rollback confirmation advancement. Fix C ensures the episode-end input confirmation loop executes rollbacks triggered by late-arriving inputs. Fix D is a safety net for the final force-promotion at episode boundary.
  </action>
  <verify>
Read the modified `pyodide_multiplayer_game.js` and verify:
1. `_promoteConfirmedFrames()` has the `pendingRollbackFrame !== null || rollbackInProgress` guard at the top
2. `_updateConfirmedFrame()` has the `rollbackInProgress` guard at the top
3. `_waitForInputConfirmation()` checks and executes `pendingRollbackFrame` before each `_updateConfirmedFrame()` call and after the timeout
4. `signalEpisodeComplete()` logs a warning if `pendingRollbackFrame` is still set before `_promoteRemainingAtBoundary()`
5. No other methods were accidentally modified
  </verify>
  <done>All four fixes applied. `_promoteConfirmedFrames` rejects promotion when rollback is pending. `_updateConfirmedFrame` rejects during rollback. `_waitForInputConfirmation` executes pending rollbacks before promoting. `signalEpisodeComplete` warns on uncorrected pending rollback.</done>
</task>

<task type="auto">
  <name>Task 2: Verify fix with E2E tests</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Run the three previously-failing E2E tests to verify the fix resolves the data parity divergence:

```bash
cd /Users/chasemcd/Repositories/interactive-gym
python -m pytest tests/e2e/test_data_comparison.py::test_active_input_parity -xvs 2>&1 | tail -50
```

If it passes (0 divergences), run the other two:

```bash
python -m pytest tests/e2e/test_latency_injection.py::test_active_input_with_latency[100] -xvs 2>&1 | tail -50
python -m pytest tests/e2e/test_network_disruption.py::test_active_input_with_packet_loss -xvs 2>&1 | tail -50
```

Then run the regression suite (tests that were passing before and must continue passing):

```bash
python -m pytest tests/e2e/test_data_comparison.py::test_export_parity_basic tests/e2e/test_data_comparison.py::test_export_parity_with_latency tests/e2e/test_data_comparison.py::test_focus_loss_mid_episode_parity tests/e2e/test_latency_injection.py::test_episode_completion_under_fixed_latency[100] tests/e2e/test_network_disruption.py::test_packet_loss_triggers_rollback -xvs 2>&1 | tail -80
```

**If a test fails:**

1. Check the failure output for the divergence pattern. If divergences still show action value 6 (Noop), the fix didn't fully address the promotion race.

2. Add diagnostic logging to `_promoteConfirmedFrames()` to trace what's being promoted:
```javascript
// At the start of the promotion loop, AFTER the guard check:
for (const [frame, data] of this.speculativeFrameData.entries()) {
    if (frame <= this.confirmedFrame) {
        const actionsStr = Object.entries(data.actions).map(([k,v]) => `${k}:${v}`).join(',');
        p2pLog.debug(`PROMOTE: frame=${frame} actions={${actionsStr}}`);
        // ... existing promotion
    }
}
```

3. Re-run the failing test and check browser console output for `PROMOTE_GUARD` messages (Fix A triggered) and `PROMOTE:` messages with action value 6 (Noop escaping the guard).

4. If `PROMOTE_GUARD` is never logged, the guard is not being reached -- check that `_processQueuedInputs` is correctly setting `pendingRollbackFrame` via `storeRemoteInput`.

5. If diagnostics show frames being promoted with correct actions but the CSV still diverges, the issue may be in `_promoteRemainingAtBoundary()`. Verify that rollback was executed before it ran by checking for the `[Episode Complete] WARNING` log.

**Timeout guidance:** These tests take 60-120 seconds each. The full regression suite may take 5-8 minutes. Use `--timeout=300` if needed.
  </action>
  <verify>All three previously-failing tests pass:
- `test_active_input_parity` -- PASSED
- `test_active_input_with_latency[100]` -- PASSED
- `test_active_input_with_packet_loss` -- PASSED

All five regression tests pass:
- `test_export_parity_basic` -- PASSED
- `test_export_parity_with_latency` -- PASSED
- `test_focus_loss_mid_episode_parity` -- PASSED
- `test_episode_completion_under_fixed_latency[100]` -- PASSED
- `test_packet_loss_triggers_rollback` -- PASSED
  </verify>
  <done>All 3 previously-failing active input parity tests pass with zero divergences. All 5 regression tests continue to pass. The rollback/promotion race condition is fixed.</done>
</task>

</tasks>

<verification>
1. `test_active_input_parity` passes with 0 divergences in all action/info columns
2. `test_active_input_with_latency[100]` passes with 0 divergences
3. `test_active_input_with_packet_loss` passes with 0 divergences
4. `test_export_parity_basic` still passes (idle parity regression)
5. `test_export_parity_with_latency` still passes (latency parity regression)
6. `test_focus_loss_mid_episode_parity` still passes (focus loss regression)
7. `test_episode_completion_under_fixed_latency[100]` still passes (episode completion regression)
8. `test_packet_loss_triggers_rollback` still passes (rollback mechanism regression)
</verification>

<success_criteria>
- Zero data parity divergences in active input tests (previously 18-98 divergences)
- Zero regressions in previously-passing tests
- PROD-01 and PROD-02 requirements satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/73-production-bug-fixes/73-01-SUMMARY.md`
</output>
