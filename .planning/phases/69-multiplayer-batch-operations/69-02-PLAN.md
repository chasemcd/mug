---
phase: 69-multiplayer-batch-operations
plan: 02
type: execute
wave: 2
depends_on: ["69-01"]
files_modified:
  - interactive_gym/server/static/js/pyodide_multiplayer_game.js
autonomous: true

must_haves:
  truths:
    - "All non-batch this.pyodide.runPythonAsync() calls in multiplayer game are replaced with structured Worker commands"
    - "stepWithActions() uses this.worker.step() with _convertToMap() for result conversion"
    - "reset() uses this.worker.reset() and this.worker.setState() for both server-auth and P2P paths"
    - "Debug hash checks use this.worker.computeHash() instead of inline Python"
    - "State management (saveStateSnapshot, loadStateSnapshot, _applyP2PState, applyServerState) use this.worker.getState/setState"
    - "this.pyodide references replaced with this.worker throughout"
  artifacts:
    - path: "interactive_gym/server/static/js/pyodide_multiplayer_game.js"
      provides: "Multiplayer game using structured Worker commands for all individual operations"
      contains: "this\\.worker\\.(getState|setState|computeHash|seedRng|render|step|reset)\\("
  key_links:
    - from: "interactive_gym/server/static/js/pyodide_multiplayer_game.js"
      to: "interactive_gym/server/static/js/PyodideWorker.js"
      via: "this.worker.* method calls"
      pattern: "this\\.worker\\."
---

<objective>
Migrate all non-batch this.pyodide.runPythonAsync() call sites in pyodide_multiplayer_game.js to structured Worker commands.

Purpose: Replace ~20 arbitrary Python execution calls with typed, structured Worker commands (getState, setState, computeHash, seedRng, step, reset, render). This eliminates Python code injection patterns, removes toPy/toJs conversion chains, and uses the Worker's built-in obs/rewards normalization. The batch operations (performRollback, _performFastForward) are handled separately in Plan 03.

Output: pyodide_multiplayer_game.js with all individual this.pyodide.* calls replaced by this.worker.* calls.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/69-multiplayer-batch-operations/69-RESEARCH.md
@.planning/phases/69-multiplayer-batch-operations/69-01-SUMMARY.md
@interactive_gym/server/static/js/pyodide_multiplayer_game.js
@interactive_gym/server/static/js/pyodide_remote_game.js
@interactive_gym/server/static/js/PyodideWorker.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate individual call sites to structured Worker commands</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Migrate each call site below from `this.pyodide.runPythonAsync(...)` / `this.pyodide.toPy(...)` to the structured Worker command. Use the research call site catalog as reference. The base class (RemoteGame) already has `_convertToMap()` and `_processRenderState()` helpers available via inheritance.

**CRITICAL RULES:**
- Replace `this.pyodide` with `this.worker` everywhere in this file
- Do NOT touch `performRollback()` or `_performFastForward()` -- those are Plan 03
- Each migration follows the same pattern: remove inline Python code, call Worker method, handle result format

**Call site migrations (in order of appearance in file):**

**1. Socket handler p2p_state_request (~line 1489):**
Replace:
```javascript
const envState = await this.pyodide.runPythonAsync(`import json\nenv.get_state()`);
const stateDict = envState.toJs({ dict_converter: Object.fromEntries });
```
With:
```javascript
const stateJson = await this.worker.getState();
const stateDict = JSON.parse(stateJson).env_state;
```
Note: getState() returns a JSON string containing {env_state, np_rng_state, py_rng_state}. We only need env_state for the socket response.

**2. validateStateSync() (~line 1763):**
Replace the entire runPythonAsync call with a Worker `computeHash` call wrapped in try/catch:
```javascript
async validateStateSync() {
    try {
        // Try to get state - if this works, get_state/set_state are supported
        await this.worker.getState();
        this.stateSyncSupported = true;
        p2pLog.debug('State sync enabled (get_state/set_state verified via Worker)');
    } catch (e) {
        this.stateSyncSupported = false;
        p2pLog.warn('State sync DISABLED - environment missing get_state/set_state');
    }
}
```
This replaces the Python hasattr() check with a practical test: if getState() succeeds, the env has get_state(). Simpler and no arbitrary Python execution needed.

**3. seedPythonEnvironment() (~line 1807):**
Replace:
```javascript
await this.pyodide.runPythonAsync(`import numpy...\nnp.random.seed(${seed})\nrandom.seed(${seed})...`);
```
With:
```javascript
await this.worker.seedRng(seed);
```

**4. reset() server-authoritative path (~lines 1901-1934):**
This path does: reset + set_state + get_obs + render + normalize obs.
Replace with a sequence of Worker calls:
```javascript
// Reset to initialize internal structures
const resetResult = await this.worker.reset(this.gameSeed || null);

// Apply server state
const envStateJson = JSON.stringify(serverState.env_state);
await this.worker.setState(envStateJson);

// Get fresh render after state application
const renderResult = await this.worker.render();

// Use obs from reset, but render from after setState
let obs = this._convertToMap(resetResult.obs);
let infos = resetResult.infos;
let render_state = this._processRenderState(renderResult.render_state);
```
Note: The original code tried to re-get obs after set_state via get_obs/_get_obs. For the Worker approach, the reset() obs is sufficient because set_state only affects internal game state, not the observation format. If environments need re-observation after set_state, this can be addressed later. The critical thing is that set_state is applied and render shows the correct state.

**5. reset() P2P path (~lines 1999-2022):**
Replace the entire runPythonAsync block with:
```javascript
const result = await this.worker.reset(this.gameSeed || null);
let obs = this._convertToMap(result.obs);
let infos = result.infos;
let render_state = this._processRenderState(result.render_state);
```
Remove the separate `this.pyodide.toPy(result).toJs()` line and the manual render_state construction. The `_processRenderState()` helper handles RGB array detection with the depth-3 check.

**6. reset() P2P hash check (~line 2072):**
Replace:
```javascript
const hashResult = await this.pyodide.runPythonAsync(`...env.get_state()...hashlib.md5...`);
```
With:
```javascript
const hashResult = await this.worker.computeHash();
const hash = hashResult.hash;
```
Note: computeHash() uses SHA-256 (not MD5), which is fine since both peers will use the same algorithm.

**7. step() debug pre-hash (~line 2400):**
Replace the entire runPythonAsync block:
```javascript
const preHashResult = await this.worker.computeHash();
const actionsStr = Object.entries(finalActions).map(([p, a]) => `${p}:${a}`).join(',');
p2pLog.debug(`FRAME: ${this.frameNumber} pre_hash=${preHashResult.hash} actions={${actionsStr}} rollback=${rollbackOccurred}`);
```

**8. step() debug post-hash (~line 2430):**
Same pattern:
```javascript
const hashResult = await this.worker.computeHash();
p2pLog.debug(`FRAME: ${this.frameNumber} post_hash=${hashResult.hash}`);
```

**9. step() post-rollback render (~lines 2549-2550):**
Replace:
```javascript
const freshRender = await this.pyodide.runPythonAsync(`env.render()`);
let freshRenderState = await this.pyodide.toPy(freshRender).toJs();
```
With:
```javascript
const renderResult = await this.worker.render();
let freshRenderState = renderResult.render_state;
```
Keep the rest of the render_state processing (RGB check, tween flags, etc.) as-is. The `_processRenderState()` helper is NOT used here because this code path applies custom tween flags for rollback smoothing.

**10. stepWithActions() (~lines 2710-2771):**
Replace the entire method body. The Worker's step() already handles on_game_step_code injection and obs/rewards normalization:
```javascript
async stepWithActions(actions) {
    const result = await this.worker.step(actions);

    let { obs, rewards, terminateds, truncateds, infos, render_state } = result;

    // Convert to Maps for downstream compatibility
    obs = this._convertToMap(obs);
    rewards = this._convertToMap(rewards);
    terminateds = this._convertToMap(terminateds);
    truncateds = this._convertToMap(truncateds);

    // Update cumulative rewards
    for (let [key, value] of rewards.entries()) {
        this.cumulative_rewards[key] += value;
    }
    this.step_num++;
    ui_utils.updateHUDText(this.getHUDText());

    // Process render_state
    render_state = this._processRenderState(render_state);

    return [obs, rewards, terminateds, truncateds, infos, render_state];
}
```

**11. _computeHashFromState() (~line 3169):**
Replace the runPythonAsync block with:
```javascript
async _computeHashFromState(envState) {
    if (!envState) return null;
    const stateJson = JSON.stringify(envState);
    const result = await this.worker.computeHash(stateJson);
    return result.hash;
}
```

**12. _handleDesync() state dump (~line 3333):**
Replace:
```javascript
const stateJson = await this.pyodide.runPythonAsync(`import json\n_env_state_dump = env.get_state()...\njson.dumps...`);
stateDump = JSON.parse(stateJson);
```
With:
```javascript
const stateJson = await this.worker.getState();
stateDump = JSON.parse(stateJson).env_state;
```

**13. computeQuickStateHash() (~line 3380):**
Replace the entire runPythonAsync block:
```javascript
async computeQuickStateHash() {
    if (!this.stateSyncSupported) return null;
    const result = await this.worker.computeHash();
    return result.hash;
}
```

**14. applyServerState() set_state (~lines 3427-3433):**
Replace:
```javascript
await this.pyodide.runPythonAsync(`import numpy...env_state = ${this.pyodide.toPy(state.env_state)}...env.set_state(env_state)...`);
```
With:
```javascript
const envStateJson = JSON.stringify(state.env_state);
await this.worker.setState(envStateJson);
```
Note: setState only accepts the full snapshot JSON (with env_state, np_rng_state, py_rng_state), OR we can make it also accept just env_state. Since applyServerState only has env_state (no RNG), wrap it:
```javascript
const statePayload = JSON.stringify({ env_state: state.env_state });
await this.worker.setState(statePayload);
```
The Worker's handleSetState should handle missing np_rng_state/py_rng_state gracefully (already does per research Example 2 with `if 'np_rng_state' in _snapshot` checks).

**15. applyServerState() render (~line 3478):**
Replace:
```javascript
await this.pyodide.runPythonAsync(`env.render()`);
```
With:
```javascript
await this.worker.render();
```

**16. _applyP2PState() (~line 4211):**
Replace:
```javascript
const envStateJson = JSON.stringify(envState);
await this.pyodide.runPythonAsync(`import json\nenv_state = json.loads(...)...env.set_state(env_state)`);
```
With:
```javascript
const statePayload = JSON.stringify({ env_state: envState });
await this.worker.setState(statePayload);
```

**17. saveStateSnapshot() (~line 4450):**
Replace the entire runPythonAsync block:
```javascript
const stateJson = await this.worker.getState();
```
Then parse the JSON and add JS-side state as before:
```javascript
const snapshotData = JSON.parse(stateJson);
snapshotData.cumulative_rewards = {...this.cumulative_rewards};
snapshotData.step_num = this.step_num;
this.stateSnapshots.set(frameNumber, JSON.stringify(snapshotData));
```

**18. loadStateSnapshot() (~line 4550):**
Replace the entire runPythonAsync block. The snapshot JSON already has the right format for setState:
```javascript
async loadStateSnapshot(frameNumber) {
    const stateJson = this.stateSnapshots.get(frameNumber);
    if (!stateJson) {
        p2pLog.error(`No snapshot found for frame ${frameNumber}`);
        return false;
    }

    try {
        const snapshotData = JSON.parse(stateJson);

        // Log what we're restoring
        const agentStates = snapshotData.env_state?.agents || {};
        const agentSummary = Object.entries(agentStates).map(([id, a]) =>
            `${id}:pos=${a.pos},inv=${a.inventory?.length || 0}`
        ).join(' ');
        p2pLog.debug(`LOAD_SNAPSHOT: frame=${frameNumber} agents=[${agentSummary}]`);

        // Restore via Worker (setState handles env_state + RNG state)
        await this.worker.setState(stateJson);

        // Restore JavaScript-side state
        if (snapshotData.cumulative_rewards) {
            this.cumulative_rewards = {...snapshotData.cumulative_rewards};
            p2pLog.debug(`RESTORE_REWARDS: frame=${frameNumber} rewards=${JSON.stringify(this.cumulative_rewards)}`);
        }
        if (snapshotData.step_num !== undefined) {
            this.step_num = snapshotData.step_num;
        }

        return true;
    } catch (e) {
        p2pLog.error(`Failed to load snapshot for frame ${frameNumber}: ${e}`);
        return false;
    }
}
```
Note: The existing loadStateSnapshot had a verify step (comparing before/after state). We drop this verification since setState is now a tested Worker command and the verification was debug logging only.

**IMPORTANT NOTES:**
- Do NOT change any GGPO logic, input buffering, episode sync, or rollback detection
- Do NOT touch performRollback() or _performFastForward() -- those are Plan 03
- The `this.pyodide.toPy(result).toJs()` pattern becomes unnecessary since Worker returns plain objects
- The render_state processing with convertRGBArrayToImage() stays for paths that add tween flags, but simple paths can use `this._processRenderState()`
- After all migrations, there should be ZERO references to `this.pyodide` except inside `performRollback()` and `_performFastForward()`
  </action>
  <verify>
1. Grep for `this.pyodide` in pyodide_multiplayer_game.js -- should ONLY appear in performRollback() and _performFastForward()
2. Grep for `this.worker.getState\|this.worker.setState\|this.worker.computeHash\|this.worker.seedRng\|this.worker.render\|this.worker.step\|this.worker.reset` to confirm new calls exist
3. Grep for `toPy` in pyodide_multiplayer_game.js -- should ONLY appear in performRollback() and _performFastForward()
4. Read the modified stepWithActions() and confirm it uses this.worker.step() + _convertToMap()
5. Read the modified reset() and confirm both server-auth and P2P paths use Worker commands
  </verify>
  <done>All ~18 individual this.pyodide.* call sites replaced with structured this.worker.* commands. Only performRollback() and _performFastForward() still use this.pyodide (migrated in Plan 03).</done>
</task>

</tasks>

<verification>
1. `grep -c 'this\.pyodide' pyodide_multiplayer_game.js` -- count should be small (only in performRollback + _performFastForward)
2. `grep -c 'this\.worker\.' pyodide_multiplayer_game.js` -- count should be significantly higher than before
3. `grep 'runPythonAsync' pyodide_multiplayer_game.js` -- should only appear in performRollback + _performFastForward
4. No `toPy` calls outside performRollback + _performFastForward
</verification>

<success_criteria>
- All 18 individual call sites migrated to Worker commands
- stepWithActions uses this.worker.step() with _convertToMap()
- reset() uses this.worker.reset() + this.worker.setState() (server-auth) or just this.worker.reset() (P2P)
- saveStateSnapshot uses this.worker.getState()
- loadStateSnapshot uses this.worker.setState()
- Hash operations use this.worker.computeHash()
- Zero this.pyodide references outside performRollback and _performFastForward
- GGPO logic, input buffering, episode sync unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/69-multiplayer-batch-operations/69-02-SUMMARY.md`
</output>
