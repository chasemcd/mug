---
phase: 69-multiplayer-batch-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/static/js/pyodide_worker.js
  - interactive_gym/server/static/js/PyodideWorker.js
autonomous: true

must_haves:
  truths:
    - "Worker accepts getState, setState, computeHash, seedRng, render, and batch message types"
    - "PyodideWorker exposes getState(), setState(), computeHash(), seedRng(), render(), and batch() async methods"
    - "Batch command executes operations sequentially and stops on first error with partial results"
    - "Existing step/reset/initEnv commands continue to work unchanged"
  artifacts:
    - path: "interactive_gym/server/static/js/pyodide_worker.js"
      provides: "New Worker-side handlers for state operations and batch"
      contains: "handleGetState|handleSetState|handleComputeHash|handleBatch"
    - path: "interactive_gym/server/static/js/PyodideWorker.js"
      provides: "Main-thread async wrapper methods for new commands"
      exports: ["getState", "setState", "computeHash", "seedRng", "render", "batch"]
  key_links:
    - from: "interactive_gym/server/static/js/PyodideWorker.js"
      to: "interactive_gym/server/static/js/pyodide_worker.js"
      via: "postMessage with type field"
      pattern: "_sendRequest\\('(getState|setState|computeHash|seedRng|render|batch)'"
---

<objective>
Extend the Worker protocol with structured commands for all multiplayer Pyodide operations.

Purpose: Phase 69 migrates MultiplayerPyodideGame from arbitrary runPythonAsync() calls to structured Worker commands. This plan adds the Worker-side handlers and main-thread methods that Plan 02 and Plan 03 will use. No callers are changed yet -- this only adds new message types.

Output: Extended pyodide_worker.js with 6 new handlers and extended PyodideWorker.js with 6 new public methods. All existing functionality remains unchanged.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/69-multiplayer-batch-operations/69-RESEARCH.md
@interactive_gym/server/static/js/pyodide_worker.js
@interactive_gym/server/static/js/PyodideWorker.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add new Worker-side handlers to pyodide_worker.js</name>
  <files>interactive_gym/server/static/js/pyodide_worker.js</files>
  <action>
Add 6 new handler functions and wire them into the handleMessage switch statement. Each handler follows the existing pattern (async function, receives id and payload, posts result or error).

**Update the module header comment** to list the new message types: `getState`, `setState`, `computeHash`, `seedRng`, `render`, `batch`.

**Refactor existing handlers for batch reuse:**
Before adding batch, refactor handleStep and handleReset into two-part functions:
- `handleStep(id, payload)` -- calls `handleStepInternal(payload)` and posts result
- `handleStepInternal(payload)` -- does the actual Python work and returns the result object
- Same pattern for handleReset: `handleResetInternal(payload)`

This allows the batch handler to call `*Internal` functions without posting individual results.

**New handlers (each has both external and internal variants):**

1. `handleGetState(id, payload)` / `handleGetStateInternal(payload)`:
   - Run Python: capture env.get_state(), numpy RNG state (via np.random.get_state() with .tolist()), Python random state (via random.getstate())
   - Return JSON string of `{ env_state, np_rng_state, py_rng_state }` using json.dumps
   - Use the exact Python code from the research Example 1, but return the JSON string directly (not parsed)
   - The result posted back is just the JSON string (caller parses)

2. `handleSetState(id, payload)` / `handleSetStateInternal(payload)`:
   - payload: `{ stateJson: string }` -- the full snapshot JSON string
   - Escape the JSON for Python embedding: `payload.stateJson.replace(/\\/g, '\\\\').replace(/'/g, "\\'")`
   - Run Python: json.loads the snapshot, env.set_state(env_state), restore numpy RNG if present, restore Python random RNG if present
   - Use the exact Python code from the research Example 2
   - Return `{ ok: true }`

3. `handleComputeHash(id, payload)` / `handleComputeHashInternal(payload)`:
   - payload: `{}` (empty -- hashes current env state) or `{ stateJson: string }` (hashes provided state)
   - If stateJson provided: parse it and hash that. If not: call env.get_state() and hash current state.
   - Python: normalize floats to 10 decimal places, json.dumps(sort_keys=True, separators=(',',':')), hashlib.sha256().hexdigest()[:16]
   - Return `{ hash: string }`

4. `handleSeedRng(id, payload)` / `handleSeedRngInternal(payload)`:
   - payload: `{ seed: number }`
   - Run Python: `np.random.seed(seed); random.seed(seed)`
   - Return `{ ok: true }`

5. `handleRender(id, payload)` / `handleRenderInternal(payload)`:
   - payload: `{}` (empty)
   - Run Python: `render_state = env.render()` then convert via toJs({depth: 2})
   - Return `{ render_state: ... }` (the raw render_state data)
   - Note: Caller is responsible for _processRenderState conversion on main thread

6. `handleBatch(id, payload)` / no internal variant needed:
   - payload: `{ operations: [{ op: string, params: object }] }`
   - Execute operations sequentially using `*Internal` functions
   - Supported ops: `setState`, `getState`, `step`, `reset`, `computeHash`, `render`, `seedRng`
   - On success: post `{ type: 'result', id, result: [result1, result2, ...] }`
   - On error: post `{ type: 'error', id, error: { message, stack, failedIndex, partialResults } }`
   - Use the exact structure from research Example 3

**Wire into handleMessage switch:**
Add cases for 'getState', 'setState', 'computeHash', 'seedRng', 'render', 'batch' that call the corresponding handlers.

**IMPORTANT: Do NOT remove or modify handleRunPython yet.** It is still used by multiplayer via the shim. It will be removed in Plan 03.
  </action>
  <verify>
Read the modified pyodide_worker.js and confirm:
1. All 6 new handler functions exist
2. handleMessage switch has cases for all 6 new types
3. handleStep/handleReset have Internal variants
4. handleRunPython is still present
5. No syntax errors (consistent template literals, proper escaping)
  </verify>
  <done>pyodide_worker.js has handlers for getState, setState, computeHash, seedRng, render, and batch. All use Internal pattern for batch reuse. Existing handlers unchanged.</done>
</task>

<task type="auto">
  <name>Task 2: Add new main-thread methods to PyodideWorker.js</name>
  <files>interactive_gym/server/static/js/PyodideWorker.js</files>
  <action>
Add 6 new public async methods to the PyodideWorker class. Each follows the existing pattern: assert ready, call _sendRequest with type and payload.

**New methods:**

1. `async getState()` -- sends type 'getState', empty payload. Returns the JSON string from Worker.

2. `async setState(stateJson)` -- sends type 'setState', payload `{ stateJson }`. Returns `{ ok: true }`.

3. `async computeHash(stateJson = null)` -- sends type 'computeHash', payload `{ stateJson }` (stateJson can be null to hash current env state). Returns `{ hash: string }`.

4. `async seedRng(seed)` -- sends type 'seedRng', payload `{ seed }`. Returns `{ ok: true }`.

5. `async render()` -- sends type 'render', empty payload. Returns `{ render_state }`.

6. `async batch(operations)` -- sends type 'batch', payload `{ operations }`. The operations param is an array of `{ op: string, params: object }`. Returns array of results.

Add these methods AFTER the existing reset() method and BEFORE the existing runPythonAsync() method. Add JSDoc comments matching the style of existing methods.

**Update the module header comment** to mention the new methods.

**IMPORTANT: Do NOT remove runPythonAsync(), toPy(), or _wrapResult() yet.** They are still used by multiplayer. They will be removed in Plan 03.
  </action>
  <verify>
Read the modified PyodideWorker.js and confirm:
1. All 6 new methods exist with JSDoc
2. Each calls _assertReady() and _sendRequest()
3. runPythonAsync, toPy, _wrapResult are still present
4. No syntax errors
  </verify>
  <done>PyodideWorker.js exposes getState(), setState(), computeHash(), seedRng(), render(), and batch() methods. All backward-compat shims preserved for now.</done>
</task>

</tasks>

<verification>
1. Read pyodide_worker.js -- confirm new handlers exist, switch cases added, existing code unchanged
2. Read PyodideWorker.js -- confirm new methods exist, shims preserved
3. Grep for "handleGetState|handleSetState|handleComputeHash|handleSeedRng|handleRender|handleBatch" in pyodide_worker.js
4. Grep for "getState|setState|computeHash|seedRng|render|batch" in PyodideWorker.js (as method definitions)
</verification>

<success_criteria>
- pyodide_worker.js has 6 new handler functions + Internal variants for batch reuse
- PyodideWorker.js has 6 new public async methods
- handleMessage switch routes all 6 new types
- Existing installPackages/initEnv/step/reset/runPython handlers unchanged
- Existing runPythonAsync/toPy/_wrapResult methods preserved in PyodideWorker.js
- No syntax errors in either file
</success_criteria>

<output>
After completion, create `.planning/phases/69-multiplayer-batch-operations/69-01-SUMMARY.md`
</output>
