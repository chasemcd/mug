---
phase: 19-waiting-room-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/static/js/pyodide_multiplayer_game.js
  - interactive_gym/server/pyodide_game_coordinator.py
  - interactive_gym/server/app.py
  - interactive_gym/server/static/js/index.js
autonomous: true

must_haves:
  truths:
    - "P2P connection validated via bidirectional message exchange before game starts"
    - "Failed P2P pairs return to matchmaking pool"
    - "User sees clear status messaging during validation (connecting, verifying, success/repool)"
  artifacts:
    - path: "interactive_gym/server/static/js/pyodide_multiplayer_game.js"
      provides: "Validation message protocol and client state machine"
      contains: "P2P_MSG_VALIDATION_PING"
    - path: "interactive_gym/server/pyodide_game_coordinator.py"
      provides: "Server-side validation tracking"
      contains: "record_validation_success"
    - path: "interactive_gym/server/app.py"
      provides: "Validation socket handlers"
      contains: "p2p_validation_success"
    - path: "interactive_gym/server/static/js/index.js"
      provides: "Status UI updates during validation"
      contains: "p2p_validation_repool"
  key_links:
    - from: "pyodide_multiplayer_game.js"
      to: "app.py"
      via: "socket.emit p2p_validation_success/failed"
      pattern: "socket\\.emit\\('p2p_validation"
    - from: "app.py"
      to: "pyodide_game_coordinator.py"
      via: "coordinator method calls"
      pattern: "PYODIDE_COORDINATOR\\.record_validation"
    - from: "app.py"
      to: "index.js"
      via: "socket.emit p2p_validation_complete/repool"
      pattern: "emit\\('p2p_validation_(complete|repool)'"
---

<objective>
Add P2P connection validation to the waiting room flow. Currently, P2P connection timeout falls back to SocketIO. For research validity, failed P2P pairs should be re-pooled for new matches, not proceed with degraded connectivity.

Purpose: Ensure all multiplayer games have validated P2P connections, maintaining research data quality.
Output: Validation message protocol, server coordination, re-pool logic, and status UI messaging.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-waiting-room-validation/19-RESEARCH.md

# Key existing patterns from v1.2
@.planning/phases/17-multiplayer-exclusion/17-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add validation message protocol and client state machine</name>
  <files>
    interactive_gym/server/static/js/pyodide_multiplayer_game.js
  </files>
  <action>
Add P2P validation message protocol and client-side validation state machine.

1. **Add message type constants** (near existing P2P_MSG_* constants around line 40):
```javascript
const P2P_MSG_VALIDATION_PING = 0x10;  // Validation request
const P2P_MSG_VALIDATION_PONG = 0x11;  // Validation response
```

2. **Add encode/decode functions** (after encodeStateHash/decodeStateHash):
```javascript
/**
 * Encode a validation ping message.
 * Format: 9 bytes
 *   Byte 0: Message type (0x10)
 *   Bytes 1-8: Timestamp (float64)
 */
function encodeValidationPing() {
    const buffer = new ArrayBuffer(9);
    const view = new DataView(buffer);
    view.setUint8(0, P2P_MSG_VALIDATION_PING);
    view.setFloat64(1, performance.now(), false);
    return buffer;
}

function encodeValidationPong(originalTimestamp) {
    const buffer = new ArrayBuffer(9);
    const view = new DataView(buffer);
    view.setUint8(0, P2P_MSG_VALIDATION_PONG);
    view.setFloat64(1, originalTimestamp, false);
    return buffer;
}
```

3. **Add validation state object** to MultiplayerPyodideGame constructor (after p2pReadyGate):
```javascript
// P2P validation state machine (Phase 19)
// States: 'idle' -> 'connecting' -> 'validating' -> 'validated' | 'failed'
this.p2pValidation = {
    enabled: true,                  // Can be disabled via config
    state: 'idle',
    timeoutMs: 10000,               // Default 10 seconds for validation
    timeoutId: null,
    pingSentAt: null,               // Timestamp when ping sent
    pongReceived: false,
    peerPingSeen: false
};
```

4. **Modify _initP2PConnection()** (around line 3987) to set state to 'connecting':
At the start of the method, add:
```javascript
this.p2pValidation.state = 'connecting';
```

5. **Modify onDataChannelOpen callback** (around line 4006) to start validation instead of immediately resolving gate:
Replace the callback body to:
```javascript
this.webrtcManager.onDataChannelOpen = () => {
    p2pLog.warn('DataChannel OPEN - starting P2P validation');
    this.p2pConnected = true;

    // Initialize P2P input sender
    const myPlayerIndex = this.playerIdToIndex[this.myPlayerId];
    this.p2pInputSender = new P2PInputSender(
        this.webrtcManager,
        myPlayerIndex,
        3  // redundancy count
    );

    // Initialize connection health monitoring
    this.connectionHealth = new ConnectionHealthMonitor();

    // Start P2P validation handshake (Phase 19)
    if (this.p2pValidation.enabled) {
        this._startValidation();
    } else {
        // Validation disabled - resolve immediately
        this._startPingInterval();
        this._sendP2PTestMessage();
        this._resolveP2PReadyGate();
    }
};
```

6. **Add validation methods** (after _resolveP2PReadyGate):
```javascript
/**
 * Start P2P validation handshake.
 * Both peers send ping, wait for pong, confirm bidirectional data flow.
 */
_startValidation() {
    this.p2pValidation.state = 'validating';
    p2pLog.info('Starting P2P validation handshake');

    // Emit status to server for UI update
    socket.emit('p2p_validation_status', {
        game_id: this.gameId,
        status: 'validating'
    });

    // Set validation timeout
    this.p2pValidation.timeoutId = setTimeout(() => {
        if (this.p2pValidation.state === 'validating') {
            this._onValidationTimeout();
        }
    }, this.p2pValidation.timeoutMs);

    // Small delay to ensure DataChannel is stable, then send ping
    setTimeout(() => {
        if (this.p2pValidation.state === 'validating') {
            this._sendValidationPing();
        }
    }, 100);
}

_sendValidationPing() {
    const packet = encodeValidationPing();
    if (this.webrtcManager?.isReady()) {
        this.webrtcManager.send(packet);
        this.p2pValidation.pingSentAt = performance.now();
        p2pLog.debug('Sent validation ping');
    }
}

_handleValidationPing(buffer) {
    const view = new DataView(buffer);
    const timestamp = view.getFloat64(1, false);

    // Mark that peer's ping was received
    this.p2pValidation.peerPingSeen = true;

    // Respond with pong
    const pong = encodeValidationPong(timestamp);
    this.webrtcManager?.send(pong);
    p2pLog.debug('Received validation ping, sent pong');

    // Check if validation complete
    this._checkValidationComplete();
}

_handleValidationPong(buffer) {
    const view = new DataView(buffer);
    const originalTimestamp = view.getFloat64(1, false);

    // Measure RTT from validation handshake
    if (this.p2pValidation.pingSentAt) {
        const rtt = performance.now() - this.p2pValidation.pingSentAt;
        p2pLog.debug(`Validation pong received, RTT: ${rtt.toFixed(1)}ms`);
    }

    this.p2pValidation.pongReceived = true;
    this._checkValidationComplete();
}

_checkValidationComplete() {
    // Validation complete when we've sent ping, received pong, and seen peer's ping
    if (this.p2pValidation.pingSentAt &&
        this.p2pValidation.pongReceived &&
        this.p2pValidation.peerPingSeen) {
        this._onValidationSuccess();
    }
}

_onValidationSuccess() {
    // Clear timeout
    if (this.p2pValidation.timeoutId) {
        clearTimeout(this.p2pValidation.timeoutId);
        this.p2pValidation.timeoutId = null;
    }

    this.p2pValidation.state = 'validated';
    p2pLog.warn('P2P validation successful');

    // Notify server
    socket.emit('p2p_validation_success', {
        game_id: this.gameId,
        player_id: this.myPlayerId
    });

    // Start ping interval now that validation is complete
    this._startPingInterval();
    this._sendP2PTestMessage();

    // Don't resolve gate yet - wait for server to confirm both players validated
}

_onValidationTimeout() {
    this.p2pValidation.state = 'failed';
    p2pLog.error('P2P validation timeout');

    // Notify server of failure
    socket.emit('p2p_validation_failed', {
        game_id: this.gameId,
        player_id: this.myPlayerId,
        reason: 'timeout'
    });

    // Server will emit p2p_validation_repool, handled by index.js
}
```

7. **Add socket handler for validation complete** (in setupMultiplayerHandlers):
```javascript
// P2P validation complete - both peers validated, proceed to game
socket.on('p2p_validation_complete', (data) => {
    p2pLog.warn('P2P validation complete - proceeding to game');
    this._resolveP2PReadyGate();
});
```

8. **Update _handleBinaryMessage()** to route validation messages (find the switch or if-chain for message types):
Add cases for the new message types:
```javascript
case P2P_MSG_VALIDATION_PING:
    this._handleValidationPing(data);
    return;
case P2P_MSG_VALIDATION_PONG:
    this._handleValidationPong(data);
    return;
```

9. **Modify the p2pReadyGate timeout logic** in pyodide_game_ready handler (around line 764):
Change the timeout behavior to emit failure instead of resolving gate:
```javascript
if (this.p2pReadyGate.enabled) {
    p2pLog.debug(`Waiting for P2P connection (max ${this.p2pReadyGate.timeoutMs}ms)...`);
    this.p2pReadyGate.timeoutId = setTimeout(() => {
        if (!this.p2pReadyGate.resolved) {
            // Phase 19: On timeout without validation, emit failure instead of fallback
            if (this.p2pValidation.enabled && this.p2pValidation.state !== 'validated') {
                p2pLog.error('P2P connection timeout - validation not complete');
                socket.emit('p2p_validation_failed', {
                    game_id: this.gameId,
                    player_id: this.myPlayerId,
                    reason: 'connection_timeout'
                });
            } else {
                // Validation disabled - allow SocketIO fallback (legacy behavior)
                p2pLog.warn('P2P connection timeout - starting with SocketIO fallback');
                this._resolveP2PReadyGate();
            }
        }
    }, this.p2pReadyGate.timeoutMs);
}
```
  </action>
  <verify>
Check that new message types and functions exist:
- `grep -n "P2P_MSG_VALIDATION_PING" interactive_gym/server/static/js/pyodide_multiplayer_game.js`
- `grep -n "_startValidation" interactive_gym/server/static/js/pyodide_multiplayer_game.js`
- `grep -n "p2p_validation_success" interactive_gym/server/static/js/pyodide_multiplayer_game.js`
  </verify>
  <done>
Client-side validation protocol implemented: message types 0x10/0x11, state machine (idle->connecting->validating->validated|failed), validation handshake methods, socket emits for success/failure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add server-side validation coordination and re-pool logic</name>
  <files>
    interactive_gym/server/pyodide_game_coordinator.py
    interactive_gym/server/app.py
  </files>
  <action>
Add server-side validation state tracking and re-pool logic.

**In pyodide_game_coordinator.py:**

1. **Update PyodideGameState dataclass** (around line 26) to add validation fields:
```python
# P2P validation state (Phase 19)
p2p_validation_enabled: bool = True
p2p_validation_timeout_s: float = 10.0
p2p_validated_players: set = dataclasses.field(default_factory=set)
validation_start_time: float | None = None
```

2. **Add validation methods** to PyodideGameCoordinator class (after handle_player_exclusion method):
```python
def start_validation(self, game_id: str) -> bool:
    """Mark validation phase started for a game."""
    with self.lock:
        game = self.games.get(game_id)
        if not game:
            return False

        game.validation_start_time = time.time()
        game.p2p_validated_players = set()
        logger.info(f"P2P validation started for game {game_id}")
        return True

def record_validation_success(self, game_id: str, player_id: str | int) -> str | None:
    """
    Record that a player validated their P2P connection.

    Returns:
        'complete' if all players validated
        'waiting' if still waiting for other players
        None if game not found
    """
    with self.lock:
        game = self.games.get(game_id)
        if not game:
            logger.warning(f"Validation success for non-existent game {game_id}")
            return None

        game.p2p_validated_players.add(str(player_id))
        logger.info(
            f"Player {player_id} validated P2P in game {game_id} "
            f"({len(game.p2p_validated_players)}/{game.num_expected_players})"
        )

        # Check if all players validated
        if len(game.p2p_validated_players) >= game.num_expected_players:
            return 'complete'
        return 'waiting'

def handle_validation_failure(self, game_id: str, player_id: str | int, reason: str) -> list:
    """
    Handle P2P validation failure - prepare for re-pool.

    Returns list of socket_ids that need to be notified for re-pool.
    Game is NOT removed yet - caller should emit events first.
    """
    with self.lock:
        game = self.games.get(game_id)
        if not game:
            logger.warning(f"Validation failure for non-existent game {game_id}")
            return []

        logger.warning(
            f"P2P validation failed for game {game_id}, "
            f"player {player_id}: {reason}"
        )

        # Return all player socket_ids for notification
        return list(game.players.values())

def remove_game(self, game_id: str) -> None:
    """Remove a game from the coordinator (called after notifying players)."""
    with self.lock:
        if game_id in self.games:
            game = self.games[game_id]
            # Stop server runner if exists
            if game.server_authoritative and game.server_runner:
                game.server_runner.stop()
            del self.games[game_id]
            logger.info(f"Removed game {game_id} from coordinator")
```

**In app.py:**

3. **Add socket handlers for P2P validation events** (after mid_game_exclusion handler):
```python
@socketio.on("p2p_validation_status")
def handle_p2p_validation_status(data):
    """Handle P2P validation status update (for UI updates)."""
    game_id = data.get("game_id")
    status = data.get("status")

    # Relay status to all players in game room for UI update
    socketio.emit(
        "p2p_validation_status",
        {"status": status},
        room=game_id,
    )


@socketio.on("p2p_validation_success")
def handle_p2p_validation_success(data):
    """Handle successful P2P validation from a client."""
    global PYODIDE_COORDINATOR

    if PYODIDE_COORDINATOR is None:
        logger.error("PYODIDE_COORDINATOR not initialized")
        return

    game_id = data.get("game_id")
    player_id = data.get("player_id")

    result = PYODIDE_COORDINATOR.record_validation_success(game_id, player_id)

    if result == 'complete':
        # All players validated - emit completion to all
        logger.info(f"All players validated in game {game_id}")
        socketio.emit(
            "p2p_validation_complete",
            {"game_id": game_id},
            room=game_id,
        )
    # If 'waiting', do nothing - other player(s) still validating


@socketio.on("p2p_validation_failed")
def handle_p2p_validation_failed(data):
    """Handle P2P validation failure - re-pool both players."""
    global PYODIDE_COORDINATOR, GAME_MANAGERS, STAGERS

    if PYODIDE_COORDINATOR is None:
        logger.error("PYODIDE_COORDINATOR not initialized")
        return

    game_id = data.get("game_id")
    player_id = data.get("player_id")
    reason = data.get("reason", "unknown")

    logger.warning(f"P2P validation failed for game {game_id}: {reason}")

    # Get socket IDs before cleanup
    socket_ids = PYODIDE_COORDINATOR.handle_validation_failure(game_id, player_id, reason)

    # Emit re-pool event to all players in the game
    for socket_id in socket_ids:
        socketio.emit(
            "p2p_validation_repool",
            {
                "message": "Connection could not be established. Finding new partner...",
                "reason": reason,
            },
            room=socket_id,
        )

    # Clean up game from coordinator
    PYODIDE_COORDINATOR.remove_game(game_id)

    # Clean up game from game manager
    # Find the scene's game manager and remove the game
    for scene_id, game_manager in GAME_MANAGERS.items():
        if game_id in game_manager.games:
            # Remove subjects from game tracking
            game = game_manager.games.get(game_id)
            if game:
                for subject_id in list(game.human_players.values()):
                    if subject_id in game_manager.subject_games:
                        del game_manager.subject_games[subject_id]
                    if subject_id in game_manager.subject_rooms:
                        del game_manager.subject_rooms[subject_id]
            game_manager._remove_game(game_id)
            logger.info(f"Cleaned up game {game_id} from GameManager for scene {scene_id}")
            break
```
  </action>
  <verify>
Check that validation methods exist in coordinator:
- `grep -n "record_validation_success" interactive_gym/server/pyodide_game_coordinator.py`
- `grep -n "handle_validation_failure" interactive_gym/server/pyodide_game_coordinator.py`

Check that socket handlers exist in app.py:
- `grep -n "p2p_validation_success" interactive_gym/server/app.py`
- `grep -n "p2p_validation_repool" interactive_gym/server/app.py`
  </verify>
  <done>
Server-side validation coordination implemented: PyodideGameState tracks validated players, coordinator has record_validation_success() and handle_validation_failure() methods, app.py has socket handlers for validation events and re-pool cleanup.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add client status UI updates</name>
  <files>
    interactive_gym/server/static/js/index.js
  </files>
  <action>
Add socket handlers for validation status updates in index.js.

1. **Add p2p_validation_status handler** (after the waiting_room_player_left handler, around line 467):
```javascript
// P2P Validation Status (Phase 19)
socket.on('p2p_validation_status', function(data) {
    var status = data.status;
    var message = '';

    switch (status) {
        case 'connecting':
            message = 'Connecting with your partner...';
            break;
        case 'validating':
            message = 'Verifying connection quality...';
            break;
        case 'validated':
            message = 'Connection established! Starting game...';
            break;
        default:
            return;  // Unknown status, don't update UI
    }

    // Update waiting room text
    $("#waitroomText").text(message);
    $("#waitroomText").show();
});
```

2. **Add p2p_validation_repool handler** (after the p2p_validation_status handler):
```javascript
// P2P Validation Re-pool (Phase 19)
socket.on('p2p_validation_repool', function(data) {
    console.log("[P2P] Re-pool requested:", data.reason);

    // Clear any existing waitroom intervals
    if (waitroomInterval) {
        clearInterval(waitroomInterval);
        waitroomInterval = null;
    }

    // Show message to user
    var message = data.message || "Finding new partner...";
    $("#waitroomText").text(message);
    $("#waitroomText").show();

    // Brief delay, then re-emit join_game to re-enter matchmaking
    setTimeout(function() {
        console.log("[P2P] Re-joining matchmaking pool");
        socket.emit("join_game", {session_id: window.sessionId});
    }, 2000);
});
```

3. **Add p2p_validation_complete handler** (after the p2p_validation_repool handler):
```javascript
// P2P Validation Complete (Phase 19)
socket.on('p2p_validation_complete', function(data) {
    console.log("[P2P] Validation complete, game starting");
    $("#waitroomText").text("Connection verified! Starting game...");
});
```
  </action>
  <verify>
Check that handlers exist in index.js:
- `grep -n "p2p_validation_status" interactive_gym/server/static/js/index.js`
- `grep -n "p2p_validation_repool" interactive_gym/server/static/js/index.js`
- `grep -n "p2p_validation_complete" interactive_gym/server/static/js/index.js`
  </verify>
  <done>
Client UI handlers implemented: p2p_validation_status shows status messages, p2p_validation_repool shows failure message and triggers re-join after 2s delay, p2p_validation_complete shows success message.
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify the full flow:

1. **Message protocol exists:**
   ```bash
   grep -n "P2P_MSG_VALIDATION" interactive_gym/server/static/js/pyodide_multiplayer_game.js
   ```

2. **Client state machine exists:**
   ```bash
   grep -n "p2pValidation" interactive_gym/server/static/js/pyodide_multiplayer_game.js | head -10
   ```

3. **Server validation methods exist:**
   ```bash
   grep -n "def.*validation" interactive_gym/server/pyodide_game_coordinator.py
   ```

4. **Socket handlers in app.py:**
   ```bash
   grep -n "@socketio.on.*p2p_validation" interactive_gym/server/app.py
   ```

5. **UI handlers in index.js:**
   ```bash
   grep -n "p2p_validation" interactive_gym/server/static/js/index.js
   ```
</verification>

<success_criteria>
- [ ] WAIT-01: P2P validation ping/pong exchange required before p2p_validation_complete is emitted
- [ ] WAIT-02: On validation timeout, p2p_validation_repool emitted and both players return to matchmaking
- [ ] WAIT-03: Status UI shows "Connecting...", "Verifying...", "Connection established!" or "Finding new partner..."
- [ ] Game ONLY starts after both players emit p2p_validation_success and server emits p2p_validation_complete
</success_criteria>

<output>
After completion, create `.planning/phases/19-waiting-room-validation/19-01-SUMMARY.md`
</output>
