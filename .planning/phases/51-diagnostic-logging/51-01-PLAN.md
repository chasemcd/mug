---
phase: 51-diagnostic-logging
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/app.py
  - interactive_gym/server/game_manager.py
autonomous: true

must_haves:
  truths:
    - "join_game logs subject_games state at entry"
    - "State validation runs before routing to GameManager"
    - "Client receives error event when waiting room state is invalid"
  artifacts:
    - path: "interactive_gym/server/app.py"
      provides: "Diagnostic logging in join_game handler"
      contains: "subject_id in game_manager.subject_games"
    - path: "interactive_gym/server/game_manager.py"
      provides: "State validation before add_subject_to_game"
      contains: "validate_subject_state"
  key_links:
    - from: "interactive_gym/server/app.py"
      to: "game_manager.validate_subject_state()"
      via: "validation call before add_subject_to_game"
      pattern: "validate_subject_state.*subject_id"
---

<objective>
Add diagnostic logging and state validation to the join_game flow to understand the exact failure path where new participants get routed to stale games.

Purpose: The known bug shows "Game manager already exists for scene X, reusing it" and participants stuck after clicking Start. We need to understand whether `subject_id in subject_games` at join_game entry, what state exists when routing happens, and emit clear errors to clients when state is invalid.

Output:
- Diagnostic logs at join_game entry showing subject_games state
- State validation before GameManager routing
- Client error events when waiting room state is invalid
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@interactive_gym/server/app.py (lines 514-603 - join_game handler)
@interactive_gym/server/game_manager.py (lines 39-100 - class and subject_games)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add diagnostic logging to join_game handler</name>
  <files>interactive_gym/server/app.py</files>
  <action>
Add comprehensive diagnostic logging at the entry of the `join_game` handler (after line 517, before subject_id validation).

Log the following at INFO level with `[JoinGame:Diag]` prefix:
1. Whether `subject_id` is already in `game_manager.subject_games` (for ALL game managers, not just current scene)
2. The current state of `game_manager.subject_games.keys()` for the current scene's game manager
3. The current state of `game_manager.active_games` for the current scene's game manager
4. The current `waiting_games` list for the current scene's game manager

The logging should happen BEFORE any subject_id validation so we can see the state even for invalid subjects.

Format example:
```python
# Diagnostic logging for stale game routing bug (BUG-04)
if game_manager is not None:
    logger.info(
        f"[JoinGame:Diag] subject_id={subject_id}, "
        f"in_subject_games={subject_id in game_manager.subject_games}, "
        f"subject_games_keys={list(game_manager.subject_games.keys())}, "
        f"active_games={list(game_manager.active_games)}, "
        f"waiting_games={game_manager.waiting_games}"
    )
```

Also add diagnostic logging inside the existing `subject_in_game` check block (around line 568) to log WHY the subject is already in a game:
```python
if game_manager.subject_in_game(subject_id):
    stale_game_id = game_manager.subject_games.get(subject_id)
    stale_game = game_manager.games.get(stale_game_id)
    logger.warning(
        f"[JoinGame:Diag] Subject {subject_id} has stale game entry. "
        f"game_id={stale_game_id}, "
        f"game_exists={stale_game is not None}, "
        f"game_status={stale_game.status if stale_game else 'N/A'}, "
        f"game_active={stale_game_id in game_manager.active_games if stale_game_id else False}"
    )
```
  </action>
  <verify>
Run the server and click "Start" button in the waiting room. Check server logs for `[JoinGame:Diag]` entries showing the subject_games state.
  </verify>
  <done>
`join_game` logs `subject_id in subject_games` status and full state snapshot at entry for every join attempt.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add state validation before GameManager routing</name>
  <files>interactive_gym/server/game_manager.py</files>
  <action>
Add a `validate_subject_state` method to `GameManager` class that checks for invalid states before routing.

Add after `subject_in_game` method (around line 96):

```python
def validate_subject_state(self, subject_id: SubjectID) -> tuple[bool, str | None]:
    """Validate subject state before adding to a game.

    Checks for invalid states that could cause routing issues:
    - Subject already in subject_games but game doesn't exist
    - Subject in subject_rooms but not in subject_games
    - Subject in a game that's already ended

    Returns:
        (is_valid, error_message) - True if state is valid, False with error message if not
    """
    # Check for orphaned subject_games entry
    if subject_id in self.subject_games:
        game_id = self.subject_games[subject_id]
        if game_id not in self.games:
            logger.warning(
                f"[StateValidation] Subject {subject_id} has orphaned subject_games entry. "
                f"game_id={game_id} not in games. Cleaning up."
            )
            # Clean up orphaned entry
            del self.subject_games[subject_id]
            if subject_id in self.subject_rooms:
                del self.subject_rooms[subject_id]
            return (True, None)  # Cleaned up, can proceed

        game = self.games[game_id]
        # Check if game is in a terminal state
        if game.status == remote_game.GameStatus.Done or game.status == remote_game.GameStatus.Inactive:
            logger.warning(
                f"[StateValidation] Subject {subject_id} mapped to finished game. "
                f"game_id={game_id}, status={game.status}. Cleaning up."
            )
            # Clean up stale entry
            game.remove_human_player(subject_id)
            del self.subject_games[subject_id]
            if subject_id in self.subject_rooms:
                del self.subject_rooms[subject_id]
            return (True, None)  # Cleaned up, can proceed

    # Check for orphaned subject_rooms entry (should not exist without subject_games)
    if subject_id in self.subject_rooms and subject_id not in self.subject_games:
        logger.warning(
            f"[StateValidation] Subject {subject_id} has orphaned subject_rooms entry. Cleaning up."
        )
        del self.subject_rooms[subject_id]
        return (True, None)  # Cleaned up, can proceed

    return (True, None)  # All checks passed
```

The method should:
1. Log at WARNING level with `[StateValidation]` prefix for any invalid states found
2. Auto-clean orphaned entries when detected
3. Return (True, None) if state is valid or was cleaned
4. Return (False, error_message) for unrecoverable states (none currently, but extensible)
  </action>
  <verify>
Run `python -c "from interactive_gym.server.game_manager import GameManager; print('Import OK')"` to verify no syntax errors.
  </verify>
  <done>
`validate_subject_state` method exists in GameManager and logs/cleans invalid states.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate validation and add client error event</name>
  <files>interactive_gym/server/app.py</files>
  <action>
In the `join_game` handler (around line 565, after the game_manager is obtained and before subject_in_game check):

1. Call `validate_subject_state` and handle the result:

```python
# State validation before routing (BUG-04)
is_valid, error_message = game_manager.validate_subject_state(subject_id)
if not is_valid:
    logger.error(
        f"[JoinGame] State validation failed for {subject_id}: {error_message}"
    )
    socketio.emit(
        "waiting_room_error",
        {
            "message": "Unable to join game due to invalid state. Please refresh the page.",
            "error_code": "INVALID_STATE",
            "details": error_message
        },
        room=flask.request.sid,
    )
    return
```

2. Add logging after successful add_subject_to_game to confirm routing:

```python
try:
    game = game_manager.add_subject_to_game(subject_id)
    if game is not None:
        logger.info(
            f"[JoinGame] Subject {subject_id} successfully added to game {game.game_id}. "
            f"Game starting. Post-add state: subject_games has {len(game_manager.subject_games)} entries."
        )
    else:
        logger.info(
            f"[JoinGame] Subject {subject_id} added to waiting room for scene {current_scene.scene_id}. "
            f"Waiting for more players. Post-add state: subject_games has {len(game_manager.subject_games)} entries."
        )
```

The `waiting_room_error` event is a new event type for client-side handling of waiting room state errors.
  </action>
  <verify>
1. Run the server and attempt a join with invalid state (if possible to simulate) - should see `waiting_room_error` event
2. Normal join flow should show `[JoinGame]` logs with post-add state counts
3. `grep -n "waiting_room_error" interactive_gym/server/app.py` should show the new emit
  </verify>
  <done>
1. State validation runs before routing to GameManager
2. Client receives `waiting_room_error` event when state is invalid
3. Successful joins log post-add state for debugging
  </done>
</task>

</tasks>

<verification>
1. Server starts without errors: `python -c "from interactive_gym.server import app; print('OK')"`
2. Grep confirms new logging patterns:
   - `grep -n "JoinGame:Diag" interactive_gym/server/app.py` shows diagnostic logs
   - `grep -n "StateValidation" interactive_gym/server/game_manager.py` shows validation logs
   - `grep -n "waiting_room_error" interactive_gym/server/app.py` shows client error event
3. No import errors in game_manager.py
</verification>

<success_criteria>
1. `join_game` logs whether `subject_id in subject_games` at entry with full state snapshot
2. `validate_subject_state` method exists and runs before `add_subject_to_game`
3. Client receives `waiting_room_error` event when state validation fails
4. All diagnostic logs use consistent prefixes: `[JoinGame:Diag]`, `[StateValidation]`
</success_criteria>

<output>
After completion, create `.planning/phases/51-diagnostic-logging/51-01-SUMMARY.md`
</output>
