---
phase: 54-participant-state-tracker
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/participant_state.py
  - interactive_gym/server/app.py
  - interactive_gym/server/game_manager.py
autonomous: true

must_haves:
  truths:
    - "ParticipantStateTracker tracks participant states (IDLE, IN_WAITROOM, IN_GAME, GAME_ENDED)"
    - "State checked before routing participant to GameManager"
    - "State updated at every transition point"
  artifacts:
    - path: "interactive_gym/server/participant_state.py"
      provides: "ParticipantState enum and ParticipantStateTracker class"
      contains: "class ParticipantStateTracker"
    - path: "interactive_gym/server/app.py"
      provides: "Integration with PARTICIPANT_TRACKER global"
      contains: "PARTICIPANT_TRACKER"
    - path: "interactive_gym/server/game_manager.py"
      provides: "State updates at transition points"
      contains: "participant_state_tracker"
  key_links:
    - from: "interactive_gym/server/app.py"
      to: "interactive_gym/server/participant_state.py"
      via: "PARTICIPANT_TRACKER.transition_to()"
      pattern: "PARTICIPANT_TRACKER\\.transition_to"
    - from: "interactive_gym/server/game_manager.py"
      to: "interactive_gym/server/participant_state.py"
      via: "self.participant_state_tracker"
      pattern: "participant_state_tracker\\.transition_to"
---

<objective>
Create a ParticipantStateTracker as single source of truth for participant lifecycle states.

Purpose: Prevent participants from being routed to wrong games by tracking their state (IDLE, IN_WAITROOM, IN_GAME, GAME_ENDED) and validating before routing.

Output:
- ParticipantState enum with 4 states
- ParticipantStateTracker class with transition_to() and get_state() methods
- Integration at join_game entry and all transition points
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/51-diagnostic-logging/51-01-SUMMARY.md
@.planning/phases/52-comprehensive-cleanup/52-01-SUMMARY.md
@.planning/phases/53-session-lifecycle/53-01-SUMMARY.md

Key existing patterns:
- SessionState enum in remote_game.py tracks game lifecycle (WAITING, MATCHED, VALIDATING, PLAYING, ENDED)
- validate_subject_state() in game_manager.py validates per-GameManager state
- PARTICIPANT_SESSIONS dict in app.py tracks participant sessions

This phase creates a COMPLEMENTARY tracker:
- SessionState tracks GAME lifecycle (per-game)
- ParticipantState tracks PARTICIPANT lifecycle (per-participant, across games)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ParticipantState enum and ParticipantStateTracker class</name>
  <files>interactive_gym/server/participant_state.py</files>
  <action>
Create new module with:

1. ParticipantState enum with 4 states:
   - IDLE: Not in any game/waitroom
   - IN_WAITROOM: Waiting for match
   - IN_GAME: Actively playing
   - GAME_ENDED: Game finished (terminal until reset)

2. Valid transitions dict (similar to SessionState):
   - IDLE -> IN_WAITROOM (join waiting room)
   - IN_WAITROOM -> IN_GAME (match found, game starts)
   - IN_WAITROOM -> IDLE (waitroom timeout, disconnect)
   - IN_GAME -> GAME_ENDED (game completes)
   - IN_GAME -> IDLE (disconnect mid-game)
   - GAME_ENDED -> IDLE (ready for new game)

3. ParticipantStateTracker class:
   - __init__(self): Initialize _states dict (subject_id -> ParticipantState)
   - get_state(subject_id) -> ParticipantState: Return current state (IDLE if not tracked)
   - transition_to(subject_id, new_state) -> bool: Validate and apply transition
   - reset(subject_id): Remove from tracking (returns to implicit IDLE)
   - is_idle(subject_id) -> bool: Convenience check
   - can_join_waitroom(subject_id) -> bool: Only if IDLE

Use same pattern as SessionState.transition_to():
- Log invalid transitions with logger.error
- Log valid transitions with logger.info
- Return bool for success/failure
  </action>
  <verify>
python -c "from interactive_gym.server.participant_state import ParticipantState, ParticipantStateTracker; t = ParticipantStateTracker(); print(t.get_state('test'), t.can_join_waitroom('test'))"
  </verify>
  <done>
ParticipantState enum has 4 states.
ParticipantStateTracker has get_state(), transition_to(), reset(), is_idle(), can_join_waitroom() methods.
Transition validation matches valid transitions dict.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate tracker into app.py</name>
  <files>interactive_gym/server/app.py</files>
  <action>
1. Import ParticipantStateTracker:
   from interactive_gym.server.participant_state import ParticipantState, ParticipantStateTracker

2. Create global tracker after PARTICIPANT_SESSIONS:
   PARTICIPANT_TRACKER: ParticipantStateTracker = ParticipantStateTracker()

3. In join_game handler, BEFORE the diagnostic logging block:
   Add state check:
   ```python
   # Check participant state before routing
   if not PARTICIPANT_TRACKER.can_join_waitroom(subject_id):
       current_state = PARTICIPANT_TRACKER.get_state(subject_id)
       logger.warning(
           f"[JoinGame] Subject {subject_id} cannot join waitroom, current state: {current_state.name}"
       )
       socketio.emit(
           "waiting_room_error",
           {
               "message": f"Cannot join game while in state: {current_state.name}",
               "error_code": "INVALID_PARTICIPANT_STATE",
               "details": f"Current state: {current_state.name}"
           },
           room=flask.request.sid,
       )
       return

   # Transition to IN_WAITROOM
   PARTICIPANT_TRACKER.transition_to(subject_id, ParticipantState.IN_WAITROOM)
   ```

4. In handle_p2p_game_ended handler (search for "p2p_game_ended"):
   After cleanup_game() call, add:
   ```python
   for subject_id in player_subject_ids:
       PARTICIPANT_TRACKER.transition_to(subject_id, ParticipantState.GAME_ENDED)
   ```

5. In leave_game handler, before PROCESSED_SUBJECT_NAMES.append:
   Add:
   ```python
   PARTICIPANT_TRACKER.reset(subject_id)
   ```

6. Pass tracker to GameManager constructor:
   In advance_scene where GameManager is instantiated, add:
   participant_state_tracker=PARTICIPANT_TRACKER,
  </action>
  <verify>
grep -n "PARTICIPANT_TRACKER" interactive_gym/server/app.py
grep -n "can_join_waitroom" interactive_gym/server/app.py
  </verify>
  <done>
PARTICIPANT_TRACKER global created.
join_game checks can_join_waitroom() before routing.
Invalid state returns waiting_room_error with INVALID_PARTICIPANT_STATE code.
State transitions called at join_game, p2p_game_ended, leave_game.
Tracker passed to GameManager constructor.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update GameManager to use tracker at transition points</name>
  <files>interactive_gym/server/game_manager.py</files>
  <action>
1. Add participant_state_tracker parameter to __init__:
   ```python
   def __init__(
       self,
       scene: gym_scene.GymScene,
       experiment_config: remote_config.RemoteConfig,
       sio: flask_socketio.SocketIO,
       pyodide_coordinator: pyodide_game_coordinator.PyodideGameCoordinator | None = None,
       pairing_manager: player_pairing_manager.PlayerPairingManager | None = None,
       get_subject_rtt: callable | None = None,
       participant_state_tracker = None,  # Optional for backward compatibility
   ):
       ...
       self.participant_state_tracker = participant_state_tracker
   ```

2. Import ParticipantState at top:
   from interactive_gym.server.participant_state import ParticipantState

3. In start_game(), after logging "Starting game...":
   Add transition to IN_GAME for all players:
   ```python
   if self.participant_state_tracker:
       for subject_id in game.human_players.values():
           if subject_id and subject_id != utils.Available:
               self.participant_state_tracker.transition_to(subject_id, ParticipantState.IN_GAME)
   ```

4. In cleanup_game(), after transitioning to SessionState.ENDED:
   Add transition to GAME_ENDED:
   ```python
   if self.participant_state_tracker:
       for subject_id in list(game.human_players.values()):
           if subject_id and subject_id != utils.Available:
               self.participant_state_tracker.transition_to(subject_id, ParticipantState.GAME_ENDED)
   ```

5. In leave_game(), when cleaning up a subject:
   Reset their participant state:
   ```python
   if self.participant_state_tracker:
       self.participant_state_tracker.reset(subject_id)
   ```

Note: The tracker may be None for backward compatibility with existing tests. Always guard with `if self.participant_state_tracker:`.
  </action>
  <verify>
grep -n "participant_state_tracker" interactive_gym/server/game_manager.py
grep -n "ParticipantState" interactive_gym/server/game_manager.py
  </verify>
  <done>
GameManager accepts participant_state_tracker parameter.
start_game() transitions all players to IN_GAME.
cleanup_game() transitions all players to GAME_ENDED.
leave_game() resets participant state.
All transitions guarded with None check for backward compatibility.
  </done>
</task>

</tasks>

<verification>
1. Unit test the state tracker:
   python -c "
from interactive_gym.server.participant_state import ParticipantState, ParticipantStateTracker
t = ParticipantStateTracker()
# Test initial state
assert t.get_state('user1') == ParticipantState.IDLE
assert t.can_join_waitroom('user1') == True
# Test transition to waitroom
assert t.transition_to('user1', ParticipantState.IN_WAITROOM) == True
assert t.can_join_waitroom('user1') == False
# Test transition to in_game
assert t.transition_to('user1', ParticipantState.IN_GAME) == True
# Test invalid transition (can't go back to waitroom from in_game)
assert t.transition_to('user1', ParticipantState.IN_WAITROOM) == False
# Test transition to ended
assert t.transition_to('user1', ParticipantState.GAME_ENDED) == True
# Test reset
t.reset('user1')
assert t.get_state('user1') == ParticipantState.IDLE
print('All state tracker tests passed!')
"

2. Run E2E tests to verify no regressions:
   python -m pytest tests/e2e/test_infrastructure.py -v

3. Verify integration:
   grep -r "PARTICIPANT_TRACKER" interactive_gym/server/
   grep -r "participant_state_tracker" interactive_gym/server/
</verification>

<success_criteria>
1. ParticipantState enum exists with IDLE, IN_WAITROOM, IN_GAME, GAME_ENDED states
2. ParticipantStateTracker validates transitions and logs state changes
3. join_game checks can_join_waitroom() before routing
4. All transition points update participant state
5. E2E tests pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/54-participant-state-tracker/54-01-SUMMARY.md`
</output>
