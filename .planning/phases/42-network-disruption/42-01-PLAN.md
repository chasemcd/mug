---
phase: 42-network-disruption
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/fixtures/network_helpers.py
  - tests/e2e/test_network_disruption.py
autonomous: true

must_haves:
  truths:
    - "Test can simulate packet loss causing rollbacks in at least one player"
    - "Test can trigger tab unfocus/refocus and observe fast-forward"
    - "Episode completes successfully after packet loss disruption"
    - "Episode completes successfully after tab visibility disruption"
  artifacts:
    - path: "tests/fixtures/network_helpers.py"
      provides: "Packet loss and visibility change helpers"
      contains: "apply_packet_loss|set_tab_visibility"
    - path: "tests/e2e/test_network_disruption.py"
      provides: "Network disruption test suite"
      exports: ["test_packet_loss_triggers_rollback", "test_tab_visibility_triggers_fast_forward"]
  key_links:
    - from: "tests/e2e/test_network_disruption.py"
      to: "tests/fixtures/network_helpers.py"
      via: "import apply_packet_loss, set_tab_visibility"
      pattern: "from tests.fixtures.network_helpers import"
    - from: "tests/e2e/test_network_disruption.py"
      to: "game.rollbackCount"
      via: "page.evaluate to access game state"
      pattern: "game\\.rollbackCount"
    - from: "set_tab_visibility"
      to: "game.focusManager.isBackgrounded"
      via: "JavaScript dispatchEvent triggers FocusManager"
      pattern: "visibilitychange"
---

<objective>
Create network disruption tests validating rollback and fast-forward mechanisms under packet loss and tab visibility changes.

Purpose: Validate that the dual-buffer data recording (v1.8) correctly handles network disruptions - packet loss triggers rollbacks and tab backgrounding triggers fast-forward on refocus.

Output:
- Extended `network_helpers.py` with packet loss and visibility helpers
- New `test_network_disruption.py` with 2 tests (NET-02, NET-03)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-network-disruption/42-RESEARCH.md

# Prior phase context
@.planning/phases/41-latency-injection/41-01-SUMMARY.md

# Existing test infrastructure
@tests/fixtures/network_helpers.py
@tests/fixtures/game_helpers.py
@tests/e2e/test_latency_injection.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add packet loss and visibility helpers to network_helpers.py</name>
  <files>tests/fixtures/network_helpers.py</files>
  <action>
Extend `network_helpers.py` with new helper functions following research patterns.

**Add apply_packet_loss() function:**
```python
def apply_packet_loss(
    page: Page,
    packet_loss_percent: float,
    latency_ms: int = 50
) -> CDPSession:
    """
    Apply WebRTC packet loss and optional base latency via CDP.

    Args:
        page: Playwright Page object
        packet_loss_percent: Packet loss percentage (0-100)
                            Recommended: 10-15% to trigger rollbacks without breaking connection
        latency_ms: Base latency in milliseconds (default 50ms for ordering effects)

    Returns:
        CDPSession for later modification or cleanup

    Note:
        packetLoss specifically affects WebRTC traffic (used for GGPO inputs).
        Higher values (>20%) risk breaking the P2P connection entirely.
    """
    cdp = page.context.new_cdp_session(page)
    cdp.send("Network.enable")
    cdp.send("Network.emulateNetworkConditions", {
        "offline": False,
        "latency": latency_ms,
        "downloadThroughput": -1,
        "uploadThroughput": -1,
        "packetLoss": packet_loss_percent,
    })
    return cdp
```

**Add set_tab_visibility() function:**
```python
def set_tab_visibility(page: Page, visible: bool) -> None:
    """
    Simulate tab visibility change by overriding document properties
    and dispatching visibilitychange event.

    Args:
        page: Playwright Page object
        visible: True for visible, False for hidden

    Note:
        This triggers the game's FocusManager which:
        - When hidden: buffers partner inputs, uses defaultAction for local player
        - When visible: triggers fast-forward to catch up with partner
    """
    hidden_value = 'false' if visible else 'true'
    visibility_state = 'visible' if visible else 'hidden'

    page.evaluate(f"""() => {{
        // Override document.hidden property
        Object.defineProperty(document, 'hidden', {{
            configurable: true,
            get: () => {hidden_value}
        }});

        // Override document.visibilityState property
        Object.defineProperty(document, 'visibilityState', {{
            configurable: true,
            get: () => '{visibility_state}'
        }});

        // Dispatch the visibilitychange event
        document.dispatchEvent(new Event('visibilitychange'));
    }}""")
```

**Add wait_for_focus_manager_state() function:**
```python
def wait_for_focus_manager_state(page: Page, backgrounded: bool, timeout: int = 10000) -> None:
    """Wait for FocusManager to reflect expected state."""
    expected = 'true' if backgrounded else 'false'
    page.wait_for_function(
        f"() => window.game?.focusManager?.isBackgrounded === {expected}",
        timeout=timeout
    )
```

**Add get_rollback_stats() function:**
```python
def get_rollback_stats(page: Page) -> dict:
    """
    Get rollback statistics from the game.

    Returns dict with:
        - rollbackCount: Total rollbacks this episode
        - maxRollbackFrames: Deepest rollback (frames replayed)
        - rollbackEvents: Array of rollback event details
        - rollbackInProgress: Whether rollback is currently executing
    """
    return page.evaluate("""() => {
        const game = window.game;
        if (!game) return null;

        return {
            rollbackCount: game.rollbackCount || 0,
            maxRollbackFrames: game.maxRollbackFrames || 0,
            rollbackEvents: game.sessionMetrics?.rollbacks?.events || [],
            rollbackInProgress: game.rollbackInProgress || false,
        };
    }""")
```

**Add get_fast_forward_state() function:**
```python
def get_fast_forward_state(page: Page) -> dict:
    """
    Get fast-forward related state from the game.

    Returns dict with frame tracking info useful for detecting
    fast-forward has occurred (frame number jumps).
    """
    return page.evaluate("""() => {
        const game = window.game;
        if (!game) return null;

        return {
            frameNumber: game.frameNumber,
            confirmedFrame: game.confirmedFrame,
            pendingFastForward: game._pendingFastForward || false,
            isBackgrounded: game.focusManager?.isBackgrounded || false,
            bufferedInputCount: game.focusManager?.bufferedInputs?.length || 0,
        };
    }""")
```
  </action>
  <verify>
```bash
# Verify new functions exist
grep -n "def apply_packet_loss" tests/fixtures/network_helpers.py
grep -n "def set_tab_visibility" tests/fixtures/network_helpers.py
grep -n "def wait_for_focus_manager_state" tests/fixtures/network_helpers.py
grep -n "def get_rollback_stats" tests/fixtures/network_helpers.py
grep -n "def get_fast_forward_state" tests/fixtures/network_helpers.py

# All 5 functions should be found
```
  </verify>
  <done>
network_helpers.py contains:
- apply_packet_loss() with CDP packetLoss parameter
- set_tab_visibility() with document property override and event dispatch
- wait_for_focus_manager_state() for visibility state verification
- get_rollback_stats() for rollback observation
- get_fast_forward_state() for fast-forward detection
  </done>
</task>

<task type="auto">
  <name>Task 2: Create network disruption test suite</name>
  <files>tests/e2e/test_network_disruption.py</files>
  <action>
Create `tests/e2e/test_network_disruption.py` following the pattern from `test_latency_injection.py`.

**Module docstring:**
```python
"""
Network disruption tests - validate rollback and fast-forward mechanisms.

These tests use CDP and JavaScript event injection to simulate network disruptions
and verify that the game correctly handles:
- NET-02: Packet loss triggering rollback scenarios
- NET-03: Tab unfocus/refocus exercising fast-forward path

The tests validate that episodes complete successfully under disruption,
and that rollback/fast-forward events are observable in game state.

Key behaviors tested:
1. Packet loss causes late/lost inputs, triggering GGPO rollbacks
2. Tab backgrounding causes frame deficit, triggering fast-forward on refocus
3. Both disruption types complete episode without data corruption
"""
```

**Test 1: test_packet_loss_triggers_rollback (NET-02)**
- Apply 15% packet loss to one player BEFORE navigation
- Use `run_full_episode_flow()` from test_latency_injection.py pattern
- After episode, verify `rollbackCount > 0` for at least one player
- Log rollback statistics for debugging

```python
@pytest.mark.timeout(300)  # 5 minutes max
def test_packet_loss_triggers_rollback(flask_server, player_contexts):
    """
    NET-02: Test that packet loss triggers rollback scenarios.

    Strategy:
    1. Apply packet loss to player 2 (15% loss, 50ms base latency)
    2. Let episode run (players idle)
    3. Verify rollbacks occurred due to late/lost packets
    4. Verify episode completes despite disruption

    Note: Uses 15% packet loss which is aggressive enough to trigger
    mispredictions but not so severe as to break the P2P connection.
    """
    page1, page2 = player_contexts
    base_url = flask_server["url"]

    # Apply packet loss to player 2 BEFORE navigation
    cdp2 = apply_packet_loss(page2, packet_loss_percent=15, latency_ms=50)

    try:
        # Run full episode flow (reuse from latency tests)
        final_state1, final_state2 = run_full_episode_flow(page1, page2, base_url)

        # Get rollback stats from both players
        stats1 = get_rollback_stats(page1)
        stats2 = get_rollback_stats(page2)

        # Verify at least one player experienced rollbacks
        # (packet loss causes late inputs which trigger misprediction correction)
        total_rollbacks = (stats1['rollbackCount'] or 0) + (stats2['rollbackCount'] or 0)

        # Log for debugging (useful when test passes but we want visibility)
        print(f"\n[Packet Loss 15%] Rollback statistics:")
        print(f"  Player 1: rollbacks={stats1['rollbackCount']}, maxFrames={stats1['maxRollbackFrames']}")
        print(f"  Player 2: rollbacks={stats2['rollbackCount']}, maxFrames={stats2['maxRollbackFrames']}")
        print(f"  Total rollbacks: {total_rollbacks}")

        assert total_rollbacks > 0, (
            f"Expected rollbacks due to packet loss, but got 0. "
            f"Player 1: {stats1}, Player 2: {stats2}"
        )

        # Verify episode completed despite rollbacks
        assert final_state1['numEpisodes'] >= 1, "Player 1 should complete episode"
        assert final_state2['numEpisodes'] >= 1, "Player 2 should complete episode"

        # Verify they stayed in same game
        assert final_state1['gameId'] == final_state2['gameId'], "Players should be in same game"

        print(f"  Episode completed: gameId={final_state1['gameId']}")

    finally:
        try:
            cdp2.detach()
        except Exception:
            pass
```

**Test 2: test_tab_visibility_triggers_fast_forward (NET-03)**
- Start game normally (no network disruption)
- Mid-episode, hide player 1's tab for 5 seconds while player 2 continues
- Show player 1's tab and wait for fast-forward
- Verify frame number jumped (fast-forward occurred)
- Verify episode completes

```python
@pytest.mark.timeout(300)  # 5 minutes max
def test_tab_visibility_triggers_fast_forward(flask_server, player_contexts):
    """
    NET-03: Test that tab unfocus/refocus exercises fast-forward path.

    Strategy:
    1. Start game normally
    2. Let both players run for a few seconds
    3. Hide player 1's tab (simulated via JS)
    4. Wait 5 seconds while player 2 continues
    5. Show player 1's tab (should trigger fast-forward)
    6. Verify player 1 caught up (frame number jumped)
    7. Verify episode completes

    Note: Fast-forward processes buffered partner inputs and steps
    through frames rapidly without rendering to catch up.
    """
    page1, page2 = player_contexts
    base_url = flask_server["url"]

    # Navigate to game
    page1.goto(base_url)
    page2.goto(base_url)

    # Socket connect
    wait_for_socket_connected(page1, timeout=30000)
    wait_for_socket_connected(page2, timeout=30000)

    # Pass instructions
    click_advance_button(page1, timeout=60000)
    click_advance_button(page2, timeout=60000)

    # Complete tutorials
    complete_tutorial_and_advance(page1, timeout=120000)
    complete_tutorial_and_advance(page2, timeout=120000)

    # Start multiplayer
    click_start_button(page1, timeout=60000)
    click_start_button(page2, timeout=60000)

    # Wait for game to start
    wait_for_game_canvas(page1, timeout=120000)
    wait_for_game_canvas(page2, timeout=120000)
    wait_for_game_object(page1, timeout=60000)
    wait_for_game_object(page2, timeout=60000)

    # Let game run for 3 seconds (build up some frames)
    import time
    time.sleep(3)

    # Record player 1's frame number before hiding
    state_before = get_fast_forward_state(page1)
    frame_before_hide = state_before['frameNumber']
    print(f"\n[Tab Visibility] Before hide: frame={frame_before_hide}")

    # Hide player 1's tab
    set_tab_visibility(page1, visible=False)
    wait_for_focus_manager_state(page1, backgrounded=True, timeout=5000)

    print(f"  Player 1 backgrounded, waiting 5 seconds...")

    # Wait 5 seconds while player 2 continues (player 2 advances frames)
    time.sleep(5)

    # Record player 2's frame number (they advanced while player 1 was hidden)
    state_p2_during = get_fast_forward_state(page2)
    print(f"  Player 2 frame during hide: {state_p2_during['frameNumber']}")

    # Show player 1's tab (triggers fast-forward)
    set_tab_visibility(page1, visible=True)
    wait_for_focus_manager_state(page1, backgrounded=False, timeout=5000)

    # Wait for fast-forward to complete (frame number should catch up)
    # Give it up to 10 seconds since fast-forward has safety limits
    page1.wait_for_function(
        f"""() => {{
            const game = window.game;
            return game &&
                   !game._pendingFastForward &&
                   game.frameNumber > {frame_before_hide + 20};  // Should have advanced significantly
        }}""",
        timeout=30000
    )

    # Get final state
    state_after = get_fast_forward_state(page1)
    frame_after_show = state_after['frameNumber']

    print(f"  After show: frame={frame_after_show}")
    print(f"  Frame jump: {frame_after_show - frame_before_hide} frames")

    # Verify fast-forward occurred (frame number jumped significantly)
    frame_jump = frame_after_show - frame_before_hide
    assert frame_jump > 30, (
        f"Expected significant frame jump after fast-forward, "
        f"but only got {frame_jump} frames (before={frame_before_hide}, after={frame_after_show})"
    )

    # Now complete the episode
    wait_for_episode_complete(page1, episode_num=1, timeout=180000)
    wait_for_episode_complete(page2, episode_num=1, timeout=180000)

    # Get final game states
    final_state1 = get_game_state(page1)
    final_state2 = get_game_state(page2)

    # Verify completion
    assert final_state1['numEpisodes'] >= 1, "Player 1 should complete episode"
    assert final_state2['numEpisodes'] >= 1, "Player 2 should complete episode"
    assert final_state1['gameId'] == final_state2['gameId'], "Players should be in same game"

    print(f"  Episode completed: gameId={final_state1['gameId']}")
```

**Imports section:**
```python
import pytest
import time
from tests.fixtures.network_helpers import (
    apply_packet_loss,
    set_tab_visibility,
    wait_for_focus_manager_state,
    get_rollback_stats,
    get_fast_forward_state,
)
from tests.fixtures.game_helpers import (
    wait_for_socket_connected,
    wait_for_game_canvas,
    wait_for_game_object,
    wait_for_episode_complete,
    get_game_state,
    click_advance_button,
    click_start_button,
    complete_tutorial_and_advance,
)
from tests.e2e.test_latency_injection import run_full_episode_flow
```
  </action>
  <verify>
```bash
# Verify test file structure
grep -n "def test_packet_loss_triggers_rollback" tests/e2e/test_network_disruption.py
grep -n "def test_tab_visibility_triggers_fast_forward" tests/e2e/test_network_disruption.py
grep -n "NET-02" tests/e2e/test_network_disruption.py
grep -n "NET-03" tests/e2e/test_network_disruption.py

# Run tests (may take 5-10 minutes)
cd /Users/chasemcd/Repositories/interactive-gym && python -m pytest tests/e2e/test_network_disruption.py -v --timeout=600 2>&1 | tail -50
```
  </verify>
  <done>
test_network_disruption.py contains:
- test_packet_loss_triggers_rollback (NET-02) that applies 15% packet loss and verifies rollbackCount > 0
- test_tab_visibility_triggers_fast_forward (NET-03) that hides/shows tab and verifies frame jump
- Both tests complete full episodes after disruption
- Rollback and fast-forward events are observable via game state
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Packet loss helper works:**
```bash
grep "packetLoss" tests/fixtures/network_helpers.py
# Should show packetLoss parameter in apply_packet_loss()
```

2. **Visibility helper works:**
```bash
grep "visibilitychange" tests/fixtures/network_helpers.py
# Should show event dispatch in set_tab_visibility()
```

3. **Tests exist and pass:**
```bash
python -m pytest tests/e2e/test_network_disruption.py -v --timeout=600
# Should show 2 tests passing
```

4. **Rollbacks observable:**
Test output should show `Total rollbacks: N` where N > 0 for packet loss test.

5. **Fast-forward observable:**
Test output should show `Frame jump: N frames` where N > 30 for visibility test.
</verification>

<success_criteria>
- [ ] apply_packet_loss() function exists with CDP packetLoss parameter
- [ ] set_tab_visibility() function exists with document property override
- [ ] get_rollback_stats() function exists for rollback observation
- [ ] get_fast_forward_state() function exists for frame tracking
- [ ] test_packet_loss_triggers_rollback passes with rollbackCount > 0
- [ ] test_tab_visibility_triggers_fast_forward passes with frame jump > 30
- [ ] Both tests complete full episodes after disruption
- [ ] NET-02 and NET-03 requirements satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/42-network-disruption/42-01-SUMMARY.md` using template at `@~/.claude/get-shit-done/templates/summary.md`
</output>
