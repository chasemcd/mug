---
phase: 16-continuous-monitoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/scenes/gym_scene.py
  - interactive_gym/server/static/js/continuous_monitor.js
  - interactive_gym/server/static/js/pyodide_multiplayer_game.js
  - interactive_gym/server/static/js/index.js
  - interactive_gym/server/static/templates/index.html
autonomous: true

must_haves:
  truths:
    - "Participant ping monitored continuously during gameplay (not just at entry)"
    - "Participant excluded mid-game if ping exceeds threshold for 3+ consecutive measurements"
    - "Tab switch detected immediately when participant leaves experiment window"
    - "Tab switch shows warning after 3s, excludes after 10s (configurable)"
    - "Excluded participant sees appropriate message explaining why"
  artifacts:
    - path: "interactive_gym/scenes/gym_scene.py"
      provides: "continuous_monitoring() configuration method"
      contains: "def continuous_monitoring"
    - path: "interactive_gym/server/static/js/continuous_monitor.js"
      provides: "ContinuousMonitor class with ping and tab monitoring"
      exports: ["ContinuousMonitor"]
    - path: "interactive_gym/server/static/js/pyodide_multiplayer_game.js"
      provides: "Mid-game exclusion handling integrated with game loop"
      contains: "_handleMidGameExclusion"
  key_links:
    - from: "pyodide_multiplayer_game.js"
      to: "continuous_monitor.js"
      via: "import and instantiation in constructor"
      pattern: "import.*ContinuousMonitor|new ContinuousMonitor"
    - from: "continuous_monitor.js"
      to: "index.js latencyMeasurements"
      via: "reads current ping from shared measurement"
      pattern: "recordPing|latencyMeasurements"
    - from: "pyodide_multiplayer_game.js step()"
      to: "ContinuousMonitor.check()"
      via: "called each frame during gameplay"
      pattern: "continuousMonitor.*check|_checkContinuousMonitoring"
---

<objective>
Implement continuous monitoring during gameplay that detects sustained ping violations and tab visibility changes, warning or excluding participants mid-game when thresholds are exceeded.

Purpose: Ensure research data quality by detecting and handling connection degradation or participant disengagement during gameplay, not just at entry.

Output:
- `continuous_monitoring()` configuration method on GymScene
- ContinuousMonitor class in new JS module
- Game loop integration for mid-game exclusion
- Warning overlay and exclusion UI
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-entry-screening-rules/15-01-SUMMARY.md
@.planning/phases/16-continuous-monitoring/16-01-RESEARCH.md
@interactive_gym/scenes/gym_scene.py
@interactive_gym/server/static/js/index.js
@interactive_gym/server/static/js/pyodide_multiplayer_game.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add continuous_monitoring() configuration to GymScene</name>
  <files>interactive_gym/scenes/gym_scene.py</files>
  <action>
Add continuous monitoring configuration to GymScene:

1. Add new instance attributes in `__init__` after entry screening block (around line 175):
   ```python
   # Continuous monitoring (Phase 16)
   self.continuous_max_ping: int | None = None  # Max ping during gameplay (ms)
   self.continuous_ping_violation_window: int = 5  # Measurements to track
   self.continuous_ping_required_violations: int = 3  # Consecutive violations for exclusion
   self.continuous_tab_warning_ms: int = 3000  # Warn after 3s hidden
   self.continuous_tab_exclude_ms: int = 10000  # Exclude after 10s hidden
   self.continuous_monitoring_enabled: bool = False  # Master enable flag
   self.continuous_exclusion_messages: dict[str, str] = {
       "ping_warning": "Your connection is unstable. Please close other applications.",
       "ping_exclude": "Your connection became too slow. The game has ended.",
       "tab_warning": "Please return to the experiment window to continue.",
       "tab_exclude": "You left the experiment window for too long. The game has ended."
   }
   ```

2. Add `continuous_monitoring()` method after `entry_screening()` method (around line 703):
   ```python
   def continuous_monitoring(
       self,
       max_ping: int = NotProvided,
       ping_violation_window: int = NotProvided,
       ping_required_violations: int = NotProvided,
       tab_warning_ms: int = NotProvided,
       tab_exclude_ms: int = NotProvided,
       exclusion_messages: dict[str, str] = NotProvided,
   ):
       """Configure continuous monitoring during gameplay.

       This monitoring runs DURING the game, after entry screening passes.
       It detects sustained connection issues or tab switching and can
       warn or exclude participants mid-game.

       :param max_ping: Maximum allowed latency in milliseconds during gameplay.
           Participants are warned/excluded if ping exceeds this for sustained period.
           None disables ping monitoring. defaults to NotProvided
       :type max_ping: int, optional
       :param ping_violation_window: Number of measurements to track for violation
           detection. defaults to NotProvided (uses 5)
       :type ping_violation_window: int, optional
       :param ping_required_violations: Consecutive violations required before
           exclusion. Must be <= ping_violation_window. defaults to NotProvided (uses 3)
       :type ping_required_violations: int, optional
       :param tab_warning_ms: Milliseconds hidden before showing warning.
           None disables tab warning. defaults to NotProvided (uses 3000)
       :type tab_warning_ms: int, optional
       :param tab_exclude_ms: Milliseconds hidden before exclusion.
           None disables tab exclusion. defaults to NotProvided (uses 10000)
       :type tab_exclude_ms: int, optional
       :param exclusion_messages: Custom messages for warnings and exclusions.
           Keys: "ping_warning", "ping_exclude", "tab_warning", "tab_exclude".
           defaults to NotProvided
       :type exclusion_messages: dict[str, str], optional
       :return: The GymScene instance (self)
       :rtype: GymScene
       """
       # Enable continuous monitoring if any parameter is set
       self.continuous_monitoring_enabled = True

       if max_ping is not NotProvided:
           assert max_ping is None or (isinstance(max_ping, int) and max_ping > 0), \
               "max_ping must be None or a positive integer"
           self.continuous_max_ping = max_ping

       if ping_violation_window is not NotProvided:
           assert isinstance(ping_violation_window, int) and ping_violation_window >= 1, \
               "ping_violation_window must be a positive integer"
           self.continuous_ping_violation_window = ping_violation_window

       if ping_required_violations is not NotProvided:
           assert isinstance(ping_required_violations, int) and ping_required_violations >= 1, \
               "ping_required_violations must be a positive integer"
           self.continuous_ping_required_violations = ping_required_violations

       if tab_warning_ms is not NotProvided:
           assert tab_warning_ms is None or (isinstance(tab_warning_ms, int) and tab_warning_ms >= 0), \
               "tab_warning_ms must be None or a non-negative integer"
           self.continuous_tab_warning_ms = tab_warning_ms

       if tab_exclude_ms is not NotProvided:
           assert tab_exclude_ms is None or (isinstance(tab_exclude_ms, int) and tab_exclude_ms >= 0), \
               "tab_exclude_ms must be None or a non-negative integer"
           self.continuous_tab_exclude_ms = tab_exclude_ms

       if exclusion_messages is not NotProvided:
           assert isinstance(exclusion_messages, dict), \
               "exclusion_messages must be a dictionary"
           self.continuous_exclusion_messages = {**self.continuous_exclusion_messages, **exclusion_messages}

       # Validate that required_violations <= window
       if self.continuous_ping_required_violations > self.continuous_ping_violation_window:
           raise ValueError(
               f"ping_required_violations ({self.continuous_ping_required_violations}) "
               f"cannot exceed ping_violation_window ({self.continuous_ping_violation_window})"
           )

       return self
   ```

These new attributes will be automatically included in scene metadata via `get_complete_scene_metadata()`.
  </action>
  <verify>
Run Python to verify syntax and method signature:
```bash
cd /Users/chasemcd/Repositories/interactive-gym && python -c "
from interactive_gym.scenes.gym_scene import GymScene
scene = GymScene()
scene.continuous_monitoring(max_ping=200, tab_warning_ms=5000)
assert scene.continuous_monitoring_enabled == True
assert scene.continuous_max_ping == 200
assert scene.continuous_tab_warning_ms == 5000
print('GymScene.continuous_monitoring() works correctly')
"
```
  </verify>
  <done>
GymScene has `continuous_monitoring()` method that sets all continuous monitoring configuration options, with validation and default messages.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ContinuousMonitor JavaScript module</name>
  <files>
    interactive_gym/server/static/js/continuous_monitor.js
    interactive_gym/server/static/templates/index.html
  </files>
  <action>
Create a new ContinuousMonitor class that handles both ping and tab visibility monitoring:

1. Create `interactive_gym/server/static/js/continuous_monitor.js`:

```javascript
/**
 * Continuous Monitor
 *
 * Monitors ping and tab visibility during gameplay, warning or excluding
 * participants when thresholds are exceeded.
 *
 * Key design decisions:
 * - Uses rolling window for ping to avoid false positives from transient spikes
 * - Requires sustained violations (N consecutive) before exclusion
 * - Tab monitoring uses visibilitychange event (not polling) for immediate detection
 * - Warning shown before exclusion to give participant chance to correct
 */

// Logging helper (matches pyodide_multiplayer_game.js pattern)
const monitorLog = {
    error: (...args) => console.error('[Monitor]', ...args),
    warn: (...args) => console.warn('[Monitor]', ...args),
    info: (...args) => console.log('[Monitor]', ...args),
    debug: (...args) => console.log('[Monitor]', ...args),
};

/**
 * ContinuousMonitor - Tracks ping and tab visibility during gameplay
 */
export class ContinuousMonitor {
    /**
     * Create a ContinuousMonitor instance.
     *
     * @param {Object} config - Configuration from scene metadata
     * @param {number|null} config.continuous_max_ping - Max ping threshold (null = disabled)
     * @param {number} config.continuous_ping_violation_window - Window size for tracking
     * @param {number} config.continuous_ping_required_violations - Consecutive violations needed
     * @param {number|null} config.continuous_tab_warning_ms - Tab hidden warning threshold (null = disabled)
     * @param {number|null} config.continuous_tab_exclude_ms - Tab hidden exclusion threshold (null = disabled)
     * @param {Object} config.continuous_exclusion_messages - Custom messages
     */
    constructor(config) {
        // Ping monitoring config
        this.maxPing = config.continuous_max_ping ?? null;
        this.pingViolationWindow = config.continuous_ping_violation_window ?? 5;
        this.pingRequiredViolations = config.continuous_ping_required_violations ?? 3;
        this.pingMeasurements = [];
        this.pingWarningShown = false;

        // Tab visibility config
        this.tabWarningMs = config.continuous_tab_warning_ms ?? 3000;
        this.tabExcludeMs = config.continuous_tab_exclude_ms ?? 10000;
        this.tabHiddenAt = null;
        this.tabWarningShown = false;

        // Exclusion messages
        this.messages = {
            ping_warning: config.continuous_exclusion_messages?.ping_warning ||
                "Your connection is unstable. Please close other applications.",
            ping_exclude: config.continuous_exclusion_messages?.ping_exclude ||
                "Your connection became too slow. The game has ended.",
            tab_warning: config.continuous_exclusion_messages?.tab_warning ||
                "Please return to the experiment window to continue.",
            tab_exclude: config.continuous_exclusion_messages?.tab_exclude ||
                "You left the experiment window for too long. The game has ended."
        };

        // State tracking
        this.enabled = config.continuous_monitoring_enabled ?? false;
        this.paused = false;  // Pause during episode transitions

        // Callbacks (set by game)
        this.onWarning = null;
        this.onExclude = null;

        // Set up tab visibility listener
        this._setupTabListener();

        monitorLog.info(`ContinuousMonitor initialized: ping=${this.maxPing}ms, tab_warn=${this.tabWarningMs}ms, tab_exclude=${this.tabExcludeMs}ms`);
    }

    /**
     * Set up Page Visibility API listener for immediate tab switch detection.
     * Uses visibilitychange event (not polling) per research recommendations.
     */
    _setupTabListener() {
        document.addEventListener('visibilitychange', () => {
            if (!this.enabled || this.paused) return;

            if (document.hidden) {
                this.tabHiddenAt = Date.now();
                this.tabWarningShown = false;
                monitorLog.debug('Tab hidden at', this.tabHiddenAt);
            } else {
                // Tab returned to foreground
                const hiddenDuration = this.tabHiddenAt ? Date.now() - this.tabHiddenAt : 0;
                monitorLog.debug(`Tab visible after ${hiddenDuration}ms hidden`);
                this.tabHiddenAt = null;
                this.tabWarningShown = false;
            }
        });
    }

    /**
     * Record a ping measurement. Call this with each ping update.
     *
     * @param {number} pingMs - Current ping in milliseconds
     */
    recordPing(pingMs) {
        if (!this.enabled || this.maxPing === null) return;

        this.pingMeasurements.push(pingMs);
        if (this.pingMeasurements.length > this.pingViolationWindow) {
            this.pingMeasurements.shift();
        }
    }

    /**
     * Check monitoring status. Call this periodically (e.g., each frame or second).
     *
     * @returns {Object} Result with status
     *   - exclude: boolean - Should participant be excluded?
     *   - warn: boolean - Should warning be shown?
     *   - reason: string|null - 'sustained_ping', 'tab_hidden', or null
     *   - message: string|null - Message to display
     */
    check() {
        const result = {
            exclude: false,
            warn: false,
            reason: null,
            message: null
        };

        if (!this.enabled || this.paused) {
            return result;
        }

        // Check tab visibility first (higher priority)
        const tabResult = this._checkTabVisibility();
        if (tabResult.exclude) {
            return tabResult;
        }
        if (tabResult.warn) {
            // Tab warning takes precedence over ping warning
            return tabResult;
        }

        // Check ping (only if tab is visible - hidden tabs have stale measurements)
        if (!this.tabHiddenAt) {
            const pingResult = this._checkPing();
            if (pingResult.exclude || pingResult.warn) {
                return pingResult;
            }
        }

        return result;
    }

    /**
     * Check tab visibility status.
     * @returns {Object} Result with exclude/warn/reason/message
     * @private
     */
    _checkTabVisibility() {
        const result = {
            exclude: false,
            warn: false,
            reason: null,
            message: null
        };

        if (!this.tabHiddenAt) {
            return result;
        }

        const hiddenDuration = Date.now() - this.tabHiddenAt;

        // Check exclusion threshold
        if (this.tabExcludeMs !== null && hiddenDuration >= this.tabExcludeMs) {
            result.exclude = true;
            result.reason = 'tab_hidden';
            result.message = this.messages.tab_exclude;
            monitorLog.warn(`Tab hidden exclusion: ${hiddenDuration}ms >= ${this.tabExcludeMs}ms threshold`);
            return result;
        }

        // Check warning threshold
        if (this.tabWarningMs !== null && hiddenDuration >= this.tabWarningMs && !this.tabWarningShown) {
            this.tabWarningShown = true;
            result.warn = true;
            result.reason = 'tab_hidden';
            result.message = this.messages.tab_warning;
            monitorLog.info(`Tab hidden warning: ${hiddenDuration}ms >= ${this.tabWarningMs}ms threshold`);
            return result;
        }

        return result;
    }

    /**
     * Check ping status for sustained violations.
     * @returns {Object} Result with exclude/warn/reason/message
     * @private
     */
    _checkPing() {
        const result = {
            exclude: false,
            warn: false,
            reason: null,
            message: null
        };

        if (this.maxPing === null || this.pingMeasurements.length === 0) {
            return result;
        }

        // Check for sustained violations (N consecutive measurements over threshold)
        if (this.pingMeasurements.length >= this.pingRequiredViolations) {
            const recent = this.pingMeasurements.slice(-this.pingRequiredViolations);
            const allOverThreshold = recent.every(ping => ping > this.maxPing);

            if (allOverThreshold) {
                result.exclude = true;
                result.reason = 'sustained_ping';
                result.message = this.messages.ping_exclude;
                const avgPing = Math.round(recent.reduce((a, b) => a + b, 0) / recent.length);
                monitorLog.warn(`Sustained ping exclusion: ${this.pingRequiredViolations} consecutive measurements > ${this.maxPing}ms (avg=${avgPing}ms)`);
                return result;
            }
        }

        // Check for single violation (warning only)
        const lastPing = this.pingMeasurements[this.pingMeasurements.length - 1];
        if (lastPing > this.maxPing && !this.pingWarningShown) {
            this.pingWarningShown = true;
            result.warn = true;
            result.reason = 'ping_spike';
            result.message = this.messages.ping_warning;
            monitorLog.info(`Ping warning: ${lastPing}ms > ${this.maxPing}ms threshold`);

            // Reset warning flag after a delay to allow re-warning
            setTimeout(() => {
                this.pingWarningShown = false;
            }, 5000);

            return result;
        }

        return result;
    }

    /**
     * Pause monitoring (e.g., during episode transitions).
     */
    pause() {
        this.paused = true;
        monitorLog.debug('Monitoring paused');
    }

    /**
     * Resume monitoring after pause.
     */
    resume() {
        this.paused = false;
        // Reset tab tracking to avoid false positives from pause duration
        this.tabHiddenAt = null;
        this.tabWarningShown = false;
        monitorLog.debug('Monitoring resumed');
    }

    /**
     * Reset all tracking state (e.g., on new episode).
     */
    reset() {
        this.pingMeasurements = [];
        this.pingWarningShown = false;
        this.tabHiddenAt = document.hidden ? Date.now() : null;
        this.tabWarningShown = false;
        monitorLog.debug('Monitor state reset');
    }
}
```

2. Add script tag to `interactive_gym/server/static/templates/index.html`:
   Find the script imports section (after ua-parser-js, before other module scripts) and verify the module is loaded.

   Actually, since this is an ES module imported by pyodide_multiplayer_game.js, no script tag needed - just the import.
  </action>
  <verify>
Check file exists and has correct structure:
```bash
cd /Users/chasemcd/Repositories/interactive-gym && \
cat interactive_gym/server/static/js/continuous_monitor.js | head -50 && \
grep -c "export class ContinuousMonitor" interactive_gym/server/static/js/continuous_monitor.js
```
  </verify>
  <done>
ContinuousMonitor class exists with:
- Rolling window ping tracking
- Sustained violation detection (3 of 5 consecutive)
- Tab visibility monitoring via visibilitychange event
- Warning before exclusion with configurable thresholds
- Pause/resume for episode transitions
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate ContinuousMonitor with game loop and add exclusion UI</name>
  <files>
    interactive_gym/server/static/js/pyodide_multiplayer_game.js
    interactive_gym/server/static/js/index.js
  </files>
  <action>
Integrate ContinuousMonitor into the multiplayer game loop and add mid-game exclusion handling:

1. In `pyodide_multiplayer_game.js`, add import at top (after existing imports, around line 16):
   ```javascript
   import { ContinuousMonitor } from './continuous_monitor.js';
   ```

2. In constructor (around line 520, after episode tracking), add monitor initialization:
   ```javascript
   // Continuous monitoring (Phase 16)
   this.continuousMonitor = null;  // Initialized in pyodide_game_ready when config available
   this.monitorCheckCounter = 0;   // Check every N frames to reduce overhead
   this.monitorCheckInterval = 30; // Check once per second at 30fps
   ```

3. In `socket.on('pyodide_game_ready', ...)` handler (around line 730, after storing TURN config), initialize monitor:
   ```javascript
   // Initialize continuous monitoring if configured (Phase 16)
   if (data.scene_metadata?.continuous_monitoring_enabled) {
       this.continuousMonitor = new ContinuousMonitor(data.scene_metadata);
       p2pLog.info('Continuous monitoring enabled');
   }
   ```

4. In `async step()` method (around line 1560, after building finalActions and before episode transition check), add monitoring check:
   ```javascript
   // Continuous monitoring check (Phase 16)
   // Check less frequently than every frame to reduce overhead
   if (this.continuousMonitor && !inEpisodeTransition) {
       this.monitorCheckCounter++;
       if (this.monitorCheckCounter >= this.monitorCheckInterval) {
           this.monitorCheckCounter = 0;
           const monitorResult = this.continuousMonitor.check();

           if (monitorResult.exclude) {
               await this._handleMidGameExclusion(monitorResult.reason, monitorResult.message);
               return null;  // Stop game loop
           }

           if (monitorResult.warn) {
               this._showMonitorWarning(monitorResult.message);
           }
       }
   }
   ```

5. Add ping recording hook. In `index.js`, modify the `socket.on('pong', ...)` handler (around line 61) to expose current ping:
   ```javascript
   // Expose for continuous monitoring
   window.currentPing = medianLatency;
   ```

   Then in pyodide_multiplayer_game.js step(), before the monitor check:
   ```javascript
   // Record ping for continuous monitoring
   if (this.continuousMonitor && window.currentPing !== undefined) {
       this.continuousMonitor.recordPing(window.currentPing);
   }
   ```

6. Add mid-game exclusion handler method (add after _logEpisodeEndMetrics method, around line 1700):
   ```javascript
   /**
    * Handle mid-game exclusion from continuous monitoring.
    * Stops game, shows message, notifies server.
    *
    * @param {string} reason - Exclusion reason ('sustained_ping', 'tab_hidden')
    * @param {string} message - Message to display to participant
    */
   async _handleMidGameExclusion(reason, message) {
       p2pLog.warn(`Mid-game exclusion: ${reason}`);

       // Stop game loop
       this.state = "done";
       this.episodeComplete = true;

       // Pause monitoring
       if (this.continuousMonitor) {
           this.continuousMonitor.pause();
       }

       // Show exclusion message
       this._showMidGameExclusionUI(message);

       // Notify server (which will notify partner in Phase 17)
       socket.emit('mid_game_exclusion', {
           game_id: this.gameId,
           player_id: this.myPlayerId,
           reason: reason,
           frame_number: this.frameNumber,
           timestamp: Date.now()
       });

       // Clean up WebRTC
       if (this.webrtcManager) {
           this.webrtcManager.close();
       }

       // Trigger end game redirect
       socket.emit('leave_game', { session_id: window.sessionId });
       socket.emit('end_game_request_redirect', {
           mid_game_exclusion: true,
           reason: reason
       });
   }

   /**
    * Show mid-game exclusion UI overlay.
    * @param {string} message - Exclusion message
    */
   _showMidGameExclusionUI(message) {
       // Create overlay if it doesn't exist
       let overlay = document.getElementById('monitorExclusionOverlay');
       if (!overlay) {
           overlay = document.createElement('div');
           overlay.id = 'monitorExclusionOverlay';
           overlay.style.cssText = `
               position: fixed;
               top: 0;
               left: 0;
               width: 100%;
               height: 100%;
               background: rgba(0, 0, 0, 0.85);
               display: flex;
               justify-content: center;
               align-items: center;
               z-index: 10000;
           `;
           document.body.appendChild(overlay);
       }

       overlay.innerHTML = `
           <div style="
               background: white;
               padding: 40px;
               border-radius: 8px;
               max-width: 500px;
               text-align: center;
           ">
               <h2 style="color: #c00; margin-bottom: 20px;">Game Ended</h2>
               <p style="font-size: 16px; margin-bottom: 20px;">${message}</p>
               <p style="color: #666; font-size: 14px;">You will be redirected shortly...</p>
           </div>
       `;
       overlay.style.display = 'flex';
   }

   /**
    * Show warning overlay (semi-transparent, doesn't block game).
    * @param {string} message - Warning message
    */
   _showMonitorWarning(message) {
       // Create warning banner if it doesn't exist
       let banner = document.getElementById('monitorWarningBanner');
       if (!banner) {
           banner = document.createElement('div');
           banner.id = 'monitorWarningBanner';
           banner.style.cssText = `
               position: fixed;
               top: 0;
               left: 0;
               width: 100%;
               padding: 15px;
               background: rgba(255, 200, 0, 0.95);
               color: #000;
               text-align: center;
               font-weight: bold;
               z-index: 9999;
               box-shadow: 0 2px 10px rgba(0,0,0,0.3);
           `;
           document.body.appendChild(banner);
       }

       banner.textContent = message;
       banner.style.display = 'block';

       // Auto-hide after 5 seconds
       setTimeout(() => {
           if (banner) {
               banner.style.display = 'none';
           }
       }, 5000);
   }
   ```

7. Add pause/resume calls during episode transitions. In episode sync methods:
   - In `_broadcastEpisodeEnd()` (around line 4050), add: `this.continuousMonitor?.pause();`
   - In `_checkEpisodeSyncAndReset()` after reset complete (around line 4110), add: `this.continuousMonitor?.resume();`
  </action>
  <verify>
Check syntax by loading the modified files in Node:
```bash
cd /Users/chasemcd/Repositories/interactive-gym && \
node --check interactive_gym/server/static/js/continuous_monitor.js 2>&1 || echo "ES modules need special handling" && \
grep -c "ContinuousMonitor" interactive_gym/server/static/js/pyodide_multiplayer_game.js && \
grep -c "_handleMidGameExclusion" interactive_gym/server/static/js/pyodide_multiplayer_game.js && \
grep "window.currentPing" interactive_gym/server/static/js/index.js
```
  </verify>
  <done>
- ContinuousMonitor imported and instantiated in game
- Ping recorded from existing Socket.IO pong handler
- Monitor checked every 30 frames (~1 second) in step()
- Mid-game exclusion stops game, shows overlay, notifies server
- Warning banner shown at top of screen (non-blocking)
- Monitor paused during episode transitions
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Python config test:**
   ```bash
   cd /Users/chasemcd/Repositories/interactive-gym && python -c "
   from interactive_gym.scenes.gym_scene import GymScene
   scene = GymScene()
   scene.continuous_monitoring(
       max_ping=200,
       ping_required_violations=3,
       tab_warning_ms=3000,
       tab_exclude_ms=10000
   )
   metadata = scene.get_complete_scene_metadata()
   assert metadata['continuous_monitoring_enabled'] == True
   assert metadata['continuous_max_ping'] == 200
   assert metadata['continuous_tab_exclude_ms'] == 10000
   print('Config serializes correctly to metadata')
   "
   ```

2. **JavaScript syntax check:**
   ```bash
   cd /Users/chasemcd/Repositories/interactive-gym && \
   npx acorn --module --silent interactive_gym/server/static/js/continuous_monitor.js && \
   echo "continuous_monitor.js syntax OK"
   ```

3. **Integration check:**
   ```bash
   grep -n "import.*ContinuousMonitor" interactive_gym/server/static/js/pyodide_multiplayer_game.js && \
   grep -n "continuousMonitor.check" interactive_gym/server/static/js/pyodide_multiplayer_game.js && \
   grep -n "_handleMidGameExclusion" interactive_gym/server/static/js/pyodide_multiplayer_game.js
   ```
</verification>

<success_criteria>
1. **MONITOR-01 (Continuous ping monitoring):** `continuousMonitor.recordPing()` called in step() with each ping update; `check()` evaluates ping every ~1 second
2. **MONITOR-02 (Sustained period exclusion):** `_checkPing()` requires 3 consecutive violations from 5-measurement window before exclusion
3. **MONITOR-03 (Tab switch detection):** `visibilitychange` event listener in ContinuousMonitor immediately detects tab hidden/visible
4. **MONITOR-04 (Configurable warning/exclusion):** Warning at 3s (configurable), exclusion at 10s (configurable), messages customizable via Python config
</success_criteria>

<output>
After completion, create `.planning/phases/16-continuous-monitoring/16-01-SUMMARY.md`
</output>
