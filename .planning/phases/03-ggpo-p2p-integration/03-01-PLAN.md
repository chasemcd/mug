---
phase: 03-ggpo-p2p-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/static/js/pyodide_multiplayer_game.js
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Both peers broadcast state hash (not just host)"
    - "State hash comparison works for desync detection"
    - "P2P input path is measurable via metrics"
    - "Connection health status triggers explicit fallback awareness"
  artifacts:
    - path: "interactive_gym/server/static/js/pyodide_multiplayer_game.js"
      provides: "Symmetric P2P state sync, P2P metrics, fallback monitoring"
      contains: "broadcastSymmetricStateSync"
  key_links:
    - from: "step() method"
      to: "broadcastSymmetricStateSync()"
      via: "periodic call based on frame interval"
      pattern: "broadcastSymmetricStateSync"
    - from: "_handleInputPacket()"
      to: "p2pMetrics"
      via: "increment counter on P2P input receipt"
      pattern: "p2pMetrics"
---

<objective>
Make GGPO P2P integration symmetric and observable.

Purpose: Remove host-only logic from P2P state sync, add metrics to verify P2P path is working, and make fallback state explicit rather than implicit.

Output: Modified pyodide_multiplayer_game.js with symmetric state sync, P2P metrics tracking, and fallback monitoring.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-ggpo-p2p-integration/03-RESEARCH.md

Key findings from research:
- P2P input sending/receiving already works (Phase 2)
- Dual-path (SocketIO + P2P) already provides implicit fallback
- `isHost` flag ONLY used for P2P state sync broadcast (line 1212)
- `storeRemoteInput()` deduplicates inputs from both paths (line 1923)
- GGPO rollback is already symmetric (both peers rollback independently)

Files to modify:
@interactive_gym/server/static/js/pyodide_multiplayer_game.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace host-only state sync with symmetric broadcast</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
1. Rename `broadcastP2PStateSync()` to `broadcastSymmetricStateSync()` (around line 1441)

2. Modify the method to:
   - Remove "host only" comment
   - Add sender_id to distinguish which peer sent the hash
   - Keep using SocketIO for now (server relays to other peer) - this is the existing pattern

3. Modify the call site in `step()` (around line 1212) to:
   - Remove the `this.isHost` check
   - Keep the `!this.serverAuthoritative` check (only in P2P mode)
   - Both peers now broadcast their state hash at the sync interval

4. Modify the `p2p_state_sync` handler (around line 517) to:
   - Compare received hash against our hash at the same frame
   - Log match/mismatch for BOTH peers (not just "non-host")
   - Keep existing desync debugging output

This makes state verification symmetric: both peers broadcast their hash, both compare received hashes, neither has authority.
  </action>
  <verify>
    - Search for `isHost` in the file - should only appear in initialization (line 443) and property declaration (line 415), NOT in step() or broadcastSymmetricStateSync()
    - Search for `broadcastSymmetricStateSync` - should exist and be called from step() without isHost check
  </verify>
  <done>
    - `broadcastP2PStateSync` renamed to `broadcastSymmetricStateSync`
    - `isHost` check removed from step() for P2P sync
    - Both peers broadcast state hash at sync interval
    - `p2p_state_sync` handler processes hashes from either peer
  </done>
</task>

<task type="auto">
  <name>Task 2: Add P2P metrics tracking</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
1. Add p2pMetrics object to constructor (around line 420, near other diagnostics):
```javascript
this.p2pMetrics = {
    inputsReceivedViaP2P: 0,
    inputsReceivedViaSocketIO: 0,
    inputsSentViaP2P: 0,
    inputsSentViaSocketIO: 0,
    p2pFallbackTriggered: false,
    p2pFallbackFrame: null
};
```

2. In `_handleInputPacket()` (around line 2586), increment `p2pMetrics.inputsReceivedViaP2P` for each input processed

3. In `socket.on('pyodide_other_player_action')` handler (around line 483), increment `p2pMetrics.inputsReceivedViaSocketIO`

4. In `step()` where inputs are sent (around line 1107-1119):
   - Increment `p2pMetrics.inputsSentViaP2P` when P2P path used
   - Increment `p2pMetrics.inputsSentViaSocketIO` when SocketIO path used (always, since dual-path)

5. Add metrics to the episode summary log (around line 1253):
   - Add P2P receive ratio: `P2P: ${this.p2pMetrics.inputsReceivedViaP2P}/${this.p2pMetrics.inputsReceivedViaP2P + this.p2pMetrics.inputsReceivedViaSocketIO}`

This provides visibility into whether P2P path is actually being used.
  </action>
  <verify>
    - Search for `p2pMetrics` - should appear in constructor, _handleInputPacket, socket.on handler, step(), and episode log
    - Verify console.log at episode complete includes P2P metrics
  </verify>
  <done>
    - p2pMetrics object tracks P2P vs SocketIO input counts
    - Episode summary logs P2P usage ratio
    - Can verify P2P path is working by checking console output
  </done>
</task>

<task type="auto">
  <name>Task 3: Add explicit fallback monitoring</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
1. Add `_checkP2PHealth()` method (after `_stopPingInterval`, around line 2520):
```javascript
/**
 * Check P2P connection health and trigger fallback awareness if degraded.
 * Note: Actual fallback is implicit (SocketIO always active), this just tracks state.
 */
_checkP2PHealth() {
    if (!this.connectionHealth || !this.p2pConnected) {
        return;
    }

    const health = this.connectionHealth.getHealthStatus();

    // Criteria for degraded P2P (fallback recommended)
    const isDegraded =
        health.status === 'critical' ||
        (health.latency && health.latency > 300);

    if (isDegraded && !this.p2pMetrics.p2pFallbackTriggered) {
        this.p2pMetrics.p2pFallbackTriggered = true;
        this.p2pMetrics.p2pFallbackFrame = this.frameNumber;
        console.warn(
            `[P2P Fallback] Connection degraded at frame ${this.frameNumber}. ` +
            `Latency: ${health.latency}ms, Status: ${health.status}. ` +
            `SocketIO continues as fallback.`
        );
    }
}
```

2. In the existing `onDataChannelClose` and `onConnectionFailed` callbacks (around line 2492-2498), add:
```javascript
if (!this.p2pMetrics.p2pFallbackTriggered) {
    this.p2pMetrics.p2pFallbackTriggered = true;
    this.p2pMetrics.p2pFallbackFrame = this.frameNumber;
    console.warn(`[P2P Fallback] DataChannel closed/failed at frame ${this.frameNumber}`);
}
```

3. Call `_checkP2PHealth()` periodically in `step()` (after the P2P sync broadcast, around line 1216):
```javascript
// Check P2P health for fallback awareness
this._checkP2PHealth();
```

4. Include fallback status in episode summary (update the log added in Task 2):
   - If p2pFallbackTriggered: `, Fallback at frame ${this.p2pMetrics.p2pFallbackFrame}`

This makes the fallback state observable in logs.
  </action>
  <verify>
    - Search for `_checkP2PHealth` - should be defined and called from step()
    - Search for `p2pFallbackTriggered` - should be set in _checkP2PHealth, onDataChannelClose, onConnectionFailed
  </verify>
  <done>
    - _checkP2PHealth() monitors connection health
    - Fallback state is tracked and logged when P2P degrades
    - Episode summary shows if/when fallback occurred
    - SocketIO continues working as implicit fallback (no change to existing behavior)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Code structure verification:
   - `grep -n "isHost" pyodide_multiplayer_game.js` shows only initialization lines (415, 443, 448), NOT in step()
   - `grep -n "broadcastSymmetricStateSync" pyodide_multiplayer_game.js` shows method definition and call
   - `grep -n "p2pMetrics" pyodide_multiplayer_game.js` shows multiple usages

2. Functional verification (manual):
   - Start two browser clients
   - Watch console for `[P2P Sync]` logs from BOTH peers (not just host)
   - Watch for `[P2P]` input receipt logs
   - At episode end, verify console shows P2P metrics (inputsReceivedViaP2P > 0)

3. GGPO behavior unchanged:
   - Rollback still triggers on late inputs (watch for `[GGPO] Rolling back` logs)
   - State snapshots still saved (watch for snapshot logs)
   - Input buffer deduplication still works (no duplicate input warnings)
</verification>

<success_criteria>
1. Both peers broadcast state hashes (symmetric, not host-only)
2. P2P metrics show inputs received via DataChannel (inputsReceivedViaP2P > 0)
3. Fallback monitoring tracks if/when P2P degraded
4. No regression in GGPO rollback behavior
5. Episode summary includes P2P usage statistics
</success_criteria>

<output>
After completion, create `.planning/phases/03-ggpo-p2p-integration/03-01-SUMMARY.md`

Include:
- Files modified
- Metrics added for P2P observability
- How to verify P2P is working (console output patterns)
- Any issues encountered
</output>
