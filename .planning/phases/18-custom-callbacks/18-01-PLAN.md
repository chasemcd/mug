---
phase: 18-custom-callbacks
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/scenes/gym_scene.py
  - interactive_gym/server/app.py
  - interactive_gym/server/static/js/index.js
  - interactive_gym/server/static/js/continuous_monitor.js
  - interactive_gym/server/static/js/pyodide_multiplayer_game.js
autonomous: true

must_haves:
  truths:
    - "Researcher can define custom entry exclusion logic via Python callback"
    - "Researcher can define custom continuous exclusion logic via Python callback"
    - "Callbacks receive full participant context (ping, browser, device, focus state)"
    - "Callbacks return exclusion decision with optional custom message"
  artifacts:
    - path: "interactive_gym/scenes/gym_scene.py"
      provides: "entry_callback and continuous_callback configuration"
      contains: "def exclusion_callbacks"
    - path: "interactive_gym/server/app.py"
      provides: "Socket handlers for callback execution"
      contains: "execute_entry_callback"
  key_links:
    - from: "interactive_gym/server/static/js/index.js"
      to: "interactive_gym/server/app.py"
      via: "Socket.IO execute_entry_callback event"
      pattern: "socket\\.emit.*execute_entry_callback"
    - from: "interactive_gym/server/static/js/continuous_monitor.js"
      to: "interactive_gym/server/app.py"
      via: "Socket.IO execute_continuous_callback event"
      pattern: "socket\\.emit.*execute_continuous_callback"
---

<objective>
Implement custom exclusion callbacks allowing researchers to define arbitrary exclusion logic via Python callback functions that receive full participant context and return exclusion decisions with optional messages.

Purpose: Enable researchers to implement experiment-specific exclusion criteria beyond the built-in rules (device type, browser, ping thresholds), such as excluding based on prior participation, custom attention checks, or complex multi-factor decisions.

Output: Working callback system where researchers define Python functions that execute on the server, receiving participant context from the client.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-entry-screening-rules/15-01-SUMMARY.md
@.planning/phases/16-continuous-monitoring/16-01-SUMMARY.md
@.planning/phases/17-multiplayer-exclusion/17-01-SUMMARY.md
@interactive_gym/scenes/gym_scene.py
@interactive_gym/server/app.py
@interactive_gym/server/static/js/index.js
@interactive_gym/server/static/js/continuous_monitor.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add callback configuration to GymScene</name>
  <files>interactive_gym/scenes/gym_scene.py</files>
  <action>
Add new method `exclusion_callbacks()` to GymScene with fluent builder pattern:

1. Add new instance attributes in `__init__`:
   ```python
   # Custom exclusion callbacks (Phase 18)
   self.entry_exclusion_callback: Callable | None = None  # Called at entry
   self.continuous_exclusion_callback: Callable | None = None  # Called during gameplay
   self.continuous_callback_interval_frames: int = 30  # Frames between callback checks (~1s at 30fps)
   ```

2. Add new method `exclusion_callbacks()`:
   ```python
   def exclusion_callbacks(
       self,
       entry_callback: Callable = NotProvided,
       continuous_callback: Callable = NotProvided,
       continuous_callback_interval_frames: int = NotProvided,
   ):
       """Configure custom exclusion callbacks for the GymScene.

       Callbacks allow researchers to implement arbitrary exclusion logic beyond
       the built-in rules. Callbacks execute on the server and receive participant
       context from the client.

       Entry callback signature:
           def my_entry_callback(context: dict) -> dict:
               # context contains: ping, browser_name, browser_version, device_type,
               #                   os_name, subject_id, scene_id
               # Return: {"exclude": bool, "message": str | None}
               return {"exclude": False, "message": None}

       Continuous callback signature:
           def my_continuous_callback(context: dict) -> dict:
               # context contains: ping, is_tab_hidden, tab_hidden_duration_ms,
               #                   frame_number, episode_number, subject_id, scene_id
               # Return: {"exclude": bool, "warn": bool, "message": str | None}
               return {"exclude": False, "warn": False, "message": None}

       :param entry_callback: Function called at entry screening, defaults to NotProvided
       :type entry_callback: Callable, optional
       :param continuous_callback: Function called periodically during gameplay, defaults to NotProvided
       :type continuous_callback: Callable, optional
       :param continuous_callback_interval_frames: Frames between continuous callback checks (default 30 ~1s), defaults to NotProvided
       :type continuous_callback_interval_frames: int, optional
       :return: The GymScene instance (self)
       :rtype: GymScene
       """
   ```

3. In the method body, validate and store callbacks:
   - Validate callback is callable if provided
   - Store on self.entry_exclusion_callback / self.continuous_exclusion_callback
   - Validate continuous_callback_interval_frames is positive integer
   - Return self for chaining

4. Update `get_complete_scene_metadata()` to indicate callbacks are configured (add boolean flags):
   - Add to metadata: `has_entry_callback: bool`
   - Add to metadata: `has_continuous_callback: bool`
   - Add to metadata: `continuous_callback_interval_frames: int`
   - Do NOT serialize the actual callback functions (they run server-side only)

Note: The actual callback functions stay on the server. Only boolean flags indicating their presence go to the client.
  </action>
  <verify>
Run `python -c "from interactive_gym.scenes.gym_scene import GymScene; s = GymScene(); s.exclusion_callbacks(entry_callback=lambda ctx: {'exclude': False}); print('entry:', s.entry_exclusion_callback); print('meta has_entry:', s.get_complete_scene_metadata().get('has_entry_callback'))"` and confirm callback is stored and metadata flag is True.
  </verify>
  <done>
GymScene has exclusion_callbacks() method, stores callbacks, and metadata includes has_entry_callback/has_continuous_callback boolean flags.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add server-side callback execution handlers</name>
  <files>interactive_gym/server/app.py</files>
  <action>
Add Socket.IO handlers to execute callbacks on the server:

1. Add `@socketio.on('execute_entry_callback')` handler:
   ```python
   @socketio.on('execute_entry_callback')
   def handle_execute_entry_callback(data):
       """Execute researcher-defined entry screening callback.

       Receives participant context from client, executes callback if configured,
       returns exclusion decision.
       """
       session_id = data.get('session_id')
       scene_id = data.get('scene_id')
       context = data.get('context', {})

       # Get the current scene configuration
       # The scene/experiment must be accessible via global state or session
       scene = get_current_scene(session_id, scene_id)  # You'll need to implement this lookup

       if scene is None or scene.entry_exclusion_callback is None:
           # No callback configured, pass through
           emit('entry_callback_result', {'exclude': False, 'message': None})
           return

       try:
           # Add subject_id and scene_id to context
           context['subject_id'] = session_id
           context['scene_id'] = scene_id

           # Execute the callback
           result = scene.entry_exclusion_callback(context)

           # Validate result format
           exclude = result.get('exclude', False)
           message = result.get('message', None)

           emit('entry_callback_result', {'exclude': exclude, 'message': message})
       except Exception as e:
           print(f"[Callback Error] Entry callback failed: {e}")
           # On error, allow entry (fail open) but log
           emit('entry_callback_result', {'exclude': False, 'message': None, 'error': str(e)})
   ```

2. Add `@socketio.on('execute_continuous_callback')` handler:
   ```python
   @socketio.on('execute_continuous_callback')
   def handle_execute_continuous_callback(data):
       """Execute researcher-defined continuous monitoring callback.

       Receives participant context from client during gameplay, executes callback,
       returns exclusion/warning decision.
       """
       session_id = data.get('session_id')
       scene_id = data.get('scene_id')
       context = data.get('context', {})

       scene = get_current_scene(session_id, scene_id)

       if scene is None or scene.continuous_exclusion_callback is None:
           emit('continuous_callback_result', {'exclude': False, 'warn': False, 'message': None})
           return

       try:
           context['subject_id'] = session_id
           context['scene_id'] = scene_id

           result = scene.continuous_exclusion_callback(context)

           exclude = result.get('exclude', False)
           warn = result.get('warn', False)
           message = result.get('message', None)

           emit('continuous_callback_result', {'exclude': exclude, 'warn': warn, 'message': message})
       except Exception as e:
           print(f"[Callback Error] Continuous callback failed: {e}")
           emit('continuous_callback_result', {'exclude': False, 'warn': False, 'message': None, 'error': str(e)})
   ```

3. Implement `get_current_scene()` helper function:
   - Look up the current scene from EXPERIMENT or session state
   - The scene is available via `EXPERIMENT.current_scene(session_id)` or similar
   - Check existing code patterns in app.py for how scenes are accessed
   - May need to access via `EXPERIMENT.scenes[scene_id]` based on existing patterns

Note: Check how other handlers in app.py access the experiment/scene configuration and follow the same pattern. The EXPERIMENT global or similar should have the scene with its callback.
  </action>
  <verify>
Search app.py for existing scene access patterns: `grep -n "EXPERIMENT" app.py | head -20` and confirm handlers follow existing patterns for accessing scene configuration.
  </verify>
  <done>
Server has execute_entry_callback and execute_continuous_callback handlers that look up the scene, execute the researcher's callback with context, and emit results back to client.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate entry callback in client-side screening</name>
  <files>interactive_gym/server/static/js/index.js</files>
  <action>
Modify entry screening to call server-side callback when configured:

1. Update `runEntryScreening()` to be async and check for callback:
   ```javascript
   async function runEntryScreening(sceneMetadata) {
       // Run built-in checks first (existing code unchanged)
       // ... existing device/browser checks ...

       // If built-in checks pass and entry callback is configured, call server
       if (sceneMetadata.has_entry_callback) {
           const callbackResult = await executeEntryCallback(sceneMetadata);
           if (callbackResult.exclude) {
               return {
                   passed: false,
                   failedRule: 'custom_callback',
                   message: callbackResult.message || 'You do not meet the requirements for this study.'
               };
           }
       }

       // All checks passed
       return { passed: true, failedRule: null, message: null };
   }
   ```

2. Add new `executeEntryCallback()` function:
   ```javascript
   function executeEntryCallback(sceneMetadata) {
       return new Promise((resolve) => {
           // Gather participant context
           const parser = new UAParser();
           const result = parser.getResult();

           const context = {
               ping: curLatency || 0,
               browser_name: result.browser.name || 'Unknown',
               browser_version: result.browser.version || 'Unknown',
               device_type: result.device.type || 'desktop',
               os_name: result.os.name || 'Unknown',
               os_version: result.os.version || 'Unknown'
           };

           // Set up one-time listener for response
           socket.once('entry_callback_result', (data) => {
               resolve({
                   exclude: data.exclude || false,
                   message: data.message || null
               });
           });

           // Send to server
           socket.emit('execute_entry_callback', {
               session_id: window.sessionId,
               scene_id: sceneMetadata.scene_id,
               context: context
           });

           // Timeout after 5 seconds (fail open)
           setTimeout(() => {
               resolve({ exclude: false, message: null });
           }, 5000);
       });
   }
   ```

3. Update `startGymScene()` to handle async screening:
   ```javascript
   async function startGymScene(data) {
       enableStartRefreshInterval();

       // Run entry screening checks (Phase 15 + Phase 18 callbacks)
       const screeningResult = await runEntryScreening(data);
       // ... rest of existing code unchanged ...
   }
   ```

4. Update the call site in `activateScene()` if needed to handle async.

Note: Preserve all existing entry screening logic (device, browser, ping). The callback runs AFTER built-in checks pass, allowing researchers to add additional criteria.
  </action>
  <verify>
Verify the async flow compiles: Check browser console for syntax errors when loading the page. The callback should only trigger when `has_entry_callback: true` in scene metadata.
  </verify>
  <done>
Entry screening integrates with server-side callback. When has_entry_callback is true, client sends context to server, awaits result, and excludes if callback returns exclude: true.
  </done>
</task>

<task type="auto">
  <name>Task 4: Integrate continuous callback in game loop</name>
  <files>
    interactive_gym/server/static/js/continuous_monitor.js
    interactive_gym/server/static/js/pyodide_multiplayer_game.js
  </files>
  <action>
Integrate continuous callback execution with the existing ContinuousMonitor:

1. In `continuous_monitor.js`, add callback support to ContinuousMonitor:

   a. Add to constructor:
   ```javascript
   // Custom callback config
   this.hasCallback = config.has_continuous_callback ?? false;
   this.callbackIntervalFrames = config.continuous_callback_interval_frames ?? 30;
   this.framesSinceCallback = 0;
   this.callbackPending = false;  // Prevent overlapping calls

   // Callback result (set by game when server responds)
   this.callbackResult = null;
   ```

   b. Add new method `shouldExecuteCallback()`:
   ```javascript
   /**
    * Check if it's time to execute the continuous callback.
    * Call this each frame. Returns true when callback should be executed.
    */
   shouldExecuteCallback() {
       if (!this.enabled || this.paused || !this.hasCallback || this.callbackPending) {
           return false;
       }

       this.framesSinceCallback++;
       if (this.framesSinceCallback >= this.callbackIntervalFrames) {
           this.framesSinceCallback = 0;
           return true;
       }
       return false;
   }
   ```

   c. Add method `setCallbackPending(pending)`:
   ```javascript
   setCallbackPending(pending) {
       this.callbackPending = pending;
   }
   ```

   d. Add method `setCallbackResult(result)`:
   ```javascript
   /**
    * Set the result from server callback execution.
    * @param {Object} result - {exclude: bool, warn: bool, message: string|null}
    */
   setCallbackResult(result) {
       this.callbackResult = result;
   }
   ```

   e. Update `check()` method to also check callback result:
   ```javascript
   // At the start of check(), add:
   // Check callback result if present
   if (this.callbackResult) {
       const cbResult = this.callbackResult;
       this.callbackResult = null;  // Clear after reading

       if (cbResult.exclude) {
           return {
               exclude: true,
               warn: false,
               reason: 'custom_callback',
               message: cbResult.message || 'You have been excluded from this study.'
           };
       }
       if (cbResult.warn) {
           return {
               exclude: false,
               warn: true,
               reason: 'custom_callback_warning',
               message: cbResult.message || 'Please follow the study instructions.'
           };
       }
   }
   // ... rest of existing check() code ...
   ```

2. In `pyodide_multiplayer_game.js`, add callback execution:

   a. Add socket listener for callback result (in constructor or initialization):
   ```javascript
   socket.on('continuous_callback_result', (data) => {
       if (this.continuousMonitor) {
           this.continuousMonitor.setCallbackPending(false);
           this.continuousMonitor.setCallbackResult(data);
       }
   });
   ```

   b. In the game loop where continuous monitoring happens (around line 1721), add callback execution:
   ```javascript
   // After the existing continuousMonitor.recordPing() and check():

   // Check if we should execute continuous callback
   if (this.continuousMonitor.shouldExecuteCallback()) {
       this._executeContinuousCallback();
   }
   ```

   c. Add new method `_executeContinuousCallback()`:
   ```javascript
   _executeContinuousCallback() {
       if (!this.continuousMonitor) return;

       this.continuousMonitor.setCallbackPending(true);

       const context = {
           ping: window.currentPing || 0,
           is_tab_hidden: document.hidden,
           tab_hidden_duration_ms: this.continuousMonitor.tabHiddenAt
               ? Date.now() - this.continuousMonitor.tabHiddenAt
               : 0,
           frame_number: this.frameNumber,
           episode_number: this.currentEpisode || 0
       };

       socket.emit('execute_continuous_callback', {
           session_id: window.sessionId,
           scene_id: this.sceneId,
           context: context
       });
   }
   ```

   d. Update `_handleMidGameExclusion` to handle 'custom_callback' reason if not already generic enough.

Note: The callback is async - we send the request and continue the game loop. When the response arrives, it's stored and checked on the next monitor.check() call. This avoids blocking the game loop.
  </action>
  <verify>
Check that ContinuousMonitor has the new callback methods by searching for them: `grep -n "shouldExecuteCallback\|setCallbackResult" continuous_monitor.js`
  </verify>
  <done>
Continuous monitoring integrates with server-side callback. When has_continuous_callback is true, client periodically sends context to server, receives exclusion/warning decisions, and handles them through existing exclusion flow.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Configuration Test**: Create a GymScene with both callbacks and verify metadata:
   ```python
   from interactive_gym.scenes.gym_scene import GymScene

   def my_entry_cb(ctx):
       print(f"Entry callback called with: {ctx}")
       return {"exclude": False}

   def my_continuous_cb(ctx):
       if ctx.get('ping', 0) > 500:
           return {"exclude": True, "message": "Custom: Ping too high!"}
       return {"exclude": False}

   scene = GymScene()
   scene.exclusion_callbacks(
       entry_callback=my_entry_cb,
       continuous_callback=my_continuous_cb,
       continuous_callback_interval_frames=60
   )

   meta = scene.get_complete_scene_metadata()
   assert meta.get('has_entry_callback') == True
   assert meta.get('has_continuous_callback') == True
   assert meta.get('continuous_callback_interval_frames') == 60
   ```

2. **Server Handler Test**: Verify socket handlers exist:
   ```bash
   grep -n "execute_entry_callback\|execute_continuous_callback" interactive_gym/server/app.py
   ```

3. **Client Integration Test**: Verify JavaScript changes:
   ```bash
   grep -n "executeEntryCallback\|execute_continuous_callback" interactive_gym/server/static/js/index.js
   grep -n "shouldExecuteCallback\|setCallbackResult" interactive_gym/server/static/js/continuous_monitor.js
   ```
</verification>

<success_criteria>
- [ ] EXT-01: Researcher can define custom exclusion rules via Python callback functions
  - `GymScene.exclusion_callbacks(entry_callback=fn, continuous_callback=fn)` works
  - Callbacks stored on scene instance

- [ ] EXT-02: Callbacks receive full participant context
  - Entry: ping, browser_name, browser_version, device_type, os_name, subject_id, scene_id
  - Continuous: ping, is_tab_hidden, tab_hidden_duration_ms, frame_number, episode_number, subject_id, scene_id

- [ ] EXT-03: Callbacks return exclusion decision with optional message
  - Entry returns: {"exclude": bool, "message": str|None}
  - Continuous returns: {"exclude": bool, "warn": bool, "message": str|None}
  - Custom messages displayed in exclusion UI
</success_criteria>

<output>
After completion, create `.planning/phases/18-custom-callbacks/18-01-SUMMARY.md`
</output>
