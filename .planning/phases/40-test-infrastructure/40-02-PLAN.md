---
phase: 40-test-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["40-01"]
files_modified:
  - tests/fixtures/__init__.py
  - tests/fixtures/game_helpers.py
  - tests/e2e/test_multiplayer_basic.py
autonomous: true

must_haves:
  truths:
    - "Two players can progress from start scene to waitroom"
    - "Two players can complete matchmaking and enter gameplay"
    - "Test can detect game completion state"
    - "Test captures episode data emission"
  artifacts:
    - path: "tests/fixtures/game_helpers.py"
      provides: "Game automation utilities"
      exports: ["wait_for_socket_connected", "wait_for_game_start", "wait_for_episode_complete", "click_continue"]
    - path: "tests/e2e/test_multiplayer_basic.py"
      provides: "Multiplayer automation test"
      min_lines: 50
  key_links:
    - from: "tests/fixtures/game_helpers.py"
      to: "window.socket"
      via: "page.wait_for_function"
      pattern: "window\\.socket.*connected"
    - from: "tests/fixtures/game_helpers.py"
      to: "window.pyodideMultiplayerGame"
      via: "page.wait_for_function"
      pattern: "pyodideMultiplayerGame"
    - from: "tests/e2e/test_multiplayer_basic.py"
      to: "tests/fixtures/game_helpers.py"
      via: "import"
      pattern: "from tests\\.fixtures\\.game_helpers import"
---

<objective>
Create game automation helpers and a multiplayer test that validates two players can connect, match, and complete a game session.

Purpose: Prove Playwright can fully automate the multiplayer game flow from start to episode completion, capturing game state for validation.

Output: Working multiplayer automation test that Phase 41-43 tests will extend with network conditions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/40-test-infrastructure/40-RESEARCH.md
@.planning/phases/40-test-infrastructure/40-01-SUMMARY.md

Key codebase files:
@interactive_gym/server/static/js/index.js (socket, waitroom flow)
@interactive_gym/server/static/js/pyodide_multiplayer_game.js (game state, completion)
@interactive_gym/server/static/templates/index.html (UI elements)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create game automation helper functions</name>
  <files>tests/fixtures/__init__.py, tests/fixtures/game_helpers.py</files>
  <action>
Create `tests/fixtures/__init__.py` (empty) and `tests/fixtures/game_helpers.py` with helpers:

```python
"""
Game automation helpers for Playwright E2E tests.

These helpers encapsulate waiting for game states and UI interactions,
making tests cleaner and more maintainable.
"""
from playwright.sync_api import Page

def wait_for_socket_connected(page: Page, timeout: int = 10000) -> None:
    """Wait for SocketIO connection to be established."""
    page.wait_for_function(
        "() => window.socket && window.socket.connected",
        timeout=timeout
    )

def wait_for_game_canvas(page: Page, timeout: int = 60000) -> None:
    """Wait for Phaser game canvas to become visible (game started)."""
    page.wait_for_selector("#phaser-game canvas", state="visible", timeout=timeout)

def wait_for_game_object(page: Page, timeout: int = 30000) -> None:
    """Wait for pyodideMultiplayerGame object to be initialized."""
    page.wait_for_function(
        "() => window.pyodideMultiplayerGame !== undefined",
        timeout=timeout
    )

def wait_for_episode_complete(page: Page, episode_num: int = 1, timeout: int = 180000) -> None:
    """
    Wait for episode completion.

    The game emits 'emit_episode_data' when episode completes.
    We check num_episodes counter on the game object.
    """
    page.wait_for_function(
        f"() => window.pyodideMultiplayerGame && window.pyodideMultiplayerGame.num_episodes >= {episode_num}",
        timeout=timeout
    )

def get_game_state(page: Page) -> dict:
    """Get current game state for assertions."""
    return page.evaluate("""() => {
        const game = window.pyodideMultiplayerGame;
        if (!game) return null;
        return {
            state: game.state,
            frameNumber: game.frameNumber,
            numEpisodes: game.num_episodes,
            maxEpisodes: game.max_episodes,
            gameId: game.gameId,
            playerId: game.playerId
        };
    }""")

def click_continue(page: Page, timeout: int = 5000) -> None:
    """Click the Continue/Advance button to progress through scenes."""
    # Try advanceButton first (main continue button)
    advance_btn = page.locator("#advanceButton")
    if advance_btn.is_visible(timeout=timeout):
        advance_btn.click()
        return

    # Try startButton as fallback (for initial start)
    start_btn = page.locator("#startButton")
    if start_btn.is_visible(timeout=timeout):
        start_btn.click()
        return

    raise Exception("No continue button found")

def wait_for_waitroom(page: Page, timeout: int = 10000) -> None:
    """Wait for waitroom text to appear (matchmaking started)."""
    page.wait_for_selector("#waitroomText", state="visible", timeout=timeout)

def wait_for_waitroom_matched(page: Page, timeout: int = 60000) -> None:
    """Wait for waitroom to complete (matched with partner)."""
    # Waitroom disappears when matched, or game canvas appears
    page.wait_for_function(
        """() => {
            const waitroom = document.getElementById('waitroomText');
            const canvas = document.querySelector('#phaser-game canvas');
            return (waitroom && waitroom.style.display === 'none') ||
                   (canvas && canvas.offsetParent !== null);
        }""",
        timeout=timeout
    )
```

These helpers abstract away the specific selectors and JavaScript calls,
making the actual test code cleaner and more readable.
  </action>
  <verify>
Run: `python -c "from tests.fixtures.game_helpers import *; print('OK')"`
  </verify>
  <done>
- game_helpers.py exports all wait and interaction functions
- Functions use correct selectors matching index.html and game JS
  </done>
</task>

<task type="auto">
  <name>Task 2: Create multiplayer connection and gameplay test</name>
  <files>tests/e2e/test_multiplayer_basic.py</files>
  <action>
Create `tests/e2e/test_multiplayer_basic.py`:

```python
"""
Basic multiplayer test - two players connect and complete one episode.

This test validates INFRA-01 and INFRA-02:
- Two browser contexts connect to same game session
- Both progress through matchmaking to gameplay
- Game completion state can be captured

The game runs with idle inputs (no keystrokes) - this is valid because:
1. Overcooked has a time limit, so episodes end naturally
2. We're testing infrastructure, not gameplay strategy
"""
import pytest
from tests.fixtures.game_helpers import (
    wait_for_socket_connected,
    wait_for_game_canvas,
    wait_for_game_object,
    wait_for_episode_complete,
    get_game_state,
    click_continue,
    wait_for_waitroom,
)


@pytest.mark.timeout(300)  # 5 minutes max for full flow
def test_two_players_connect_and_complete_episode(flask_server, player_contexts):
    """
    Test that two players can:
    1. Connect to the game server
    2. Progress through start scene
    3. Enter waitroom and get matched
    4. Start gameplay
    5. Complete at least one episode (via timeout, players are idle)
    """
    page1, page2 = player_contexts
    base_url = flask_server["url"]

    # Step 1: Both players navigate to game
    page1.goto(base_url)
    page2.goto(base_url)

    # Step 2: Wait for socket connections
    wait_for_socket_connected(page1)
    wait_for_socket_connected(page2)

    # Step 3: Both players click Continue on start scene
    # The start scene has instructions and a Continue button
    click_continue(page1)
    click_continue(page2)

    # Step 4: Wait for waitroom (matchmaking)
    wait_for_waitroom(page1)
    wait_for_waitroom(page2)

    # Step 5: Wait for game to start (matchmaking complete)
    # This may take a while as P2P connection establishes
    wait_for_game_canvas(page1, timeout=90000)
    wait_for_game_canvas(page2, timeout=90000)

    # Step 6: Verify game objects initialized
    wait_for_game_object(page1)
    wait_for_game_object(page2)

    # Get initial state
    state1 = get_game_state(page1)
    state2 = get_game_state(page2)

    # Verify both are in same game
    assert state1["gameId"] == state2["gameId"], "Players should be in same game"
    assert state1["playerId"] != state2["playerId"], "Players should have different IDs"

    # Step 7: Wait for first episode to complete
    # Players are idle, so episode completes via time limit
    # Overcooked cramped_room has short episodes (~60s)
    wait_for_episode_complete(page1, episode_num=1, timeout=180000)
    wait_for_episode_complete(page2, episode_num=1, timeout=180000)

    # Step 8: Verify completion state
    final_state1 = get_game_state(page1)
    final_state2 = get_game_state(page2)

    assert final_state1["numEpisodes"] >= 1, "Player 1 should have completed 1+ episodes"
    assert final_state2["numEpisodes"] >= 1, "Player 2 should have completed 1+ episodes"

    # Log success metrics
    print(f"Game completed: gameId={final_state1['gameId']}")
    print(f"Player 1: episodes={final_state1['numEpisodes']}, frames={final_state1['frameNumber']}")
    print(f"Player 2: episodes={final_state2['numEpisodes']}, frames={final_state2['frameNumber']}")


@pytest.mark.timeout(120)
def test_matchmaking_pairs_two_players(flask_server, player_contexts):
    """
    Test that matchmaking successfully pairs two players.

    This is a lighter test that just verifies matchmaking works
    without waiting for full episode completion.
    """
    page1, page2 = player_contexts
    base_url = flask_server["url"]

    # Navigate and connect
    page1.goto(base_url)
    page2.goto(base_url)
    wait_for_socket_connected(page1)
    wait_for_socket_connected(page2)

    # Progress to waitroom
    click_continue(page1)
    click_continue(page2)
    wait_for_waitroom(page1)
    wait_for_waitroom(page2)

    # Wait for game canvas (proves matchmaking succeeded)
    wait_for_game_canvas(page1, timeout=90000)
    wait_for_game_canvas(page2, timeout=90000)

    # Verify game objects exist and have same gameId
    wait_for_game_object(page1)
    wait_for_game_object(page2)

    state1 = get_game_state(page1)
    state2 = get_game_state(page2)

    assert state1 is not None, "Player 1 game object should exist"
    assert state2 is not None, "Player 2 game object should exist"
    assert state1["gameId"] == state2["gameId"], "Players should be matched in same game"
```

Note: The test uses idle players (no keyboard input). This is intentional:
- Overcooked episodes have a time limit and end naturally
- We're testing infrastructure, not gameplay
- This avoids complexity of simulating keyboard input
  </action>
  <verify>
Run: `pytest tests/e2e/test_multiplayer_basic.py -v --headed`
Expected: Both tests pass. Browsers show game loading, matching, and gameplay.
Check console output for "Game completed" message with gameId.
  </verify>
  <done>
- test_two_players_connect_and_complete_episode passes (full flow)
- test_matchmaking_pairs_two_players passes (lighter check)
- Both players matched to same gameId
- Episode completion detected
  </done>
</task>

<task type="auto">
  <name>Task 3: Add pytest configuration and verify full test suite</name>
  <files>pytest.ini</files>
  <action>
Create `pytest.ini` in project root:

```ini
[pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = -v --tb=short
markers =
    timeout: marks test with custom timeout
    slow: marks tests as slow (may skip in CI)
```

This provides:
- Standard test discovery from `tests/` directory
- Verbose output by default
- Short tracebacks (easier to read)
- Marker for timeout (used by pytest-timeout)

Then run the full test suite to verify everything works together.
  </action>
  <verify>
Run: `pytest tests/ -v` (full suite)
Expected: All tests pass (infrastructure smoke test + multiplayer tests)

Verify no orphan processes:
`ps aux | grep -E "overcooked|chromium" | grep -v grep` should be empty after tests
  </verify>
  <done>
- pytest.ini configures test discovery correctly
- Full test suite (3 tests) passes
- No orphan browser or server processes after tests
- Total test time under 5 minutes
  </done>
</task>

</tasks>

<verification>
1. Helper functions work: `python -c "from tests.fixtures.game_helpers import *"`
2. Multiplayer test passes: `pytest tests/e2e/test_multiplayer_basic.py -v --headed`
3. Full suite passes: `pytest tests/ -v`
4. No process leaks after tests complete
</verification>

<success_criteria>
- Game automation helpers correctly wait for socket, canvas, game object, episode completion
- Two players can connect, match, enter gameplay, and complete an episode
- Test captures game completion state (numEpisodes >= 1)
- Both players verified to be in the same game (matching gameId)
- All 3 tests in suite pass
</success_criteria>

<output>
After completion, create `.planning/phases/40-test-infrastructure/40-02-SUMMARY.md`
</output>
