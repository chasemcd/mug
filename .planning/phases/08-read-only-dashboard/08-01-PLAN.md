---
phase: 08-read-only-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/admin/aggregator.py
  - interactive_gym/server/admin/__init__.py
  - interactive_gym/server/admin/namespace.py
  - interactive_gym/server/app.py
autonomous: true

must_haves:
  truths:
    - "AdminEventAggregator can collect participant state from PARTICIPANT_SESSIONS"
    - "AdminEventAggregator can collect waiting room state from GAME_MANAGERS"
    - "State updates are pushed to admin namespace at 1-2 Hz"
    - "Activity events are logged and emitted to admin namespace"
  artifacts:
    - path: "interactive_gym/server/admin/aggregator.py"
      provides: "AdminEventAggregator class"
      min_lines: 100
      exports: ["AdminEventAggregator"]
    - path: "interactive_gym/server/admin/namespace.py"
      provides: "State emission handlers"
      contains: "emit.*state_update"
  key_links:
    - from: "interactive_gym/server/admin/aggregator.py"
      to: "PARTICIPANT_SESSIONS, GAME_MANAGERS, STAGERS"
      via: "constructor injection"
      pattern: "self\\.participant_sessions"
    - from: "interactive_gym/server/admin/namespace.py"
      to: "AdminEventAggregator"
      via: "aggregator.get_experiment_snapshot"
      pattern: "aggregator\\.get_"
    - from: "interactive_gym/server/app.py"
      to: "AdminEventAggregator"
      via: "initialization in run()"
      pattern: "ADMIN_AGGREGATOR.*AdminEventAggregator"
---

<objective>
Create backend state aggregation for the admin dashboard.

Purpose: Collect and project existing experiment state (participants, waiting rooms, games) into a format suitable for real-time dashboard display. This implements the observer pattern - reading existing state without modifying participant code paths.

Output: AdminEventAggregator class that periodically emits state snapshots to connected admins via SocketIO.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/v1.1/ARCHITECTURE.md
@.planning/research/v1.1/PITFALLS.md
@.planning/phases/07-admin-foundation/07-01-SUMMARY.md
@interactive_gym/server/app.py
@interactive_gym/server/admin/namespace.py
@interactive_gym/server/admin/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AdminEventAggregator class</name>
  <files>interactive_gym/server/admin/aggregator.py</files>
  <action>
Create `interactive_gym/server/admin/aggregator.py` with AdminEventAggregator class:

```python
class AdminEventAggregator:
    """
    Central hub for collecting and projecting experiment state to admin dashboard.

    Uses observer pattern - reads existing state structures without modifying them.
    Emits to admin namespace at 1-2 Hz (throttled).
    """

    def __init__(
        self,
        sio: flask_socketio.SocketIO,
        participant_sessions: dict,  # PARTICIPANT_SESSIONS
        stagers: dict,               # STAGERS
        game_managers: dict,         # GAME_MANAGERS
        pyodide_coordinator: PyodideGameCoordinator | None = None
    ):
        # Store references (read-only access)
        # Do NOT modify these - observer pattern only
```

Key methods to implement:

1. `get_experiment_snapshot() -> dict`:
   - Returns complete state dict with:
     - `participants`: List of participant state dicts
     - `waiting_rooms`: List of waiting room state dicts
     - `activity_log`: Recent activity events (last 100)
     - `summary`: Aggregate stats (total participants, active games, etc.)

2. `_get_participant_state(subject_id) -> dict`:
   - Extract: subject_id, current_scene_id, is_connected, connection_status
   - Connection status logic:
     - "connected" if is_connected=True
     - "disconnected" if is_connected=False and session exists
     - "completed" if subject_id in PROCESSED_SUBJECT_NAMES (need to pass this)
   - Include: created_at, last_updated_at from ParticipantSession
   - Include: scene progress (current_scene_index / total_scenes from stager)

3. `_get_waiting_room_state(scene_id, game_manager) -> dict`:
   - Extract from game_manager:
     - waiting_games list length
     - For each waiting game: players waiting, target size, wait start time
     - group_waitrooms: group_id -> waiting subjects, wait duration
   - Return: scene_id, waiting_count, target_size, avg_wait_duration_ms, groups

4. `log_activity(event_type, subject_id, details) -> None`:
   - Append to internal activity log (capped at 500 entries, FIFO)
   - Event types: "join", "scene_advance", "disconnect", "game_start", "game_end"
   - Include timestamp, subject_id, details dict

5. `start_broadcast_loop(interval_seconds=1.0) -> None`:
   - Use eventlet.spawn to run periodic broadcast
   - Call get_experiment_snapshot() and emit to 'admin_broadcast' room
   - Throttle: only emit if state changed (hash comparison) or every 2 seconds regardless

6. `emit_activity(event) -> None`:
   - Immediately emit single activity event to admins (for real-time timeline)
   - Call from log_activity after logging

IMPORTANT: Follow PITFALLS.md guidance:
- Use incremental updates where possible, not full state scans every tick
- Throttle high-frequency emissions to 1-2 Hz
- Don't hold locks while emitting (copy data first)
  </action>
  <verify>
File exists with:
- AdminEventAggregator class with __init__ accepting 5 parameters
- get_experiment_snapshot() method returning dict with participants, waiting_rooms, activity_log, summary keys
- log_activity() method for event logging
- start_broadcast_loop() method
  </verify>
  <done>
AdminEventAggregator class created with all projection methods and broadcast loop capability.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate aggregator with app.py and namespace</name>
  <files>
    interactive_gym/server/app.py
    interactive_gym/server/admin/namespace.py
    interactive_gym/server/admin/__init__.py
  </files>
  <action>
**In app.py:**

1. Add global at module level (near other globals):
```python
ADMIN_AGGREGATOR: AdminEventAggregator | None = None
```

2. Import AdminEventAggregator at top:
```python
from interactive_gym.server.admin.aggregator import AdminEventAggregator
```

3. In run() function, after GROUP_MANAGER initialization and before admin_namespace creation:
```python
# Initialize admin event aggregator
from interactive_gym.server.admin.aggregator import AdminEventAggregator
ADMIN_AGGREGATOR = AdminEventAggregator(
    sio=socketio,
    participant_sessions=PARTICIPANT_SESSIONS,
    stagers=STAGERS,
    game_managers=GAME_MANAGERS,
    pyodide_coordinator=PYODIDE_COORDINATOR
)
ADMIN_AGGREGATOR.start_broadcast_loop(interval_seconds=1.0)
logger.info("Admin event aggregator initialized and broadcast loop started")
```

4. Pass aggregator to AdminNamespace:
```python
admin_namespace = AdminNamespace('/admin', aggregator=ADMIN_AGGREGATOR)
```

5. Add activity logging hooks to key events (minimal invasive changes):
   - In `register_subject` after successful registration: `ADMIN_AGGREGATOR.log_activity("join", subject_id, {"socket_id": sid})`
   - In `advance_scene` after successful advance: `ADMIN_AGGREGATOR.log_activity("scene_advance", subject_id, {"scene_id": current_scene.scene_id})`
   - In `on_disconnect` before cleanup: `ADMIN_AGGREGATOR.log_activity("disconnect", subject_id, {"scene_id": session.current_scene_id if session else None})`

**In admin/namespace.py:**

Update on_request_state to use aggregator (already has placeholder):
```python
def on_request_state(self):
    """Admin requests current experiment state snapshot."""
    logger.debug("Admin requested state snapshot")

    if self.aggregator:
        state = self.aggregator.get_experiment_snapshot()
        emit('state_update', state)
    else:
        emit('state_update', {
            'participants': [],
            'waiting_rooms': [],
            'activity_log': [],
            'summary': {'total_participants': 0, 'active_games': 0, 'waiting_count': 0},
            'message': 'Aggregator not initialized'
        })
```

**In admin/__init__.py:**

Export AdminEventAggregator:
```python
from .aggregator import AdminEventAggregator
```
  </action>
  <verify>
1. `grep -n "ADMIN_AGGREGATOR" interactive_gym/server/app.py` shows global declaration and initialization
2. `grep -n "log_activity" interactive_gym/server/app.py` shows at least 3 logging calls
3. `grep -n "aggregator.get_experiment_snapshot" interactive_gym/server/admin/namespace.py` shows usage
4. Server starts without errors: `python -c "from interactive_gym.server.admin import AdminEventAggregator; print('OK')"`
  </verify>
  <done>
AdminEventAggregator integrated into app.py with activity logging hooks, AdminNamespace uses aggregator for state requests.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add connection status tracking</name>
  <files>
    interactive_gym/server/admin/aggregator.py
    interactive_gym/server/app.py
  </files>
  <action>
Enhance connection status to support green/yellow/red states (MON-02):

**In aggregator.py:**

Add connection status computation method:
```python
def _compute_connection_status(self, session: ParticipantSession, subject_id: str) -> str:
    """
    Compute connection status for display.

    Returns:
        'connected' (green) - Currently connected
        'reconnecting' (yellow) - Disconnected recently (< 30 seconds)
        'disconnected' (red) - Disconnected for > 30 seconds
        'completed' (gray) - Finished experiment
    """
    # Check if completed (need access to PROCESSED_SUBJECT_NAMES)
    if subject_id in self.processed_subjects:
        return 'completed'

    if session.is_connected:
        return 'connected'

    # Check how long disconnected
    if session.last_updated_at:
        seconds_since_update = time.time() - session.last_updated_at
        if seconds_since_update < 30:
            return 'reconnecting'

    return 'disconnected'
```

Add processed_subjects to __init__ signature and store reference:
```python
def __init__(
    self,
    sio,
    participant_sessions,
    stagers,
    game_managers,
    pyodide_coordinator=None,
    processed_subjects=None  # PROCESSED_SUBJECT_NAMES list
):
    ...
    self.processed_subjects = processed_subjects or []
```

Update _get_participant_state to use this:
```python
def _get_participant_state(self, subject_id: str) -> dict:
    session = self.participant_sessions.get(subject_id)
    if not session:
        return None

    stager = self.stagers.get(subject_id)
    scene_progress = None
    if stager:
        scene_progress = {
            'current_index': stager.current_scene_index,
            'total_scenes': len(stager.scenes),
            'current_scene_id': session.current_scene_id
        }

    return {
        'subject_id': subject_id,
        'connection_status': self._compute_connection_status(session, subject_id),
        'current_scene_id': session.current_scene_id,
        'scene_progress': scene_progress,
        'created_at': session.created_at,
        'last_updated_at': session.last_updated_at
    }
```

**In app.py:**

Pass PROCESSED_SUBJECT_NAMES to aggregator:
```python
ADMIN_AGGREGATOR = AdminEventAggregator(
    sio=socketio,
    participant_sessions=PARTICIPANT_SESSIONS,
    stagers=STAGERS,
    game_managers=GAME_MANAGERS,
    pyodide_coordinator=PYODIDE_COORDINATOR,
    processed_subjects=PROCESSED_SUBJECT_NAMES  # Add this
)
```
  </action>
  <verify>
1. `grep -n "_compute_connection_status" interactive_gym/server/admin/aggregator.py` shows method exists
2. `grep -n "connection_status" interactive_gym/server/admin/aggregator.py` shows it's included in participant state
3. `grep -n "processed_subjects" interactive_gym/server/app.py` shows it's passed to aggregator
  </verify>
  <done>
Connection status tracking implemented with connected/reconnecting/disconnected/completed states.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Server starts without import errors
2. AdminEventAggregator can be imported: `from interactive_gym.server.admin import AdminEventAggregator`
3. Aggregator has all required methods: get_experiment_snapshot, log_activity, start_broadcast_loop
4. Connection status logic distinguishes 4 states
5. Activity logging is integrated into register_subject, advance_scene, on_disconnect
</verification>

<success_criteria>
- AdminEventAggregator class exists and is properly integrated
- State snapshot includes participants with connection status, waiting rooms, activity log
- Broadcast loop emits state_update to admin_broadcast room at ~1 Hz
- Activity events are logged and immediately emitted for real-time timeline
- Server starts and runs without errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-read-only-dashboard/08-01-SUMMARY.md`
</output>
