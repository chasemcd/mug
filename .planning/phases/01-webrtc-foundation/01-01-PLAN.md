---
phase: 01-webrtc-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/pyodide_game_coordinator.py
  - interactive_gym/server/static/js/webrtc_manager.js
autonomous: true

must_haves:
  truths:
    - "SocketIO relays WebRTC signaling messages between peers"
    - "WebRTCManager can create offer/answer and exchange ICE candidates"
    - "DataChannel is configured as unreliable/unordered"
  artifacts:
    - path: "interactive_gym/server/pyodide_game_coordinator.py"
      provides: "webrtc_signal SocketIO handler"
      contains: "handle_webrtc_signal"
    - path: "interactive_gym/server/static/js/webrtc_manager.js"
      provides: "WebRTCManager class with connection lifecycle"
      exports: ["WebRTCManager"]
      min_lines: 150
  key_links:
    - from: "webrtc_manager.js"
      to: "SocketIO socket"
      via: "socket.emit('webrtc_signal', ...)"
      pattern: "socket\\.emit\\(['\"]webrtc_signal['\"]"
    - from: "pyodide_game_coordinator.py"
      to: "target socket"
      via: "sio.emit('webrtc_signal', ..., room=target_socket)"
      pattern: "emit\\(['\"]webrtc_signal['\"]"
---

<objective>
Create the WebRTC signaling infrastructure and connection manager.

Purpose: Establish the foundation for peer-to-peer communication by implementing server-side signaling relay and a client-side WebRTC connection manager.

Output:
- Server: `webrtc_signal` SocketIO handler that relays SDP/ICE messages between peers
- Client: `WebRTCManager` class that handles RTCPeerConnection lifecycle, DataChannel creation, and signaling message handling
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-webrtc-foundation/01-RESEARCH.md
@.planning/codebase/CONVENTIONS.md
@interactive_gym/server/pyodide_game_coordinator.py
@interactive_gym/server/static/js/pyodide_multiplayer_game.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WebRTC signaling handler to PyodideGameCoordinator</name>
  <files>interactive_gym/server/pyodide_game_coordinator.py</files>
  <action>
Add a `handle_webrtc_signal` method to `PyodideGameCoordinator` class that:

1. Accepts signaling data with fields: `game_id`, `target_player_id`, `type` (offer|answer|ice-candidate), `payload`
2. Looks up the game in `self.games`
3. Finds the target player's socket_id from `game.players[target_player_id]`
4. Determines sender's player_id by reverse-lookup from socket_id (iterate `game.players.items()`)
5. Emits `webrtc_signal` to target socket with: `type`, `from_player_id`, `game_id`, `payload`
6. Logs the relay at DEBUG level

Follow existing conventions:
- Method should use `with self.lock:` for thread safety
- Use `logger.debug()` for successful relays, `logger.warning()` for errors
- Parameter naming: `target_player_id` (snake_case)
- Return early if game/player not found

Note: The actual SocketIO event registration happens in app.py, but this method provides the handler logic. For now, add the method to the coordinator class - we'll wire it up in the integration plan.

Example signature:
```python
def handle_webrtc_signal(self, game_id: str, target_player_id: str | int,
                         signal_type: str, payload: Any, sender_socket_id: str):
```
  </action>
  <verify>
Run: `python -c "from interactive_gym.server.pyodide_game_coordinator import PyodideGameCoordinator; print(hasattr(PyodideGameCoordinator, 'handle_webrtc_signal'))"`
Output should be `True`
  </verify>
  <done>
`PyodideGameCoordinator.handle_webrtc_signal` method exists and correctly relays signaling messages to target peer's socket
  </done>
</task>

<task type="auto">
  <name>Task 2: Create WebRTCManager JavaScript class</name>
  <files>interactive_gym/server/static/js/webrtc_manager.js</files>
  <action>
Create a new ES module `webrtc_manager.js` that exports a `WebRTCManager` class.

The class should implement:

**Constructor:**
```javascript
constructor(socket, gameId, myPlayerId) {
    this.socket = socket;
    this.gameId = gameId;
    this.myPlayerId = myPlayerId;
    this.peerConnection = null;
    this.dataChannel = null;
    this.pendingCandidates = [];
    this.remoteDescriptionSet = false;

    // Callbacks (set by consumer)
    this.onDataChannelOpen = null;
    this.onDataChannelMessage = null;
    this.onDataChannelClose = null;
    this.onConnectionFailed = null;

    this._setupSignalingHandlers();
}
```

**Core methods:**

1. `_setupSignalingHandlers()` - Listen for `webrtc_signal` SocketIO events, dispatch to `_handleSignal()`

2. `async connectToPeer(peerId)` - Main entry point:
   - Create RTCPeerConnection with ICE servers (Google STUN only for Phase 1)
   - Determine initiator role: `this.myPlayerId < peerId` (lower ID initiates)
   - If initiator: create DataChannel, create/send offer
   - If answerer: wait for `ondatachannel` event
   - Store `this.targetPeerId = peerId` for signaling

3. `_createPeerConnection()` - Set up RTCPeerConnection:
   - ICE config: `{ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] }`
   - Handle `onicecandidate` -> send via `_sendSignal('ice-candidate', candidate)`
   - Handle `onconnectionstatechange` -> log state, call `onConnectionFailed` if 'failed'
   - Handle `ondatachannel` (for answerer) -> call `_setupDataChannel(event.channel)`

4. `_setupDataChannel(dc)` - Configure DataChannel:
   - `dc.binaryType = 'arraybuffer'`
   - Handle `onopen` -> call `this.onDataChannelOpen?.()`
   - Handle `onmessage` -> call `this.onDataChannelMessage?.(event.data)`
   - Handle `onclose` -> call `this.onDataChannelClose?.()`
   - Handle `onerror` -> log error

5. `async _handleSignal(data)` - Process incoming signaling:
   - Ignore if `data.from_player_id === this.myPlayerId`
   - Handle 'offer': setRemoteDescription, flush pending candidates, create/send answer
   - Handle 'answer': setRemoteDescription, flush pending candidates
   - Handle 'ice-candidate': if remoteDescription set, addIceCandidate; else buffer in pendingCandidates

6. `_sendSignal(type, payload)` - Send signaling message:
   ```javascript
   this.socket.emit('webrtc_signal', {
       game_id: this.gameId,
       target_player_id: this.targetPeerId,
       type: type,
       payload: payload
   });
   ```

7. `send(data)` - Send data over DataChannel:
   - Check `this.dataChannel?.readyState === 'open'`
   - Return `false` if not ready, `true` if sent

8. `close()` - Cleanup:
   - Close DataChannel if exists
   - Close RTCPeerConnection if exists
   - Set references to null
   - Remove signaling event listener

**DataChannel configuration (for initiator):**
```javascript
const dc = this.peerConnection.createDataChannel('game', {
    ordered: false,       // Unordered for UDP-like behavior
    maxRetransmits: 0     // No retransmits (GGPO handles loss)
});
```

**Key implementation notes from research:**
- Always call `setLocalDescription()` BEFORE sending SDP
- Buffer ICE candidates until `remoteDescription` is set
- Use `new RTCSessionDescription(payload)` when setting remote descriptions
- Use `new RTCIceCandidate(payload)` when adding ICE candidates
- Log connection state changes with `[WebRTC]` prefix for debugging

Export the class as default and named export:
```javascript
export { WebRTCManager };
export default WebRTCManager;
```
  </action>
  <verify>
1. File exists: `ls interactive_gym/server/static/js/webrtc_manager.js`
2. Exports WebRTCManager: `grep -c "export.*WebRTCManager" interactive_gym/server/static/js/webrtc_manager.js` returns 1+
3. Has DataChannel config: `grep "maxRetransmits.*0" interactive_gym/server/static/js/webrtc_manager.js` matches
4. Has ICE candidate buffering: `grep "pendingCandidates" interactive_gym/server/static/js/webrtc_manager.js` matches
  </verify>
  <done>
`webrtc_manager.js` exists with WebRTCManager class implementing:
- RTCPeerConnection lifecycle (create, connect, close)
- DataChannel creation with unreliable/unordered config
- SocketIO signaling (send/receive offer, answer, ICE candidates)
- ICE candidate buffering (prevents candidates before remote description)
- Callback interface for open/message/close/error events
  </done>
</task>

</tasks>

<verification>
1. Python import test passes for coordinator method
2. JavaScript file exists and exports WebRTCManager
3. DataChannel configured with `ordered: false, maxRetransmits: 0`
4. ICE candidate buffering implemented (pendingCandidates array)
5. Both signaling directions implemented (send via emit, receive via on)
</verification>

<success_criteria>
- `handle_webrtc_signal` method added to PyodideGameCoordinator
- `webrtc_manager.js` created with WebRTCManager class (150+ lines)
- DataChannel uses unreliable/unordered configuration
- Signaling flows in both directions via SocketIO
- ICE candidate buffering prevents race condition
</success_criteria>

<output>
After completion, create `.planning/phases/01-webrtc-foundation/01-01-SUMMARY.md`
</output>
