---
phase: 01-webrtc-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - interactive_gym/server/app.py
  - interactive_gym/server/static/js/pyodide_multiplayer_game.js
autonomous: false

must_haves:
  truths:
    - "User A and User B can establish a WebRTC peer connection after server-mediated SDP exchange"
    - "A DataChannel opens between peers with unreliable/unordered configuration"
    - "Both peers can send and receive test messages over the DataChannel"
    - "ICE candidate exchange completes via SocketIO signaling"
  artifacts:
    - path: "interactive_gym/server/app.py"
      provides: "webrtc_signal SocketIO event registration"
      contains: "@socketio.on('webrtc_signal')"
    - path: "interactive_gym/server/static/js/pyodide_multiplayer_game.js"
      provides: "WebRTCManager integration"
      contains: "WebRTCManager"
  key_links:
    - from: "app.py"
      to: "pyodide_game_coordinator.py"
      via: "PYODIDE_COORDINATOR.handle_webrtc_signal()"
      pattern: "PYODIDE_COORDINATOR\\.handle_webrtc_signal"
    - from: "pyodide_multiplayer_game.js"
      to: "webrtc_manager.js"
      via: "import WebRTCManager"
      pattern: "import.*WebRTCManager.*from.*webrtc_manager"
---

<objective>
Integrate WebRTC connection into the multiplayer game flow and verify end-to-end functionality.

Purpose: Wire the WebRTCManager into the existing game initialization flow so that peers automatically establish a DataChannel connection after the game is ready.

Output:
- Server: SocketIO event handler in `app.py` that delegates to coordinator
- Client: WebRTCManager instantiation and P2P connection triggered on `pyodide_game_ready`
- Verified: Test messages flow between peers over DataChannel
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-webrtc-foundation/01-RESEARCH.md
@.planning/phases/01-webrtc-foundation/01-01-SUMMARY.md
@.planning/codebase/CONVENTIONS.md
@interactive_gym/server/app.py
@interactive_gym/server/pyodide_game_coordinator.py
@interactive_gym/server/static/js/pyodide_multiplayer_game.js
@interactive_gym/server/static/js/webrtc_manager.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register webrtc_signal SocketIO event in app.py</name>
  <files>interactive_gym/server/app.py</files>
  <action>
Add a SocketIO event handler for `webrtc_signal` in `app.py`.

Find the section where other SocketIO handlers are registered (near `pyodide_player_action`, `pyodide_hud_update`, etc.) and add:

```python
@socketio.on('webrtc_signal')
def handle_webrtc_signal(data):
    """
    Relay WebRTC signaling messages between peers.

    Routes SDP offers/answers and ICE candidates through the server
    since peers cannot communicate directly until WebRTC is established.
    """
    if PYODIDE_COORDINATOR is None:
        logger.warning("WebRTC signal received but no coordinator")
        return

    game_id = data.get('game_id')
    target_player_id = data.get('target_player_id')
    signal_type = data.get('type')
    payload = data.get('payload')
    sender_socket_id = flask.request.sid

    PYODIDE_COORDINATOR.handle_webrtc_signal(
        game_id=game_id,
        target_player_id=target_player_id,
        signal_type=signal_type,
        payload=payload,
        sender_socket_id=sender_socket_id
    )
```

Follow existing conventions:
- Use same import style as other handlers
- Log at debug level for normal operation
- Early return with warning if coordinator not initialized
  </action>
  <verify>
`grep -c "@socketio.on('webrtc_signal')" interactive_gym/server/app.py` returns 1
  </verify>
  <done>
`webrtc_signal` SocketIO event is registered and delegates to `PYODIDE_COORDINATOR.handle_webrtc_signal()`
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate WebRTCManager into MultiplayerPyodideGame</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Integrate WebRTCManager into the existing MultiplayerPyodideGame class.

1. **Add import at top of file:**
```javascript
import { WebRTCManager } from './webrtc_manager.js';
```

2. **Add properties to constructor (after existing properties):**
```javascript
// P2P WebRTC connection
this.webrtcManager = null;
this.p2pConnected = false;
this.p2pPeerId = null;  // The other player's ID
```

3. **Modify `pyodide_game_ready` handler** to initiate P2P connection:

After the existing logic that initializes action queues, add:

```javascript
// Initiate P2P WebRTC connection
// Find the other player's ID (for 2-player games)
const otherPlayers = data.players.filter(pid => pid != this.myPlayerId);
if (otherPlayers.length === 1) {
    this.p2pPeerId = otherPlayers[0];
    this._initP2PConnection();
} else if (otherPlayers.length > 1) {
    console.warn('[MultiplayerPyodide] P2P only supports 2-player games, skipping WebRTC');
}
```

4. **Add `_initP2PConnection()` method:**
```javascript
_initP2PConnection() {
    /**
     * Initialize WebRTC P2P connection to peer.
     * Called after pyodide_game_ready when we know the other player's ID.
     */
    console.log(`[MultiplayerPyodide] Initiating P2P connection to player ${this.p2pPeerId}`);

    this.webrtcManager = new WebRTCManager(socket, this.gameId, this.myPlayerId);

    // Set up callbacks
    this.webrtcManager.onDataChannelOpen = () => {
        console.log('[MultiplayerPyodide] P2P DataChannel OPEN');
        this.p2pConnected = true;

        // Send a test message to verify connection
        this._sendP2PTestMessage();
    };

    this.webrtcManager.onDataChannelMessage = (data) => {
        this._handleP2PMessage(data);
    };

    this.webrtcManager.onDataChannelClose = () => {
        console.log('[MultiplayerPyodide] P2P DataChannel CLOSED');
        this.p2pConnected = false;
    };

    this.webrtcManager.onConnectionFailed = () => {
        console.error('[MultiplayerPyodide] P2P connection FAILED');
        this.p2pConnected = false;
        // For Phase 1, just log - fallback to SocketIO is existing behavior
    };

    // Start the connection (role determined by player ID comparison)
    this.webrtcManager.connectToPeer(this.p2pPeerId);
}
```

5. **Add `_sendP2PTestMessage()` method:**
```javascript
_sendP2PTestMessage() {
    /**
     * Send a test message over the P2P DataChannel to verify connectivity.
     */
    const testMessage = {
        type: 'test',
        from: this.myPlayerId,
        timestamp: Date.now()
    };

    const success = this.webrtcManager.send(JSON.stringify(testMessage));
    if (success) {
        console.log('[MultiplayerPyodide] Sent P2P test message');
    } else {
        console.warn('[MultiplayerPyodide] Failed to send P2P test message');
    }
}
```

6. **Add `_handleP2PMessage(data)` method:**
```javascript
_handleP2PMessage(data) {
    /**
     * Handle incoming P2P DataChannel messages.
     * For Phase 1, only handles test messages. Phase 2 will add input handling.
     */
    try {
        // Handle both string and ArrayBuffer data
        let message;
        if (typeof data === 'string') {
            message = JSON.parse(data);
        } else if (data instanceof ArrayBuffer) {
            const decoder = new TextDecoder();
            message = JSON.parse(decoder.decode(data));
        } else {
            console.warn('[MultiplayerPyodide] Unknown P2P message type:', typeof data);
            return;
        }

        if (message.type === 'test') {
            const latency = Date.now() - message.timestamp;
            console.log(`[MultiplayerPyodide] Received P2P test from player ${message.from}, latency: ${latency}ms`);
        } else {
            console.log('[MultiplayerPyodide] Received P2P message:', message.type);
        }
    } catch (e) {
        console.error('[MultiplayerPyodide] Failed to parse P2P message:', e);
    }
}
```

7. **Add cleanup in existing `cleanup()` or destructor method** (if exists, or in `resetForNewEpisode` if that's the pattern):
```javascript
// In cleanup/reset logic, add:
if (this.webrtcManager) {
    this.webrtcManager.close();
    this.webrtcManager = null;
    this.p2pConnected = false;
}
```
  </action>
  <verify>
1. `grep -c "import.*WebRTCManager" interactive_gym/server/static/js/pyodide_multiplayer_game.js` returns 1
2. `grep -c "_initP2PConnection" interactive_gym/server/static/js/pyodide_multiplayer_game.js` returns 2+ (definition + call)
3. `grep -c "p2pConnected" interactive_gym/server/static/js/pyodide_multiplayer_game.js` returns 3+ (property + assignments)
  </verify>
  <done>
MultiplayerPyodideGame imports WebRTCManager, instantiates it on game ready, and handles DataChannel callbacks including test message exchange
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete WebRTC signaling and DataChannel connection flow:
1. Server relays WebRTC signaling (SDP offer/answer, ICE candidates)
2. Client WebRTCManager handles connection lifecycle
3. MultiplayerPyodideGame initiates P2P connection on game ready
4. Test messages exchanged over DataChannel
  </what-built>
  <how-to-verify>
1. Start the server: `python -m interactive_gym.examples.slimevolleyball.slimevb_human_human` (or similar multiplayer example)
2. Open two browser tabs to the game URL (use different incognito windows if needed)
3. Join both players to start the game
4. Open browser DevTools console in both tabs
5. Look for these log messages indicating success:

**In both consoles:**
- `[MultiplayerPyodide] Initiating P2P connection to player X`
- `[WebRTC] Connection state: connected` (or similar state logs)
- `[MultiplayerPyodide] P2P DataChannel OPEN`
- `[MultiplayerPyodide] Sent P2P test message`
- `[MultiplayerPyodide] Received P2P test from player X, latency: Nms`

**Success criteria:**
- Both peers show "DataChannel OPEN"
- Both peers receive the test message from their partner
- Latency reported should be reasonable (typically < 100ms on LAN)
- No WebRTC errors in console

**If connection fails:**
- Check for ICE candidate errors
- Verify both clients are receiving signaling messages
- Check server logs for webrtc_signal relay messages
  </how-to-verify>
  <resume-signal>Type "approved" if P2P connection works, or describe issues observed</resume-signal>
</task>

</tasks>

<verification>
1. SocketIO event registered: `@socketio.on('webrtc_signal')` in app.py
2. WebRTCManager imported in multiplayer game
3. P2P connection initiated on game ready
4. Test messages sent and received over DataChannel
5. Human verified: Both peers connect and exchange test messages
</verification>

<success_criteria>
Phase 1 success criteria (from ROADMAP.md):
1. User A and User B can establish a WebRTC peer connection after server-mediated SDP exchange
2. A DataChannel opens between peers with unreliable/unordered configuration (ordered: false, maxRetransmits: 0)
3. Both peers can send and receive test messages over the DataChannel
4. ICE candidate exchange completes via SocketIO signaling

All criteria verified via browser DevTools console output during human verification.
</success_criteria>

<output>
After completion, create `.planning/phases/01-webrtc-foundation/01-02-SUMMARY.md`
</output>
