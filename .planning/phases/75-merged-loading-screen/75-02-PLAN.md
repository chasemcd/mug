---
phase: 75-merged-loading-screen
plan: 02
type: execute
wave: 2
depends_on: ["75-01"]
files_modified:
  - interactive_gym/server/static/js/index.js
autonomous: true

must_haves:
  truths:
    - "Participant sees exactly one loading screen during pre-game setup"
    - "Loading screen does not advance until both screening passes AND Pyodide is ready"
    - "If Pyodide fails or times out, participant sees an error page via showExclusionMessage()"
    - "Timeout duration comes from pyodide_config.pyodide_load_timeout_s (default 60s)"
    - "Non-Pyodide experiments are not affected (pyodide gate is immediately satisfied)"
    - "Reconnect after loading completes does not re-show the loading screen"
  artifacts:
    - path: "interactive_gym/server/static/js/index.js"
      provides: "Loading gate logic, unified loading screen, timeout, error handling"
      contains: "loadingGate"
  key_links:
    - from: "experiment_config handler"
      to: "loadingGate object"
      via: "handler creates gate, starts preload and screening, both call checkLoadingGate on completion"
      pattern: "checkLoadingGate"
    - from: "preloadPyodide()"
      to: "checkLoadingGate()"
      via: "preloadPyodide sets loadingGate.pyodideComplete and calls checkLoadingGate"
      pattern: "loadingGate\\.pyodideComplete"
    - from: "checkLoadingGate()"
      to: "showExclusionMessage() or processPendingScene()"
      via: "gate resolves to error page or scene dispatch depending on both signals"
      pattern: "checkLoadingGate.*showExclusionMessage|processPendingScene"
---

<objective>
Refactor the client-side JavaScript to use a unified loading gate that coordinates both entry screening and Pyodide preloading into a single loading screen, with configurable timeout and proper error handling.

Purpose: This is the core implementation for LOAD-01 (single screen), LOAD-02 (dual gate), LOAD-03 (configurable timeout on client side), and LOAD-04 (error page on failure/timeout). It replaces the current scattered gating approach with an event-driven dual-signal loading gate.

Output: Modified index.js with loadingGate object, refactored experiment_config handler, updated preloadPyodide(), timeout handling, and simplified per-scene Pyodide gating.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/75-merged-loading-screen/75-RESEARCH.md
@.planning/phases/75-merged-loading-screen/75-01-SUMMARY.md

@interactive_gym/server/static/js/index.js
@interactive_gym/server/static/templates/index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add loading gate and refactor experiment_config handler</name>
  <files>interactive_gym/server/static/js/index.js</files>
  <action>
    This task makes several coordinated changes to index.js. Read the entire file first, then apply all changes together.

    **A. Add loadingGate object (near the top, after the pyodide preload state block around line 207)**

    Add a loading gate object right after `window.pyodidePreloadStatus = 'idle';` (around line 207):

    ```javascript
    // Unified loading gate (Phase 75) - coordinates screening + Pyodide readiness
    const loadingGate = {
        screeningComplete: false,
        screeningPassed: null,       // true/false/null
        screeningMessage: null,      // exclusion message if failed
        pyodideComplete: false,
        pyodideSuccess: null,        // true/false/null
        timeoutId: null,
        gateResolved: false,         // prevents re-entry on reconnect
    };
    ```

    **B. Add checkLoadingGate() function (right after the loadingGate object)**

    ```javascript
    /**
     * Check if both loading signals (screening + Pyodide) are complete.
     * Called by both screening completion and Pyodide completion paths.
     * When both are done, resolves the gate: proceed to scene or show error.
     */
    function checkLoadingGate() {
        if (loadingGate.gateResolved) return;

        // Update status text based on current state
        const statusEl = document.getElementById('loadingStatus');
        if (statusEl) {
            if (!loadingGate.screeningComplete && !loadingGate.pyodideComplete) {
                statusEl.textContent = 'Checking compatibility...';
            } else if (loadingGate.screeningComplete && !loadingGate.pyodideComplete) {
                statusEl.textContent = 'Loading Python runtime...';
            } else if (!loadingGate.screeningComplete && loadingGate.pyodideComplete) {
                statusEl.textContent = 'Checking compatibility...';
            }
        }

        // Both must be complete before we can resolve
        if (!loadingGate.screeningComplete || !loadingGate.pyodideComplete) {
            return;
        }

        // Gate is resolving -- mark resolved to prevent re-entry
        loadingGate.gateResolved = true;
        if (loadingGate.timeoutId) {
            clearTimeout(loadingGate.timeoutId);
            loadingGate.timeoutId = null;
        }

        // Hide loading screen
        const loadingScreen = document.getElementById('loadingScreen');
        if (loadingScreen) loadingScreen.style.display = 'none';

        // Screening failed -> show exclusion (existing behavior)
        if (!loadingGate.screeningPassed) {
            console.log('[LoadingGate] Screening failed:', loadingGate.screeningMessage);
            showExclusionMessage(loadingGate.screeningMessage);
            return;
        }

        // Pyodide failed -> show error page (LOAD-04)
        if (!loadingGate.pyodideSuccess) {
            console.log('[LoadingGate] Pyodide failed - showing error page');
            showExclusionMessage('Failed to load the Python runtime. Please refresh the page or try a different browser.');
            return;
        }

        // Both passed -> proceed to scene
        console.log('[LoadingGate] Both signals ready - proceeding');
        if (pendingSceneData) {
            processPendingScene();
        } else {
            console.log('[LoadingGate] No pending scene, requesting from server');
            socket.emit("request_current_scene", {});
        }
    }
    ```

    **C. Modify preloadPyodide() to integrate with loading gate**

    In the existing `preloadPyodide()` function (around line 216):

    1. In the early return for non-Pyodide experiments (`!pyodideConfig.needs_pyodide`), ADD after `window.pyodidePreloadStatus = 'ready';`:
       ```javascript
       loadingGate.pyodideComplete = true;
       loadingGate.pyodideSuccess = true;
       checkLoadingGate();
       ```

    2. Remove the call to `showPyodideProgress('Loading Python runtime...');` (line ~224). The loading screen is now managed by the experiment_config handler.

    3. Remove the call to `showPyodideProgress('Installing packages...');` (line ~234). Status updates now go through `#loadingStatus` via checkLoadingGate().
       Instead, update the loading status directly:
       ```javascript
       const statusEl = document.getElementById('loadingStatus');
       if (statusEl) statusEl.textContent = 'Installing packages...';
       ```

    4. In the success path (after `window.pyodidePreloadStatus = 'ready';`):
       - Remove `hidePyodideProgress();`
       - ADD:
         ```javascript
         loadingGate.pyodideComplete = true;
         loadingGate.pyodideSuccess = true;
         checkLoadingGate();
         ```

    5. In the catch error path (after `window.pyodidePreloadStatus = 'error';`):
       - Remove `showPyodideProgress('Loading failed - will retry when game starts');`
       - ADD:
         ```javascript
         loadingGate.pyodideComplete = true;
         loadingGate.pyodideSuccess = false;
         checkLoadingGate();
         ```

    **D. Remove showPyodideProgress() and hidePyodideProgress() functions**

    Delete the `showPyodideProgress()` and `hidePyodideProgress()` functions (around lines 264-274). They reference `#pyodideLoader` and `#pyodideStatus` which no longer exist in the HTML.

    **E. Refactor the experiment_config handler (lines 585-652)**

    Replace the entire `socket.on('experiment_config', ...)` handler with the following logic:

    ```javascript
    socket.on('experiment_config', async function(data) {
        console.log("[ExperimentConfig] Received experiment configuration");

        // Guard against re-entry on reconnect (Pitfall 5)
        if (loadingGate.gateResolved) {
            console.log("[ExperimentConfig] Loading gate already resolved, skipping");
            return;
        }

        // Show unified loading screen (LOAD-01)
        const loadingScreen = document.getElementById('loadingScreen');
        if (loadingScreen) loadingScreen.style.display = 'flex';

        // Start Pyodide preload concurrently (fire and forget)
        if (data.pyodide_config) {
            preloadPyodide(data.pyodide_config);

            // Start timeout timer if Pyodide is needed (LOAD-03)
            if (data.pyodide_config.needs_pyodide) {
                const timeoutS = data.pyodide_config.pyodide_load_timeout_s || 60;
                loadingGate.timeoutId = setTimeout(() => {
                    if (!loadingGate.pyodideComplete) {
                        console.error('[LoadingGate] Pyodide loading timed out after ' + timeoutS + 's');
                        window.pyodidePreloadStatus = 'error';
                        loadingGate.pyodideComplete = true;
                        loadingGate.pyodideSuccess = false;
                        // Signal server loading is done (timeout) to clear grace state
                        socket.emit('pyodide_loading_complete', { error: true, reason: 'timeout' });
                        checkLoadingGate();
                    }
                }, timeoutS * 1000);
            }
        } else {
            // No Pyodide config -> immediately mark pyodide as complete
            loadingGate.pyodideComplete = true;
            loadingGate.pyodideSuccess = true;
        }

        // If no pyodide needed, mark complete immediately
        // (preloadPyodide handles this internally, but handle the case where
        // pyodide_config exists but needs_pyodide is false -- covered by preloadPyodide's
        // early return which now calls checkLoadingGate)

        // Run entry screening
        if (data.entry_screening) {
            experimentScreeningConfig = data.entry_screening;
            console.log("[ExperimentConfig] Entry screening config:", experimentScreeningConfig);

            const hasScreeningRules = experimentScreeningConfig.device_exclusion ||
                (experimentScreeningConfig.browser_requirements && experimentScreeningConfig.browser_requirements.length > 0) ||
                (experimentScreeningConfig.browser_blocklist && experimentScreeningConfig.browser_blocklist.length > 0) ||
                experimentScreeningConfig.max_ping ||
                experimentScreeningConfig.has_entry_callback;

            if (hasScreeningRules) {
                console.log("[ExperimentConfig] Running experiment-level entry screening...");

                // Update loading status
                const statusEl = document.getElementById('loadingStatus');
                if (statusEl) statusEl.textContent = 'Checking compatibility...';

                const result = await runEntryScreening(experimentScreeningConfig);
                experimentScreeningPassed = result.passed;
                experimentScreeningMessage = result.message;
                experimentScreeningComplete = true;

                // Update loading gate with screening result
                loadingGate.screeningComplete = true;
                loadingGate.screeningPassed = result.passed;
                loadingGate.screeningMessage = result.message;

                if (!result.passed) {
                    console.log("[ExperimentConfig] Screening failed:", result.failedRule, result.message);
                }

                checkLoadingGate();
            } else {
                // No screening rules configured
                experimentScreeningPassed = true;
                experimentScreeningComplete = true;
                loadingGate.screeningComplete = true;
                loadingGate.screeningPassed = true;
                checkLoadingGate();
            }
        } else {
            // No entry screening config
            experimentScreeningPassed = true;
            experimentScreeningComplete = true;
            loadingGate.screeningComplete = true;
            loadingGate.screeningPassed = true;
            checkLoadingGate();
        }
    });
    ```

    Key differences from the old handler:
    - Shows `#loadingScreen` instead of `#screeningLoader`
    - Does NOT call `processPendingScene()` directly -- delegates to `checkLoadingGate()` which handles scene dispatch
    - Does NOT call `socket.emit("request_current_scene")` directly -- `checkLoadingGate()` handles this
    - Adds Pyodide timeout via `setTimeout` (LOAD-03)
    - Guards against reconnect re-entry with `loadingGate.gateResolved` check

    **F. Simplify per-scene Pyodide gating (keep as safety net)**

    In `startStaticScene()` (around lines 1304-1313), the Pyodide gate polling for the advance button:
    - Keep it as-is. Per the research recommendation, this is a no-cost safety net. Once the loading gate passes, `pyodidePreloadStatus` is guaranteed 'ready', so this code becomes a no-op. But if some edge case bypasses the loading gate (e.g., session restoration), it still protects.

    In the `advanceButton` click handler (around lines 1493-1497):
    - Keep it as-is. Same reasoning -- safety net.

    In `enableStartRefreshInterval()` (around lines 1590-1633):
    - Keep it as-is. The `pyodideReadyIfUsing()` check is already a correct safety net for gym scenes.

    **IMPORTANT: What NOT to change:**
    - Do NOT modify `processPendingScene()` -- it stays the same
    - Do NOT modify `pyodideReadyIfUsing()` -- it stays the same
    - Do NOT modify `startStaticScene()` Pyodide gate -- keep as safety net
    - Do NOT modify `advanceButton` click handler Pyodide check -- keep as safety net
    - Do NOT modify `enableStartRefreshInterval()` -- keep as safety net
  </action>
  <verify>
    1. `grep -c 'loadingGate' interactive_gym/server/static/js/index.js` returns a count > 0 (confirms gate object exists)
    2. `grep -c 'checkLoadingGate' interactive_gym/server/static/js/index.js` returns a count > 0 (confirms gate function exists)
    3. `grep -c 'showPyodideProgress\|hidePyodideProgress' interactive_gym/server/static/js/index.js` returns 0 (old functions removed)
    4. `grep -c 'screeningLoader' interactive_gym/server/static/js/index.js` returns 0 (no references to old element)
    5. `grep -c 'pyodideLoader' interactive_gym/server/static/js/index.js` returns 0 (no references to old element)
    6. `grep -c 'loadingScreen' interactive_gym/server/static/js/index.js` returns a count > 0 (references new element)
    7. `grep 'gateResolved' interactive_gym/server/static/js/index.js` shows the reconnect guard
    8. `grep 'pyodide_load_timeout_s' interactive_gym/server/static/js/index.js` shows the timeout config usage
  </verify>
  <done>
    - The experiment_config handler shows a single #loadingScreen and delegates to checkLoadingGate() (LOAD-01, LOAD-02)
    - Pyodide timeout is read from pyodide_config.pyodide_load_timeout_s with 60s default (LOAD-03)
    - Timeout and error paths call showExclusionMessage() for a clear error page (LOAD-04)
    - preloadPyodide() updates loadingGate and calls checkLoadingGate() on completion
    - Non-Pyodide experiments immediately satisfy the pyodide gate signal
    - Reconnect guard prevents re-showing the loading screen after it has resolved
    - Per-scene Pyodide gating preserved as safety net (no behavioral change for edge cases)
    - Old showPyodideProgress/hidePyodideProgress functions removed (no longer needed)
  </done>
</task>

<task type="auto">
  <name>Task 2: Smoke test with manual server start</name>
  <files>interactive_gym/server/static/js/index.js</files>
  <action>
    Run the existing E2E test suite to verify no regressions from the loading screen changes. The multiplayer basic test is the best quick validation because it exercises the full flow: experiment_config -> screening -> Pyodide preload -> scene dispatch.

    Run:
    ```bash
    cd /Users/chasemcd/Repositories/interactive-gym
    python -m pytest tests/e2e/test_multiplayer_basic.py -x -v --timeout=300
    ```

    If the test passes, the loading gate is working correctly (both screening and Pyodide complete, scene dispatches, game plays through).

    If the test fails:
    - Check if it's a loading screen issue (stuck on loading, error page shown when shouldn't be)
    - Check console output for [LoadingGate] log messages
    - Fix any issues found (likely: loadingScreen display style mismatch, missing gate signal, or timing issue)

    Also verify non-Pyodide experiment path is not broken by running:
    ```bash
    python -c "
    from interactive_gym.configurations.experiment_config import ExperimentConfig
    c = ExperimentConfig()
    config = c.get_pyodide_config()
    assert config['needs_pyodide'] == False
    assert config['pyodide_load_timeout_s'] == 60
    print('Non-Pyodide config OK - needs_pyodide is False, timeout configured')
    "
    ```
  </action>
  <verify>
    - E2E test `test_multiplayer_basic.py` passes (at least 2 tests pass: basic episode completion and data export)
    - No Python import errors in config classes
  </verify>
  <done>
    E2E smoke test passes, confirming the unified loading screen works end-to-end: experiment_config arrives, loading screen shows, both Pyodide and screening complete, gate resolves, scene dispatches, game plays through.
  </done>
</task>

</tasks>

<verification>
1. LOAD-01: Single loading screen - only `#loadingScreen` exists in HTML and JS, no `#screeningLoader` or `#pyodideLoader` references
2. LOAD-02: Dual gate - `checkLoadingGate()` requires both `screeningComplete` AND `pyodideComplete` before proceeding
3. LOAD-03: Configurable timeout - `setTimeout` uses `pyodide_load_timeout_s` from config (default 60s)
4. LOAD-04: Error page - both timeout and Pyodide error paths call `showExclusionMessage()` with clear error text
5. No regressions: E2E test suite passes, per-scene safety nets preserved
</verification>

<success_criteria>
- The loadingGate object coordinates both signals (screening + Pyodide) before allowing scene dispatch
- Pyodide timeout uses configurable value from server config
- Error/timeout shows showExclusionMessage() error page (not a hang or blank screen)
- Reconnect guard prevents loading screen from re-appearing
- showPyodideProgress/hidePyodideProgress removed (old #pyodideLoader functions)
- No references to #screeningLoader or #pyodideLoader remain in JS
- E2E multiplayer basic test passes
</success_criteria>

<output>
After completion, create `.planning/phases/75-merged-loading-screen/75-02-SUMMARY.md`
</output>
