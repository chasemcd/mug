---
phase: 94-client-rendering-and-input
plan: 02
type: execute
wave: 1
depends_on: ["94-01"]
files_modified:
  - mug/server/static/js/index.js
  - mug/server/static/js/phaser_gym_graphics.js
  - mug/server/app.py
  - mug/server/game_manager.py
  - mug/server/remote_game.py
autonomous: true

must_haves:
  truths:
    - "Client handles episode reset from server: flushes state buffer, restarts rendering fresh"
    - "Client handles game complete from server: stops rendering, shows post-game flow identical to P2P"
    - "Client can reconnect to a running server-auth game and resume rendering from current state"
    - "Server tracks disconnect timeout per player and drops permanently after configurable expiry"
  artifacts:
    - path: "mug/server/static/js/index.js"
      provides: "Server-auth-aware game_reset and end_game handlers, reconnection logic"
    - path: "mug/server/app.py"
      provides: "Server-auth reconnection handler (rejoin_game or similar)"
    - path: "mug/server/game_manager.py"
      provides: "Disconnect timeout tracking and permanent drop logic for server-auth games"
  key_links:
    - from: "mug/server/static/js/index.js"
      to: "phaser_gym_graphics.js clearStateBuffer"
      via: "game_reset handler flushes buffer on episode transition"
      pattern: "clearStateBuffer"
    - from: "mug/server/app.py"
      to: "mug/server/game_manager.py"
      via: "reconnection socket handler calls game_manager to re-add player"
      pattern: "rejoin.*server_auth"
---

<objective>
Handle episode transitions (reset and game complete) and connection resilience for server-authoritative mode. The client flushes its state buffer on episode reset, handles game complete with the same post-game flow as P2P, and supports reconnection to running games with configurable disconnect timeout.

Purpose: Without episode transition handling, multi-episode server-auth games would not work. Without reconnection, any disconnect permanently loses a participant -- a major advantage of server-auth over P2P is the ability to rejoin.

Output: Modified JS and Python files enabling episode transitions and reconnection for server-auth games.
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/94-client-rendering-and-input/94-01-PLAN.md
@mug/server/static/js/index.js
@mug/server/static/js/phaser_gym_graphics.js
@mug/server/app.py
@mug/server/game_manager.py
@mug/server/remote_game.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Handle episode reset and game complete for server-auth clients</name>
  <files>
    mug/server/static/js/index.js
    mug/server/static/js/phaser_gym_graphics.js
  </files>
  <action>
**Episode Reset (game_reset handler in index.js, line 1118):**

The existing `game_reset` handler destroys the Phaser game and recreates it with a countdown. For server-auth mode, this needs a key modification:

1. In the `game_reset` handler, when `window.serverAuthoritative === true`:
   - Call `clearStateBuffer()` (imported from phaser_gym_graphics.js) to flush the buffer immediately. Per user decision: "On episode reset: flush the state buffer immediately, start fresh with new episode states."
   - Do NOT destroy and recreate the Phaser game instance. Server-auth rendering is continuous -- just flush the buffer and let new states arrive. The existing Phaser instance keeps running and will render new states as they come in.
   - Still show the reset countdown UI (startResetCountdown) to match P2P behavior per user decision: "Episode reset behavior matches P2P mode exactly."
   - After countdown completes, emit `reset_complete` to the server (same as P2P path) so the server's `run_server_game` can proceed past the reset wait.
   - The `scene_metadata` fallback to `resetData.config` should still work since the server sends config in the game_reset event.

2. Ensure `clearStateBuffer` is exported from phaser_gym_graphics.js (it's currently a non-exported function on line 23). Export it:
   ```js
   export function clearStateBuffer() {
       stateBuffer = [];
   }
   ```
   And import it in index.js alongside the existing imports.

**Game Complete (end_game handler in index.js, line 1220):**

The existing `end_game` handler already works generically:
- Calls `graphics_end()` to destroy the Phaser game
- Hides HUD, disables key listener
- Emits `leave_game`
- Shows error message if present
- Requests redirect

3. Verify this handler works for server-auth mode. It should, since it doesn't reference pyodide or P2P state. If `window.serverAuthoritative` is true, additionally:
   - Clear `window.serverAuthoritative = false` and `window.currentGameId = null` to reset state
   - Call `clearStateBuffer()` to clean up

4. Export `clearStateBuffer` from phaser_gym_graphics.js and add it to the import line in index.js (line 3).
  </action>
  <verify>
    - Grep for `clearStateBuffer` in index.js confirms import and usage in game_reset handler
    - Grep for `export function clearStateBuffer` in phaser_gym_graphics.js confirms export
    - The game_reset handler has a `window.serverAuthoritative` branch
    - The end_game handler clears serverAuthoritative state
  </verify>
  <done>
    - Episode reset flushes state buffer and shows countdown (matching P2P behavior)
    - Episode reset emits reset_complete to server after countdown
    - Game complete cleans up server-auth state and follows same post-game flow as P2P
    - clearStateBuffer is exported and used in both reset and end_game paths
  </done>
</task>

<task type="auto">
  <name>Task 2: Add server-auth reconnection support</name>
  <files>
    mug/server/app.py
    mug/server/game_manager.py
    mug/server/remote_game.py
    mug/server/static/js/index.js
  </files>
  <action>
**Server-side reconnection (Python):**

Per user decisions:
- "Reconnection: participant can rejoin a running game (server-auth advantage over P2P)"
- "On rejoin: client receives just the current state and starts rendering from there (no burst of history)"
- "Configurable disconnect timeout: researcher sets max disconnect duration; after expiry, participant is dropped permanently (slot stays on default actions)"

1. In `mug/server/game_manager.py`, modify `leave_game` for server-auth disconnect handling:
   - The existing server-auth branch (line 1147) just logs and continues. Enhance it to:
   - Start a disconnect timeout timer using `eventlet.spawn_after(timeout_seconds, self._permanent_drop, game_id, subject_id)`
   - Store the timeout greenlet in a dict so it can be cancelled on reconnect: `self._disconnect_timeouts: dict[SubjectID, eventlet.GreenThread] = {}`
   - The timeout value comes from `self.scene.reconnection_timeout_ms / 1000` (already exists on GymScene, default 5000ms = 5s)
   - Do NOT remove the player from the game immediately -- they stay in the slot with default actions
   - Do NOT call `remove_subject` (which deletes from subject_games/subject_rooms)
   - Instead, just mark the player as disconnected (e.g., set `game.document_focus_status[subject_id] = False`) and let the game loop continue with default actions

2. Add a `_permanent_drop` method to GameManager:
   ```python
   def _permanent_drop(self, game_id, subject_id):
       """Permanently drop a disconnected player after timeout expiry."""
       game = self.games.get(game_id)
       if game is None:
           return
       # Only drop if still disconnected (not reconnected)
       if subject_id in self._disconnect_timeouts:
           del self._disconnect_timeouts[subject_id]
           # Remove from subject tracking but leave game slot on default actions
           if subject_id in self.subject_games:
               del self.subject_games[subject_id]
           if subject_id in self.subject_rooms:
               del self.subject_rooms[subject_id]
           logger.info(f"[ServerAuth] Permanently dropped {subject_id} from game {game_id} after timeout")
   ```

3. Add a `rejoin_server_auth_game` method to GameManager:
   ```python
   def rejoin_server_auth_game(self, subject_id, socket_id):
       """Rejoin a disconnected player to their running server-auth game."""
       game_id = self.subject_games.get(subject_id)
       if game_id is None:
           return None
       game = self.games.get(game_id)
       if game is None:
           return None
       if game.status not in (remote_game.GameStatus.Active, remote_game.GameStatus.Reset):
           return None

       # Cancel disconnect timeout
       timeout = self._disconnect_timeouts.pop(subject_id, None)
       if timeout is not None:
           timeout.cancel()

       # Rejoin the room
       flask_socketio.join_room(game_id, sid=socket_id)
       self.subject_rooms[subject_id] = game_id

       logger.info(f"[ServerAuth] {subject_id} rejoined game {game_id}")
       return game
   ```

4. In `mug/server/app.py`, add a `rejoin_server_auth` socket handler:
   ```python
   @socketio.on("rejoin_server_auth")
   def on_rejoin_server_auth(data):
       subject_id = get_subject_id_from_session_id(flask.request.sid)
       if subject_id is None:
           return
       for gm in GAME_MANAGERS.values():
           game = gm.rejoin_server_auth_game(subject_id, flask.request.sid)
           if game is not None:
               socketio.emit("rejoin_success", {
                   "game_id": game.game_id,
                   "scene_metadata": gm.scene.scene_metadata,
               }, room=flask.request.sid)
               return
       socketio.emit("rejoin_failed", {}, room=flask.request.sid)
   ```

5. Initialize `self._disconnect_timeouts = {}` in `GameManager.__init__`.

**Client-side reconnection (JS):**

6. In `index.js`, add a `socket.on('connect', ...)` or `socket.on('reconnect', ...)` handler that:
   - If `window.serverAuthoritative === true` and `window.currentGameId` is set (meaning we were in a server-auth game), emit `rejoin_server_auth` to the server
   - On `rejoin_success`: re-show the game container, re-enable key listener, and let rendering continue (the server_render_state events will start flowing again once back in the room)
   - On `rejoin_failed`: treat as disconnection -- show error, redirect

7. Add socket handlers for `rejoin_success` and `rejoin_failed` near the other game event handlers.
  </action>
  <verify>
    - Grep for `rejoin_server_auth` in app.py confirms the handler exists
    - Grep for `_disconnect_timeouts` in game_manager.py confirms timeout tracking
    - Grep for `_permanent_drop` in game_manager.py confirms permanent drop method
    - Grep for `rejoin_server_auth` in index.js confirms client reconnection logic
    - Grep for `rejoin_success` in index.js confirms success handler
  </verify>
  <done>
    - Server tracks disconnect timeouts for server-auth players
    - After timeout expiry, player is permanently dropped (slot stays on default actions)
    - Client can reconnect to running server-auth game via rejoin_server_auth event
    - On rejoin, client receives current state and starts rendering (no burst of history)
    - Disconnect UX matches P2P mode's existing behavior
  </done>
</task>

</tasks>

<verification>
1. Grep for `clearStateBuffer` in index.js -- imported and used in game_reset and end_game
2. Grep for `rejoin_server_auth` in app.py and index.js -- handlers exist on both sides
3. Grep for `_disconnect_timeouts` in game_manager.py -- timeout tracking initialized and used
4. Grep for `_permanent_drop` in game_manager.py -- drop method exists
5. The game_reset handler has explicit server-auth branch (flushes buffer, shows countdown, emits reset_complete)
6. The end_game handler cleans up server-auth state (flags, buffer)
</verification>

<success_criteria>
- Episode reset flushes buffer and matches P2P countdown behavior
- Game complete follows same post-game flow as P2P
- Client can reconnect to running server-auth game
- Configurable disconnect timeout with permanent drop
- No regression to P2P mode (all changes gated behind serverAuthoritative checks)
</success_criteria>

<output>
After completion, create `.planning/phases/94-client-rendering-and-input/94-02-SUMMARY.md`
</output>
