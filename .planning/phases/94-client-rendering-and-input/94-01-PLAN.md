---
phase: 94-client-rendering-and-input
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - mug/server/static/js/pyodide_multiplayer_game.js
  - mug/server/static/js/index.js
  - mug/server/static/js/phaser_gym_graphics.js
autonomous: true

must_haves:
  truths:
    - "Client receives server_render_state events and queues them in a FIFO buffer"
    - "Client renders buffered states at the scene-configured FPS via the existing Phaser/Worker timer, playing through every frame in order (no skip-to-latest)"
    - "Client freezes on last rendered frame when buffer is empty (no jitter indicator)"
    - "Server-auth mode bypasses Pyodide initialization entirely -- no WASM loading, no package installs"
  artifacts:
    - path: "mug/server/static/js/pyodide_multiplayer_game.js"
      provides: "ServerAuthGame class or server-auth mode branch within MultiplayerPyodideGame"
    - path: "mug/server/static/js/index.js"
      provides: "server_render_state socket handler that feeds incoming states into the buffer"
    - path: "mug/server/static/js/phaser_gym_graphics.js"
      provides: "addStateToBuffer accepts server-auth payloads and processRendering consumes them"
  key_links:
    - from: "mug/server/static/js/index.js"
      to: "phaser_gym_graphics.js addStateToBuffer"
      via: "socket.on('server_render_state') handler"
      pattern: "socket\\.on.*server_render_state"
    - from: "mug/server/static/js/phaser_gym_graphics.js"
      to: "stateBuffer"
      via: "processRendering reads from stateBuffer at FPS cadence"
      pattern: "stateBuffer"
---

<objective>
Build the client-side state buffer and rendering pipeline for server-authoritative mode. The client receives `server_render_state` socket events from the server, queues them in an unbounded FIFO buffer, and renders them in order at the scene-configured FPS. Server-auth mode bypasses Pyodide entirely (no WASM, no Python env).

Purpose: This is the client-side consumer of Phase 93's server broadcast pipeline. Without this, clients have no way to visualize server-authoritative games.

Output: Modified JS files that enable server-auth clients to receive, buffer, and render game state from the server.
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/93-server-pipeline/93-01-SUMMARY.md
@.planning/phases/93-server-pipeline/93-02-SUMMARY.md
@mug/server/static/js/pyodide_multiplayer_game.js
@mug/server/static/js/pyodide_remote_game.js
@mug/server/static/js/phaser_gym_graphics.js
@mug/server/static/js/index.js
@mug/scenes/gym_scene.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add server-auth state buffer and rendering mode to client JS</name>
  <files>
    mug/server/static/js/index.js
    mug/server/static/js/phaser_gym_graphics.js
  </files>
  <action>
**index.js changes:**

1. Add a `socket.on('server_render_state', ...)` handler near the existing `socket.on('environment_state', ...)` handler (around line 1210). The handler should:
   - Extract `render_state` from the event data (the Phaser-compatible state dict from `env.render(render_mode="interactive_gym")`)
   - Call `addStateToBuffer()` with the full data payload (which includes `render_state`, `step`, `episode`, `rewards`, `cumulative_rewards`, `hud_text`)
   - Update the HUD text if `hud_text` is present: `$('#hudText').show(); $('#hudText').text(data.hud_text);`

2. In the `socket.on('start_game', ...)` handler (line 840), detect server-auth mode from `scene_metadata.server_authoritative`. When true:
   - Do NOT pass `pyodideRemoteGame` in `graphics_config` (set `pyodide_remote_game: null` in the config)
   - Set a module-level flag `window.serverAuthoritative = true` so other handlers can check it
   - Still call `ui_utils.enableKeyListener(scene_metadata.input_mode)` and `graphics_start(graphics_config)` as normal
   - The FPS is already configured from `scene_metadata.fps` in the Phaser config

**phaser_gym_graphics.js changes:**

1. Remove the `MAX_BUFFER_SIZE = 1` cap from the `addStateToBuffer` function (line 15-21). The buffer should be unbounded per user decision ("No buffer cap: play every frame, no dropping"). Change to:
   ```js
   export function addStateToBuffer(state_data) {
       stateBuffer.push(state_data);
   }
   ```

2. In `addStateToBuffer`, normalize the incoming data format. Server-auth payloads have `render_state` as the state dict (list of sprite objects). The buffer should store objects in the format that `processRendering` / `drawState` already expects. The server sends `{render_state: [...], step: N, episode: N, rewards: {...}, ...}`. The existing `environment_state` handler already calls `addStateToBuffer` with a similar shape. Ensure the `render_state` field maps to `game_state_objects` when consumed:
   ```js
   export function addStateToBuffer(state_data) {
       // Normalize: server_render_state sends render_state, existing path sends game_state_objects
       if (state_data.render_state && !state_data.game_state_objects) {
           state_data.game_state_objects = state_data.render_state;
       }
       stateBuffer.push(state_data);
   }
   ```

3. In the `GymScene.update()` method (line 415), when `pyodide_remote_game` is null (server-auth mode), skip the `processPyodideGame()` call entirely and only call `processRendering()`. The existing code already has a guard for `this.pyodide_remote_game` being truthy before calling processPyodideGame, so this should work naturally. However, verify that `processRendering()` correctly consumes from `stateBuffer` when `pyodide_remote_game` is null.

4. In `processRendering()` (find it -- it's the method that shifts from stateBuffer and calls drawState), ensure it works standalone without pyodide_remote_game. It should shift the next state from stateBuffer if available, and if the buffer is empty, do nothing (freeze on last frame). This matches the user decision: "On network jitter: freeze on last rendered frame, no indicator."
  </action>
  <verify>
    - Grep for `server_render_state` in index.js confirms the handler exists
    - Grep for `MAX_BUFFER_SIZE` in phaser_gym_graphics.js returns no results (cap removed)
    - Grep for `serverAuthoritative` in index.js confirms the flag is set in start_game handler
    - The addStateToBuffer function has the render_state normalization logic
  </verify>
  <done>
    - server_render_state socket handler exists and feeds states into the buffer
    - Buffer is unbounded (no MAX_BUFFER_SIZE cap)
    - Server-auth mode sets window.serverAuthoritative flag and skips pyodide_remote_game in graphics config
    - processRendering consumes from buffer at Phaser FPS and freezes when buffer is empty
  </done>
</task>

<task type="auto">
  <name>Task 2: Add server-auth input sending from client to server</name>
  <files>
    mug/server/static/js/index.js
    mug/server/static/js/phaser_gym_graphics.js
  </files>
  <action>
**Sending actions on keypress (index.js or phaser_gym_graphics.js):**

The user decision says: "Send actions immediately on keypress -- no batching or sampling at render tick intervals." The existing input infrastructure (`ui_utils.enableKeyListener` with `PressedKeys`/`SingleKeypress` modes) already handles key events.

1. In `index.js`, find where key events are currently handled. The existing P2P path uses `pyodide_player_action` socket events sent from `pyodide_multiplayer_game.js` (line 6840). For server-auth mode, we need to send `player_action` events instead.

2. Add a keydown/keyup integration for server-auth mode. The approach: hook into the existing `ui_utils` key listener infrastructure. When `window.serverAuthoritative === true`, send a `player_action` socket event on each keypress:
   ```js
   socket.emit('player_action', {
       key: keyName,
       game_id: window.currentGameId  // need to track this
   });
   ```

3. To track the game_id, in the `start_game` handler, store `window.currentGameId = gameStartData.game_id`.

4. For the actual key event hook: examine `ui_utils.enableKeyListener` to understand how it captures keys. It likely sets up `keydown`/`keyup` handlers that populate `pressedKeys` or `humanKeyPressBuffer`. For server-auth mode, we need to emit `player_action` from the key handler.

   Look at `ui_utils.js` to find `enableKeyListener`. Add a server-auth branch: when `window.serverAuthoritative` is true, the keydown handler should also emit `player_action` to the server. For `PressedKeys` mode, emit on every keydown. For `SingleKeypress` mode, emit once per key press.

5. The server's `on_player_action` handler (app.py line 1753) already expects `{key: str, game_id: str}` and maps the key via `scene.action_mapping`. So the client just needs to send the raw key name (e.g., "ArrowUp", "a").

6. Configurable N-frame input delay (default 0): For now, the default is 0 frames (no artificial delay), which means send immediately. The input delay mechanism will be a simple frame counter on the client that delays emission by N render frames. Since default is 0, just add the plumbing:
   - Store `window.serverAuthInputDelay = scene_metadata.input_delay || 0` in the start_game handler
   - If delay is 0, send immediately. If > 0, queue the action and emit it N frames later. Since this is an edge case (default 0), implement the queueing mechanism but keep it simple: maintain a small queue `[{key, emitAtFrame}]` and on each render tick, emit any actions whose emitAtFrame <= currentFrame.
  </action>
  <verify>
    - Grep for `player_action` in index.js or ui_utils.js confirms the emit call exists
    - Grep for `currentGameId` in index.js confirms game_id is tracked
    - Grep for `serverAuthInputDelay` confirms input delay plumbing exists
  </verify>
  <done>
    - Client sends player_action socket events on keypress when in server-auth mode
    - Game ID is tracked from start_game event and included in player_action payloads
    - Input delay plumbing exists (default 0 = immediate send)
    - Input mode (PressedKeys/SingleKeypress) works identically to P2P mode
  </done>
</task>

</tasks>

<verification>
1. Grep for `server_render_state` in JS files -- handler exists in index.js
2. Grep for `player_action` emit in JS files -- client sends actions
3. Grep for `MAX_BUFFER_SIZE` in phaser_gym_graphics.js -- returns nothing (removed)
4. Grep for `serverAuthoritative` in index.js -- flag is set and checked
5. No references to `loadPyodide` or `micropip` in server-auth code paths
</verification>

<success_criteria>
- Client can receive server_render_state events and queue them
- Client renders buffered states at scene FPS (no skip, no drop)
- Client sends player_action events on keypress
- Server-auth mode does not load Pyodide
- Input delay plumbing exists (default 0)
</success_criteria>

<output>
After completion, create `.planning/phases/94-client-rendering-and-input/94-01-SUMMARY.md`
</output>
