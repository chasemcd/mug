---
phase: 94-client-rendering-and-input
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - mug/server/static/js/index.js
  - mug/server/static/js/phaser_gym_graphics.js
  - mug/server/static/js/ui_utils.js
autonomous: true

must_haves:
  truths:
    - "Client receives server_render_state events and queues them in a FIFO buffer"
    - "Client renders buffered states at the scene-configured FPS via the existing Phaser/Worker timer, playing through every frame in order (no skip-to-latest)"
    - "Client freezes on last rendered frame when buffer is empty (no jitter indicator)"
    - "Server-auth mode bypasses Pyodide initialization entirely -- no WASM loading, no package installs"
  artifacts:
    - path: "mug/server/static/js/index.js"
      provides: "server_render_state socket handler that feeds incoming states into the buffer; server-auth mode detection in start_game"
    - path: "mug/server/static/js/phaser_gym_graphics.js"
      provides: "addStateToBuffer accepts server-auth payloads and processRendering consumes them; input delay queue and dequeue logic"
    - path: "mug/server/static/js/ui_utils.js"
      provides: "server-auth keydown handler that emits player_action socket events"
  key_links:
    - from: "mug/server/static/js/index.js"
      to: "phaser_gym_graphics.js addStateToBuffer"
      via: "socket.on('server_render_state') handler"
      pattern: "socket\\.on.*server_render_state"
    - from: "mug/server/static/js/phaser_gym_graphics.js"
      to: "stateBuffer"
      via: "processRendering reads from stateBuffer at FPS cadence"
      pattern: "stateBuffer"
    - from: "mug/server/static/js/ui_utils.js"
      to: "socket.emit player_action"
      via: "_emitOrQueueAction routes keypress to immediate emit or delay queue"
      pattern: "_emitOrQueueAction"
    - from: "mug/server/static/js/phaser_gym_graphics.js"
      to: "ui_utils.js drainInputDelayQueue"
      via: "processRendering calls drainInputDelayQueue when delay > 0"
      pattern: "drainInputDelayQueue"
---

<objective>
Build the client-side state buffer and rendering pipeline for server-authoritative mode. The client receives `server_render_state` socket events from the server, queues them in an unbounded FIFO buffer, and renders them in order at the scene-configured FPS. Server-auth mode bypasses Pyodide entirely (no WASM, no Python env).

Architecture note: Per user decision, shared logic is factored so both P2P and server-auth execute the same code paths. The rendering pipeline (`addStateToBuffer`, `processRendering`, `drawState`) in `phaser_gym_graphics.js` is already shared -- both modes push to `stateBuffer` and render identically. The `window.serverAuthoritative` flag gates only initialization (skip Pyodide) and input transport (emit `player_action` instead of P2P action sync). No separate client is built; `pyodide_multiplayer_game.js` is untouched since its P2P-specific logic (Pyodide init, action sync, rollback) is simply not instantiated in server-auth mode.

Purpose: This is the client-side consumer of Phase 93's server broadcast pipeline. Without this, clients have no way to visualize server-authoritative games.

Output: Modified JS files that enable server-auth clients to receive, buffer, and render game state from the server.
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/93-server-pipeline/93-01-SUMMARY.md
@.planning/phases/93-server-pipeline/93-02-SUMMARY.md
@mug/server/static/js/pyodide_multiplayer_game.js
@mug/server/static/js/pyodide_remote_game.js
@mug/server/static/js/phaser_gym_graphics.js
@mug/server/static/js/index.js
@mug/server/static/js/ui_utils.js
@mug/scenes/gym_scene.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add server-auth state buffer and rendering mode to client JS</name>
  <files>
    mug/server/static/js/index.js
    mug/server/static/js/phaser_gym_graphics.js
  </files>
  <action>
**index.js changes:**

1. Add a `socket.on('server_render_state', ...)` handler near the existing `socket.on('environment_state', ...)` handler (around line 1210). The handler should:
   - Extract `render_state` from the event data (the Phaser-compatible state dict from `env.render(render_mode="interactive_gym")`)
   - Call `addStateToBuffer()` with the full data payload (which includes `render_state`, `step`, `episode`, `rewards`, `cumulative_rewards`, `hud_text`)
   - Update the HUD text if `hud_text` is present: `$('#hudText').show(); $('#hudText').text(data.hud_text);`

2. In the `socket.on('start_game', ...)` handler (line 840), detect server-auth mode from `scene_metadata.server_authoritative`. When true:
   - Do NOT pass `pyodideRemoteGame` in `graphics_config` (set `pyodide_remote_game: null` in the config)
   - Set a module-level flag `window.serverAuthoritative = true` so other handlers can check it
   - Still call `ui_utils.enableKeyListener(scene_metadata.input_mode)` and `graphics_start(graphics_config)` as normal
   - The FPS is already configured from `scene_metadata.fps` in the Phaser config

**phaser_gym_graphics.js changes:**

1. Remove the `MAX_BUFFER_SIZE = 1` cap from the `addStateToBuffer` function (line 15-21). The buffer should be unbounded per user decision ("No buffer cap: play every frame, no dropping"). Change to:
   ```js
   export function addStateToBuffer(state_data) {
       stateBuffer.push(state_data);
   }
   ```

2. In `addStateToBuffer`, normalize the incoming data format. Server-auth payloads have `render_state` as the state dict (list of sprite objects). The buffer should store objects in the format that `processRendering` / `drawState` already expects. The server sends `{render_state: [...], step: N, episode: N, rewards: {...}, ...}`. The existing `environment_state` handler already calls `addStateToBuffer` with a similar shape. Ensure the `render_state` field maps to `game_state_objects` when consumed:
   ```js
   export function addStateToBuffer(state_data) {
       // Normalize: server_render_state sends render_state, existing path sends game_state_objects
       if (state_data.render_state && !state_data.game_state_objects) {
           state_data.game_state_objects = state_data.render_state;
       }
       stateBuffer.push(state_data);
   }
   ```

3. In the `GymScene.update()` method (line 415), when `pyodide_remote_game` is null (server-auth mode), skip the `processPyodideGame()` call entirely and only call `processRendering()`. The existing code already has a guard for `this.pyodide_remote_game` being truthy before calling processPyodideGame, so this should work naturally. However, verify that `processRendering()` correctly consumes from `stateBuffer` when `pyodide_remote_game` is null.

4. In `processRendering()` (find it -- it's the method that shifts from stateBuffer and calls drawState), ensure it works standalone without pyodide_remote_game. It should shift the next state from stateBuffer if available, and if the buffer is empty, do nothing (freeze on last frame). This matches the user decision: "On network jitter: freeze on last rendered frame, no indicator."
  </action>
  <verify>
    - Grep for `server_render_state` in index.js confirms the handler exists
    - Grep for `MAX_BUFFER_SIZE` in phaser_gym_graphics.js returns no results (cap removed)
    - Grep for `serverAuthoritative` in index.js confirms the flag is set in start_game handler
    - The addStateToBuffer function has the render_state normalization logic
  </verify>
  <done>
    - server_render_state socket handler exists and feeds states into the buffer
    - Buffer is unbounded (no MAX_BUFFER_SIZE cap)
    - Server-auth mode sets window.serverAuthoritative flag and skips pyodide_remote_game in graphics config
    - processRendering consumes from buffer at Phaser FPS and freezes when buffer is empty
  </done>
</task>

<task type="auto">
  <name>Task 2: Add server-auth input sending from client to server</name>
  <files>
    mug/server/static/js/ui_utils.js
    mug/server/static/js/index.js
    mug/server/static/js/phaser_gym_graphics.js
  </files>
  <action>
**Sending actions on keypress (ui_utils.js):**

The user decision says: "Send actions immediately on keypress -- no batching or sampling at render tick intervals." The existing input infrastructure (`ui_utils.enableKeyListener` with `PressedKeys`/`SingleKeypress` modes) in `ui_utils.js` (line 22) already handles key events via jQuery `keydown`/`keyup` handlers. The `socket` variable is already module-scoped in `ui_utils.js` (line 3).

1. In `index.js`, in the `start_game` handler (line 840), store `window.currentGameId = gameStartData.game_id` so it is available to the key handler.

2. In `ui_utils.js`, modify `enableKeyListener` (line 22) to add server-auth action sending. The function already receives `input_mode` ("single_keystroke" or "pressed_keys"). Add the server-auth branch inside both the `single_keystroke` and `pressed_keys` keydown handlers:

   **For `single_keystroke` mode (line 37):** After the existing `addHumanKeyPressToBuffer` and `send_pressed_keys` emit, add:
   ```js
   if (window.serverAuthoritative) {
       _emitOrQueueAction(event.key);
   }
   ```

   **For `pressed_keys` mode (line 48):** After `pressedKeys[event.key] = true`, add:
   ```js
   if (window.serverAuthoritative) {
       _emitOrQueueAction(event.key);
   }
   ```

   The server's `on_player_action` handler (app.py) already expects `{key: str, game_id: str}` and maps the key via `scene.action_mapping`. So the client sends the raw key name (e.g., "ArrowUp", "a").

3. **Input delay queue** (CLNT-03): Add the `_emitOrQueueAction` helper function and supporting state at module scope in `ui_utils.js`:

   **Module-level state (near line 20, after `pressedKeys`):**
   ```js
   // Server-auth input delay queue (CLNT-03)
   // When inputDelay > 0, actions are queued and emitted N render frames later.
   // When inputDelay === 0 (default), actions emit immediately.
   var serverAuthInputDelay = 0;       // Set from scene_metadata in start_game
   var inputDelayQueue = [];            // Items: {key: string, emitAtFrame: number}
   var serverAuthFrameCounter = 0;     // Incremented each processRendering() call
   ```

   **Helper function (after enableKeyListener):**
   ```js
   function _emitOrQueueAction(keyName) {
       if (serverAuthInputDelay === 0) {
           // Default: emit immediately, no delay
           socket.emit('player_action', {
               key: keyName,
               game_id: window.currentGameId
           });
       } else {
           // Queue for delayed emission
           inputDelayQueue.push({
               key: keyName,
               emitAtFrame: serverAuthFrameCounter + serverAuthInputDelay
           });
       }
   }
   ```

   **Exported setter for configuration (called from index.js start_game handler):**
   ```js
   export function setServerAuthInputDelay(delayFrames) {
       serverAuthInputDelay = delayFrames;
       inputDelayQueue = [];
       serverAuthFrameCounter = 0;
   }
   ```

   **Exported drain function (called from phaser_gym_graphics.js processRendering on each render tick):**
   ```js
   export function drainInputDelayQueue() {
       serverAuthFrameCounter++;
       let i = 0;
       while (i < inputDelayQueue.length) {
           if (inputDelayQueue[i].emitAtFrame <= serverAuthFrameCounter) {
               socket.emit('player_action', {
                   key: inputDelayQueue[i].key,
                   game_id: window.currentGameId
               });
               inputDelayQueue.splice(i, 1);
           } else {
               i++;
           }
       }
   }
   ```

4. In `index.js` `start_game` handler, configure the delay:
   ```js
   window.serverAuthInputDelay = scene_metadata.input_delay || 0;
   ui_utils.setServerAuthInputDelay(window.serverAuthInputDelay);
   ```

5. In `phaser_gym_graphics.js` `processRendering()` (line 738), at the top of the method, when `window.serverAuthoritative` is true and `serverAuthInputDelay > 0`, call `ui_utils.drainInputDelayQueue()` to process any queued delayed actions:
   ```js
   if (window.serverAuthoritative && window.serverAuthInputDelay > 0) {
       ui_utils.drainInputDelayQueue();
   }
   ```
   Import `drainInputDelayQueue` from `ui_utils.js` at the top of `phaser_gym_graphics.js`.
  </action>
  <verify>
    - Grep for `player_action` in ui_utils.js confirms the emit call exists
    - Grep for `currentGameId` in index.js confirms game_id is tracked
    - Grep for `serverAuthInputDelay` in ui_utils.js confirms delay state and setter
    - Grep for `inputDelayQueue` in ui_utils.js confirms queue data structure
    - Grep for `drainInputDelayQueue` in phaser_gym_graphics.js confirms dequeue integration
    - Grep for `_emitOrQueueAction` in ui_utils.js confirms the routing function
    - To test delay > 0: set `scene_metadata.input_delay = 3` in scene config, verify in browser console that `inputDelayQueue` accumulates items and they emit 3 render frames later
  </verify>
  <done>
    - Client sends player_action socket events on keypress when in server-auth mode
    - Game ID is tracked from start_game event and included in player_action payloads
    - Input delay queue in ui_utils.js: items are `{key: string, emitAtFrame: number}`, frame counter incremented in processRendering, dequeue emits when `emitAtFrame <= serverAuthFrameCounter`
    - When delay is 0 (default), actions emit immediately with no queue overhead
    - When delay > 0, actions queue and drain on each render tick
    - Input mode (PressedKeys/SingleKeypress) works identically to P2P mode
  </done>
</task>

</tasks>

<verification>
1. Grep for `server_render_state` in JS files -- handler exists in index.js
2. Grep for `player_action` emit in JS files -- client sends actions
3. Grep for `MAX_BUFFER_SIZE` in phaser_gym_graphics.js -- returns nothing (removed)
4. Grep for `serverAuthoritative` in index.js -- flag is set and checked
5. No references to `loadPyodide` or `micropip` in server-auth code paths
</verification>

<success_criteria>
- Client can receive server_render_state events and queue them
- Client renders buffered states at scene FPS (no skip, no drop)
- Client sends player_action events on keypress
- Server-auth mode does not load Pyodide
- Input delay plumbing exists (default 0)
</success_criteria>

<output>
After completion, create `.planning/phases/94-client-rendering-and-input/94-01-SUMMARY.md`
</output>
