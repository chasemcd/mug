---
phase: 59-matchmaker-rtt-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/matchmaker.py
  - interactive_gym/server/game_manager.py
  - interactive_gym/server/app.py
autonomous: true

must_haves:
  truths:
    - "Matchmaker constructor accepts max_p2p_rtt_ms threshold parameter"
    - "Match proposal triggers P2P RTT probe before game creation"
    - "Match is rejected and candidates re-pooled if RTT exceeds threshold"
    - "Subclasses can override should_reject_for_rtt() method"
    - "Matches proceed immediately when max_p2p_rtt_ms is None (default)"
  artifacts:
    - path: "interactive_gym/server/matchmaker.py"
      provides: "max_p2p_rtt_ms parameter and should_reject_for_rtt method"
      contains: "max_p2p_rtt_ms"
    - path: "interactive_gym/server/game_manager.py"
      provides: "Probe-then-match orchestration with on_complete callback"
      contains: "_probe_and_create_game"
    - path: "interactive_gym/server/app.py"
      provides: "probe_coordinator passed to GameManager"
      contains: "probe_coordinator"
  key_links:
    - from: "interactive_gym/server/game_manager.py"
      to: "interactive_gym/server/probe_coordinator.py"
      via: "probe_coordinator.create_probe() call"
      pattern: "self\\.probe_coordinator\\.create_probe"
    - from: "interactive_gym/server/game_manager.py"
      to: "interactive_gym/server/matchmaker.py"
      via: "matchmaker.should_reject_for_rtt() call"
      pattern: "self\\.matchmaker\\.should_reject_for_rtt"
---

<objective>
Integrate P2P RTT measurement into the matching flow so match decisions consider actual peer-to-peer latency.

Purpose: Prevent high-latency pairs from being matched together, ensuring research data quality by avoiding latency-induced behavioral artifacts.

Output: GameManager orchestrates probe -> measure -> decide flow; Matchmaker exposes RTT threshold configuration with overridable rejection logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/57-p2p-probe-infrastructure/57-01-SUMMARY.md
@.planning/phases/58-rtt-measurement/58-01-SUMMARY.md

# Key source files
@interactive_gym/server/matchmaker.py
@interactive_gym/server/game_manager.py
@interactive_gym/server/probe_coordinator.py
@interactive_gym/server/app.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add max_p2p_rtt_ms to Matchmaker ABC</name>
  <files>interactive_gym/server/matchmaker.py</files>
  <action>
Add P2P RTT threshold configuration to the Matchmaker ABC:

1. Add `max_p2p_rtt_ms: int | None = None` parameter to Matchmaker.__init__():
   - Store as self.max_p2p_rtt_ms
   - None means no P2P RTT filtering (default behavior)

2. Add `should_reject_for_rtt(self, measured_rtt_ms: float | None) -> bool` method:
   - If self.max_p2p_rtt_ms is None, return False (accept all)
   - If measured_rtt_ms is None (measurement failed), return True (reject on failure)
   - Return measured_rtt_ms > self.max_p2p_rtt_ms
   - This method is NOT abstract - subclasses CAN override but don't have to

3. Update FIFOMatchmaker:
   - Pass max_p2p_rtt_ms to super().__init__()
   - Update docstring to document RTT filtering behavior

4. Update module docstring to explain:
   - max_p2p_rtt_ms is for P2P RTT (peer-to-peer latency via WebRTC DataChannel)
   - This is DIFFERENT from the existing rtt_ms in MatchCandidate (server RTT)
   - P2P RTT filtering happens AFTER matchmaker proposes, not inside find_match()

Example API:
```python
class Matchmaker(ABC):
    def __init__(self, max_p2p_rtt_ms: int | None = None):
        self.max_p2p_rtt_ms = max_p2p_rtt_ms

    def should_reject_for_rtt(self, measured_rtt_ms: float | None) -> bool:
        if self.max_p2p_rtt_ms is None:
            return False
        if measured_rtt_ms is None:
            return True  # Reject on measurement failure
        return measured_rtt_ms > self.max_p2p_rtt_ms
```
  </action>
  <verify>
Run: `python -c "from interactive_gym.server.matchmaker import Matchmaker, FIFOMatchmaker; m = FIFOMatchmaker(max_p2p_rtt_ms=150); print(f'threshold={m.max_p2p_rtt_ms}'); print(f'reject(100)={m.should_reject_for_rtt(100)}'); print(f'reject(200)={m.should_reject_for_rtt(200)}'); print(f'reject(None)={m.should_reject_for_rtt(None)}')"` should output:
- threshold=150
- reject(100)=False
- reject(200)=True
- reject(None)=True
  </verify>
  <done>
Matchmaker ABC has max_p2p_rtt_ms constructor parameter and should_reject_for_rtt() method. FIFOMatchmaker passes threshold to parent. Default behavior (None) accepts all matches.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add probe-then-match orchestration to GameManager</name>
  <files>interactive_gym/server/game_manager.py</files>
  <action>
Add async probe orchestration between matchmaker proposal and game creation:

1. Add `probe_coordinator` parameter to GameManager.__init__():
   - Type: `probe_coordinator: ProbeCoordinator | None = None`
   - Store as self.probe_coordinator
   - Optional for backward compatibility

2. Add `_pending_matches` data structure:
   - Type: `dict[str, dict]` (probe_session_id -> match context)
   - Tracks matches waiting for RTT measurement
   - Context includes: matched candidates, arriving subject_id, timestamp

3. Add `_probe_and_create_game()` method:
   - Called when matchmaker proposes a match AND probe_coordinator exists AND matchmaker.max_p2p_rtt_ms is not None
   - Creates probe between first two matched candidates (for 2-player games)
   - Stores match context in _pending_matches keyed by probe_session_id
   - Calls probe_coordinator.create_probe() with on_complete callback
   - Returns None (game creation is deferred until probe completes)

4. Add `_on_probe_complete()` callback method:
   - Receives: subject_a, subject_b, rtt_ms (None if failed)
   - Looks up match context from _pending_matches
   - Calls matchmaker.should_reject_for_rtt(rtt_ms)
   - If rejected: re-pool candidates to waitroom (log "RTT rejection: {rtt_ms}ms > {threshold}ms")
   - If accepted: proceed with _create_game_for_match()
   - Clean up _pending_matches entry

5. Modify `_add_to_fifo_queue()`:
   - After matchmaker returns matched candidates, check if P2P RTT probe is needed:
     - probe_coordinator is not None
     - matchmaker.max_p2p_rtt_ms is not None
   - If probe needed: call _probe_and_create_game() and return the arriving subject to waitroom temporarily
   - If no probe needed: proceed with existing _create_game_for_match() flow

6. Add `_repool_candidates()` helper method:
   - Takes list of MatchCandidates that were rejected
   - For each candidate already in waitroom, leave them there
   - For any candidate that was removed, add them back
   - Log the re-pooling action

Important: The arriving participant goes to the waitroom immediately (via _add_to_waitroom) while the probe runs. If probe succeeds, they get moved to the new game. If probe fails/rejects, they stay in the waitroom for future matching.

Import ProbeCoordinator at top of file (with TYPE_CHECKING guard to avoid circular imports).
  </action>
  <verify>
Run: `grep -n "probe_coordinator" interactive_gym/server/game_manager.py | head -5` shows probe_coordinator parameter and storage.
Run: `grep -n "_pending_matches\|_probe_and_create_game\|_on_probe_complete\|_repool_candidates" interactive_gym/server/game_manager.py` shows all new methods exist.
  </verify>
  <done>
GameManager has probe_coordinator parameter, _pending_matches tracking, and probe-then-match orchestration via _probe_and_create_game() with callback _on_probe_complete(). RTT rejection triggers re-pooling of candidates.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire ProbeCoordinator into GameManager in app.py</name>
  <files>interactive_gym/server/app.py</files>
  <action>
Connect the existing PROBE_COORDINATOR to GameManager:

1. Find where GameManager is instantiated (look for `GameManager(` in the file)

2. Add `probe_coordinator=PROBE_COORDINATOR` to the GameManager constructor call

3. Verify PROBE_COORDINATOR is already initialized (from Phase 57):
   - Import exists: `from interactive_gym.server.probe_coordinator import ProbeCoordinator`
   - Global exists: `PROBE_COORDINATOR = None`
   - Initialization in run(): `PROBE_COORDINATOR = ProbeCoordinator(...)`

No other changes needed - the SocketIO handlers for probe_ready, probe_signal, probe_result are already wired from Phase 57.
  </action>
  <verify>
Run: `grep -n "probe_coordinator=PROBE_COORDINATOR" interactive_gym/server/app.py` shows the wiring.
Run: `grep -n "PROBE_COORDINATOR" interactive_gym/server/app.py` shows both the global and the GameManager wiring.
  </verify>
  <done>
PROBE_COORDINATOR passed to GameManager, completing the integration. RTT probes can now be triggered during matching.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Unit verification** - Import and instantiate components:
```bash
python -c "
from interactive_gym.server.matchmaker import Matchmaker, FIFOMatchmaker
from interactive_gym.server.game_manager import GameManager

# Test matchmaker RTT rejection
m = FIFOMatchmaker(max_p2p_rtt_ms=150)
print(f'Threshold: {m.max_p2p_rtt_ms}')
print(f'Reject 100ms: {m.should_reject_for_rtt(100)}')  # False
print(f'Reject 200ms: {m.should_reject_for_rtt(200)}')  # True
print(f'Reject None: {m.should_reject_for_rtt(None)}')  # True

# Default matchmaker has no threshold
m_default = FIFOMatchmaker()
print(f'Default threshold: {m_default.max_p2p_rtt_ms}')
print(f'Default reject any: {m_default.should_reject_for_rtt(1000)}')  # False
"
```

2. **Integration smoke test** - Verify wiring doesn't break server start:
```bash
cd /Users/chasemcd/Repositories/interactive-gym
timeout 5 python -c "
from interactive_gym.server.app import create_app
# Just import, don't run server
print('Imports successful')
" || true
```

3. **Code structure verification**:
```bash
# Matchmaker has RTT methods
grep -c "max_p2p_rtt_ms\|should_reject_for_rtt" interactive_gym/server/matchmaker.py

# GameManager has probe integration
grep -c "probe_coordinator\|_pending_matches\|_probe_and_create_game" interactive_gym/server/game_manager.py

# App wires coordinator
grep "probe_coordinator=PROBE_COORDINATOR" interactive_gym/server/app.py
```
</verification>

<success_criteria>
- [ ] Matchmaker.__init__ accepts max_p2p_rtt_ms parameter
- [ ] Matchmaker.should_reject_for_rtt() method exists and is overridable
- [ ] FIFOMatchmaker passes max_p2p_rtt_ms to parent
- [ ] GameManager accepts probe_coordinator parameter
- [ ] GameManager._probe_and_create_game() triggers probe before game creation
- [ ] GameManager._on_probe_complete() handles RTT rejection with re-pooling
- [ ] PROBE_COORDINATOR passed to GameManager in app.py
- [ ] Default behavior (no threshold) creates games immediately without probing
</success_criteria>

<output>
After completion, create `.planning/phases/59-matchmaker-rtt-integration/59-01-SUMMARY.md`
</output>
