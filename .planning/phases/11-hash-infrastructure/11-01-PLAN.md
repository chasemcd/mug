---
phase: 11-hash-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/static/js/pyodide_multiplayer_game.js
autonomous: true
user_setup: []

must_haves:
  truths:
    - "State hash is computed using SHA-256 (not MD5)"
    - "Floats are normalized to 10 decimal places before hashing"
    - "Hashes are stored only for confirmed frames (not predicted)"
    - "confirmedHashHistory tracks frame-to-hash mapping"
    - "Hash history is invalidated when rollback occurs"
    - "Hash history is pruned to prevent memory growth"
  artifacts:
    - path: "interactive_gym/server/static/js/pyodide_multiplayer_game.js"
      provides: "SHA-256 hashing, float normalization, confirmedHashHistory, hash invalidation on rollback"
      contains: "confirmedHashHistory"
  key_links:
    - from: "computeQuickStateHash()"
      to: "env.get_state()"
      via: "Python hashlib.sha256"
      pattern: "hashlib\\.sha256"
    - from: "performRollback()"
      to: "confirmedHashHistory"
      via: "hash invalidation"
      pattern: "confirmedHashHistory\\.delete"
    - from: "_updateConfirmedFrame()"
      to: "confirmedHashHistory"
      via: "hash computation trigger"
      pattern: "_computeAndStoreConfirmedHash"
---

<objective>
Implement deterministic state hashing infrastructure for sync validation.

Purpose: Enable cross-platform state verification by computing SHA-256 hashes of confirmed game states with proper float normalization, laying the foundation for P2P hash exchange and mismatch detection in subsequent phases.

Output: Updated `pyodide_multiplayer_game.js` with:
- SHA-256 hashing (replacing MD5)
- Float normalization to 10 decimal places
- `confirmedHashHistory` Map for confirmed frame hashes
- `_updateConfirmedFrame()` logic for tracking confirmation
- Hash invalidation during rollback
- History pruning to prevent memory growth
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/SUMMARY.md
@.planning/research/ARCHITECTURE.md

Key existing code in pyodide_multiplayer_game.js:
- `computeQuickStateHash()` at ~line 1902: Currently uses MD5, needs SHA-256
- `stateHashHistory` at ~line 507: Existing map for predicted frame hashes (keep for legacy)
- `confirmedFrame` at ~line 434, 522: Tracks last frame with all inputs confirmed
- `performRollback()` at ~line 2689: Core rollback operation - needs hash invalidation
- `inputBuffer` at ~line 438: Map<frameNumber, Map<playerId, action>> - used to check confirmation
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add confirmedHashHistory data structure and update computeQuickStateHash to SHA-256</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
1. In the constructor (around line 505-510, near existing `stateHashHistory`), add:
   ```javascript
   // Confirmed hash history: hashes for frames where ALL players' inputs are confirmed
   // This is separate from stateHashHistory which may include predicted frames
   this.confirmedHashHistory = new Map();  // frameNumber -> hash (SHA-256 truncated)
   this.confirmedHashHistoryMaxSize = 120;  // Keep ~4 seconds at 30fps
   ```

2. Update `computeQuickStateHash()` (around line 1902) to:
   - Use SHA-256 instead of MD5 for cross-platform reliability
   - Add float normalization to 10 decimal places before JSON serialization
   - Truncate to 16 hex chars for efficient storage/transmission

   Updated Python code inside the function:
   ```python
   import json
   import hashlib

   def _normalize_floats(obj, precision=10):
       """Recursively normalize floats to fixed precision for deterministic hashing."""
       if isinstance(obj, float):
           return round(obj, precision)
       elif isinstance(obj, dict):
           return {k: _normalize_floats(v, precision) for k, v in obj.items()}
       elif isinstance(obj, (list, tuple)):
           return [_normalize_floats(item, precision) for item in obj]
       return obj

   _env_state_for_hash = env.get_state()
   _normalized_state = _normalize_floats(_env_state_for_hash)

   # SHA-256 hash with deterministic JSON serialization
   _json_str = json.dumps(_normalized_state, sort_keys=True, separators=(',', ':'))
   _hash = hashlib.sha256(_json_str.encode()).hexdigest()[:16]
   _hash
   ```

3. Update the JSDoc comment to reflect SHA-256 usage and float normalization.

IMPORTANT: Keep the existing MD5-based logic in comments or as fallback for reference during transition. The existing `stateHashHistory` stays as-is (it serves legacy/predicted frame tracking).
  </action>
  <verify>
- Search for "sha256" in the file to confirm SHA-256 is used
- Search for "_normalize_floats" to confirm float normalization is added
- Search for "confirmedHashHistory" to confirm the new Map is declared
- Run `node -e "console.log('syntax check')"` to verify no JavaScript syntax errors
  </verify>
  <done>
- computeQuickStateHash() uses SHA-256 (HASH-03)
- Float normalization to 10 decimal places before hashing (HASH-02)
- confirmedHashHistory Map declared in constructor (HASH-04)
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement _updateConfirmedFrame and _computeAndStoreConfirmedHash</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Add two new methods after the existing `getStateHashForFrame()` method (around line 1900):

1. `_hasAllInputsForFrame(frameNumber, playerIds)`:
   ```javascript
   /**
    * Check if all specified players have confirmed inputs for a frame.
    * @param {number} frameNumber - Frame to check
    * @param {Array<string>} playerIds - Player IDs to check
    * @returns {boolean} True if all players have inputs for this frame
    */
   _hasAllInputsForFrame(frameNumber, playerIds) {
       const frameInputs = this.inputBuffer.get(frameNumber);
       if (!frameInputs) return false;

       for (const playerId of playerIds) {
           if (!frameInputs.has(String(playerId))) {
               return false;
           }
       }
       return true;
   }
   ```

2. `_updateConfirmedFrame()`:
   ```javascript
   /**
    * Update confirmedFrame to the highest frame where ALL players have confirmed inputs.
    * Called after processing inputs and after rollback completion.
    * Triggers hash computation for newly confirmed frames.
    */
   async _updateConfirmedFrame() {
       const humanPlayerIds = this._getHumanPlayerIds();
       if (humanPlayerIds.length === 0) return;

       // Find highest consecutive confirmed frame
       for (let frame = this.confirmedFrame + 1; frame < this.frameNumber; frame++) {
           if (this._hasAllInputsForFrame(frame, humanPlayerIds)) {
               // This frame is now confirmed (all inputs received)
               this.confirmedFrame = frame;

               // Remove from predictedFrames if it was there
               this.predictedFrames.delete(frame);

               // Compute and store hash for this confirmed frame
               await this._computeAndStoreConfirmedHash(frame);
           } else {
               // Gap in confirmation - stop here
               break;
           }
       }
   }
   ```

3. `_computeAndStoreConfirmedHash(frameNumber)`:
   ```javascript
   /**
    * Compute and store hash for a confirmed frame.
    * Only called when frame is fully confirmed (all inputs received, no rollback pending).
    * @param {number} frameNumber - The confirmed frame to hash
    */
   async _computeAndStoreConfirmedHash(frameNumber) {
       // Skip if hash already exists (e.g., from prior confirmation)
       if (this.confirmedHashHistory.has(frameNumber)) {
           return;
       }

       // Skip if state sync not supported
       if (!this.stateSyncSupported) {
           return;
       }

       try {
           const hash = await this.computeQuickStateHash();
           this.confirmedHashHistory.set(frameNumber, hash);

           p2pLog.debug(`Confirmed hash for frame ${frameNumber}: ${hash}`);

           // Prune old entries to prevent unbounded growth
           this._pruneConfirmedHashHistory();
       } catch (e) {
           p2pLog.warn(`Failed to compute confirmed hash for frame ${frameNumber}: ${e}`);
       }
   }
   ```

4. `_pruneConfirmedHashHistory()`:
   ```javascript
   /**
    * Remove old entries from confirmedHashHistory to prevent memory growth.
    * Keeps most recent confirmedHashHistoryMaxSize entries.
    */
   _pruneConfirmedHashHistory() {
       if (this.confirmedHashHistory.size <= this.confirmedHashHistoryMaxSize) {
           return;
       }

       // Map maintains insertion order - delete oldest entries
       const keysToDelete = [];
       for (const key of this.confirmedHashHistory.keys()) {
           if (this.confirmedHashHistory.size - keysToDelete.length <= this.confirmedHashHistoryMaxSize) {
               break;
           }
           keysToDelete.push(key);
       }
       for (const key of keysToDelete) {
           this.confirmedHashHistory.delete(key);
       }
   }
   ```

5. Add helper method `_getHumanPlayerIds()` if not already present:
   ```javascript
   /**
    * Get list of human player IDs from policy mapping.
    * @returns {Array<string>} Array of player IDs where policy is 'human'
    */
   _getHumanPlayerIds() {
       const humanIds = [];
       for (const [agentId, policy] of Object.entries(this.policyMapping)) {
           if (policy === 'human') {
               humanIds.push(String(agentId));
           }
       }
       return humanIds;
   }
   ```

IMPORTANT: These methods implement HASH-01 (compute hash only on confirmed frames). The hash is computed ONLY when `_updateConfirmedFrame()` detects a newly confirmed frame.
  </action>
  <verify>
- Search for "_updateConfirmedFrame" to confirm method exists
- Search for "_computeAndStoreConfirmedHash" to confirm method exists
- Search for "_hasAllInputsForFrame" to confirm method exists
- Search for "_pruneConfirmedHashHistory" to confirm method exists
  </verify>
  <done>
- _updateConfirmedFrame() tracks confirmation and triggers hashing (HASH-01)
- _computeAndStoreConfirmedHash() computes and stores hash for confirmed frames
- _pruneConfirmedHashHistory() prevents memory growth
- confirmedHashHistory is properly populated with frame-to-hash mapping (HASH-04)
  </done>
</task>

<task type="auto">
  <name>Task 3: Add hash invalidation to performRollback and integrate _updateConfirmedFrame into step loop</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
1. In `performRollback()` (around line 2689), add hash invalidation AFTER the rollback guard is set but BEFORE restoring snapshot:
   ```javascript
   // Set rollback guard to prevent nested rollbacks
   this.rollbackInProgress = true;

   // NEW: Invalidate confirmed hashes from rollback point onward
   // These hashes are for states that are about to be overwritten
   for (const frame of this.confirmedHashHistory.keys()) {
       if (frame >= targetFrame) {
           this.confirmedHashHistory.delete(frame);
       }
   }
   p2pLog.debug(`Invalidated confirmed hashes >= frame ${targetFrame}`);

   // Also reset confirmedFrame to before rollback point
   // (it will be recalculated after replay completes)
   this.confirmedFrame = Math.min(this.confirmedFrame, targetFrame - 1);
   ```

2. In the `step()` method, add call to `_updateConfirmedFrame()` AFTER:
   - Processing queued inputs
   - Completing any rollback
   - But BEFORE advancing frameNumber

   Find the section after rollback handling (around line 1436) and add:
   ```javascript
   // After rollback completes (or if no rollback), update confirmed frame tracking
   // This triggers hash computation for any newly confirmed frames
   await this._updateConfirmedFrame();
   ```

3. In `clearGGPOState()` (around line 3050), add clearing of confirmedHashHistory:
   ```javascript
   // Clear confirmed hash history on episode reset
   this.confirmedHashHistory.clear();
   ```

4. Also ensure confirmedHashHistory is cleared in `_resetEpisodeState()` or equivalent reset method if one exists separate from clearGGPOState.

INTEGRATION POINTS:
- The call to _updateConfirmedFrame() should be placed after line ~1436 (after rollback completion check)
- Hash invalidation in performRollback() should be around line ~2702 (after rollbackInProgress = true)
- clearGGPOState() modification should be around line ~3050
  </action>
  <verify>
- Search for "confirmedHashHistory.delete" in performRollback to confirm invalidation
- Search for "_updateConfirmedFrame" in step() to confirm integration
- Search for "confirmedHashHistory.clear" to confirm reset on episode
- Test by running the game and checking console for "Confirmed hash for frame" debug messages
  </verify>
  <done>
- Hash invalidation during rollback clears hashes >= target frame (supports future EXCH-03)
- confirmedFrame is reset appropriately during rollback
- _updateConfirmedFrame() is called in step loop to track confirmation
- confirmedHashHistory is cleared on episode reset
- All HASH requirements (HASH-01, HASH-02, HASH-03, HASH-04) are implemented
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Code verification:**
   - `grep -n "sha256" interactive_gym/server/static/js/pyodide_multiplayer_game.js` shows SHA-256 usage
   - `grep -n "confirmedHashHistory" interactive_gym/server/static/js/pyodide_multiplayer_game.js` shows Map usage in constructor, methods, rollback, and reset
   - `grep -n "_normalize_floats" interactive_gym/server/static/js/pyodide_multiplayer_game.js` shows float normalization
   - `grep -n "_updateConfirmedFrame" interactive_gym/server/static/js/pyodide_multiplayer_game.js` shows method definition and call in step()

2. **Functional verification (manual):**
   - Start a multiplayer game
   - Set `window.p2pLogLevel = 'debug'` in browser console
   - Play for a few frames
   - Observe "[P2P] Confirmed hash for frame N: <hash>" log messages
   - Verify hashes are 16 hex characters (SHA-256 truncated)

3. **Rollback verification (manual):**
   - Set `window.debugRemoteInputDelay = 5` to force rollbacks
   - Observe "Invalidated confirmed hashes >= frame N" log messages during rollback
</verification>

<success_criteria>
- [ ] computeQuickStateHash() uses hashlib.sha256 (not md5) - HASH-03
- [ ] Float values normalized to 10 decimal places before JSON serialization - HASH-02
- [ ] confirmedHashHistory Map tracks frame -> hash for confirmed frames - HASH-04
- [ ] Hashes computed only for frames where all players have confirmed inputs - HASH-01
- [ ] performRollback() invalidates hashes for frames >= target frame
- [ ] confirmedHashHistory pruned to max 120 entries (4 seconds at 30fps)
- [ ] confirmedHashHistory cleared on episode reset
- [ ] No JavaScript syntax errors
- [ ] Debug logging shows hash computation occurring
</success_criteria>

<output>
After completion, create `.planning/phases/11-hash-infrastructure/11-01-SUMMARY.md` with:
- Requirements addressed (HASH-01 through HASH-04)
- Key code changes made
- Data structures added
- Integration points (step loop, rollback, reset)
- Any deviations from plan
</output>
