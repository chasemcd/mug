---
phase: 57-p2p-probe-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/static/js/probe_connection.js
  - interactive_gym/server/static/js/index.js
autonomous: true

must_haves:
  truths:
    - "Client can receive probe_prepare and create ProbeConnection"
    - "Client can establish WebRTC DataChannel with probe peer"
    - "Client can report probe result to server"
    - "Probe connections are closed after measurement or timeout"
  artifacts:
    - path: "interactive_gym/server/static/js/probe_connection.js"
      provides: "ProbeConnection class wrapping WebRTCManager for probes"
      exports: ["ProbeConnection"]
    - path: "interactive_gym/server/static/js/index.js"
      provides: "ProbeManager integration in client entry point"
      contains: ["probe_prepare", "ProbeConnection"]
  key_links:
    - from: "interactive_gym/server/static/js/probe_connection.js"
      to: "interactive_gym/server/static/js/webrtc_manager.js"
      via: "WebRTCManager instantiation"
      pattern: "new WebRTCManager"
    - from: "interactive_gym/server/static/js/index.js"
      to: "interactive_gym/server/static/js/probe_connection.js"
      via: "ProbeConnection import and instantiation"
      pattern: "ProbeConnection"
---

<objective>
Create client-side P2P probe infrastructure that enables WebRTC connections for RTT measurement.

Purpose: Phase 57 establishes probe connections for RTT measurement. This plan creates the client-side connection wrapper and integrates it with the main application so clients can respond to probe requests from the server.

Output: ProbeConnection class and client integration that enables:
- Receiving probe_prepare events and creating ProbeConnection
- Establishing WebRTC DataChannel with peer
- Measuring RTT and reporting results to server
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/57-p2p-probe-infrastructure/57-RESEARCH.md

@interactive_gym/server/static/js/webrtc_manager.js
@interactive_gym/server/static/js/index.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProbeConnection class</name>
  <files>interactive_gym/server/static/js/probe_connection.js</files>
  <action>
Create the ProbeConnection class as a lightweight wrapper around WebRTCManager for probe-only connections:

```javascript
/**
 * Probe Connection
 *
 * Lightweight WebRTC connection wrapper for P2P RTT probing.
 * Used during matchmaking to measure actual peer-to-peer latency
 * BEFORE a game is created.
 *
 * Wraps WebRTCManager but uses probe-specific signaling events.
 */

import { WebRTCManager } from './webrtc_manager.js';

export class ProbeConnection {
    /**
     * Create a probe connection.
     * @param {Object} socket - SocketIO socket instance
     * @param {string} probeSessionId - Unique probe session identifier
     * @param {string} mySubjectId - This participant's subject_id
     * @param {string} peerSubjectId - Peer participant's subject_id
     * @param {Object} options - Configuration options
     * @param {string} options.turnUsername - TURN server username
     * @param {string} options.turnCredential - TURN server credential
     */
    constructor(socket, probeSessionId, mySubjectId, peerSubjectId, options = {}) {
        this.socket = socket;
        this.probeSessionId = probeSessionId;
        this.mySubjectId = mySubjectId;
        this.peerSubjectId = peerSubjectId;
        this.closed = false;

        // Create WebRTCManager with probe context
        // Use probeSessionId where gameId would go, mySubjectId where playerId would go
        this.webrtcManager = new WebRTCManager(
            socket,
            probeSessionId,
            mySubjectId,
            {
                turnUsername: options.turnUsername,
                turnCredential: options.turnCredential,
                // Don't force relay for probes - we want to find best path
            }
        );

        // Callbacks
        this.onConnected = null;
        this.onFailed = null;
        this.onClosed = null;

        // Timeout for connection establishment (10 seconds)
        this.connectionTimeout = null;
        this.connectionTimeoutMs = 10000;

        this._setupCallbacks();
        this._setupSignaling();
    }

    _setupCallbacks() {
        this.webrtcManager.onDataChannelOpen = () => {
            console.log(`[Probe ${this.probeSessionId}] DataChannel open`);
            this._clearConnectionTimeout();
            this.onConnected?.();
        };

        this.webrtcManager.onConnectionFailed = () => {
            console.log(`[Probe ${this.probeSessionId}] Connection failed`);
            this._clearConnectionTimeout();
            this.onFailed?.();
        };

        this.webrtcManager.onDataChannelClose = () => {
            console.log(`[Probe ${this.probeSessionId}] DataChannel closed`);
            this.onClosed?.();
        };
    }

    _setupSignaling() {
        // Listen for probe-specific signals
        this._boundSignalHandler = (data) => {
            if (data.probe_session_id !== this.probeSessionId) return;

            // Translate probe signal to WebRTCManager signal format
            const webrtcSignal = {
                type: data.type,
                from_player_id: data.from_subject_id,
                game_id: this.probeSessionId,
                payload: data.payload,
            };

            // Pass to WebRTCManager's signal handler
            this.webrtcManager._handleSignal(webrtcSignal);
        };

        this.socket.on('probe_signal', this._boundSignalHandler);
    }

    /**
     * Start the probe connection.
     * Lower subject_id is deterministic initiator (same as game connections).
     */
    start() {
        if (this.closed) {
            console.warn(`[Probe ${this.probeSessionId}] Cannot start - already closed`);
            return;
        }

        console.log(`[Probe ${this.probeSessionId}] Starting connection to ${this.peerSubjectId}`);

        // Set connection timeout
        this.connectionTimeout = setTimeout(() => {
            console.warn(`[Probe ${this.probeSessionId}] Connection timeout`);
            this.onFailed?.();
        }, this.connectionTimeoutMs);

        // Override _sendSignal to use probe events instead of webrtc_signal
        const originalSendSignal = this.webrtcManager._sendSignal.bind(this.webrtcManager);
        this.webrtcManager._sendSignal = (type, payload) => {
            if (this.closed) return;
            this.socket.emit('probe_signal', {
                probe_session_id: this.probeSessionId,
                target_subject_id: this.peerSubjectId,
                type: type,
                payload: payload,
            });
        };

        // WebRTCManager.connectToPeer uses deterministic initiator
        this.webrtcManager.connectToPeer(this.peerSubjectId);
    }

    _clearConnectionTimeout() {
        if (this.connectionTimeout) {
            clearTimeout(this.connectionTimeout);
            this.connectionTimeout = null;
        }
    }

    /**
     * Check if probe connection is ready for measurement.
     * @returns {boolean}
     */
    isReady() {
        return this.webrtcManager.isReady();
    }

    /**
     * Get RTT via WebRTC getStats().
     * @returns {Promise<number|null>} RTT in milliseconds or null if unavailable
     */
    async getRTT() {
        if (!this.webrtcManager.peerConnection) return null;

        try {
            const stats = await this.webrtcManager.peerConnection.getStats();
            let selectedPairId = null;

            // Find transport with selected candidate pair
            stats.forEach(report => {
                if (report.type === 'transport' && report.selectedCandidatePairId) {
                    selectedPairId = report.selectedCandidatePairId;
                }
            });

            if (!selectedPairId) return null;

            // Find RTT from selected pair
            let rtt = null;
            stats.forEach(report => {
                if (report.type === 'candidate-pair' && report.id === selectedPairId) {
                    if (report.currentRoundTripTime !== undefined) {
                        rtt = report.currentRoundTripTime * 1000;  // Convert seconds to ms
                    }
                }
            });

            return rtt;
        } catch (e) {
            console.warn('[Probe] getRTT failed:', e);
            return null;
        }
    }

    /**
     * Close the probe connection and clean up.
     */
    close() {
        if (this.closed) return;
        this.closed = true;

        console.log(`[Probe ${this.probeSessionId}] Closing`);

        this._clearConnectionTimeout();

        // Remove signal listener
        if (this._boundSignalHandler) {
            this.socket.off('probe_signal', this._boundSignalHandler);
            this._boundSignalHandler = null;
        }

        // Close WebRTC connection
        this.webrtcManager.close();
    }
}
```

Key design decisions:
- Reuse WebRTCManager for all WebRTC complexity (ICE, TURN, DataChannel)
- Override _sendSignal to route through probe_signal events instead of webrtc_signal
- Use probeSessionId where WebRTCManager expects gameId (for internal routing)
- Connection timeout prevents hanging probes
- getRTT uses WebRTC getStats() for accurate measurement
  </action>
  <verify>
File exists and has valid JavaScript syntax (no direct way to verify in Node without bundling, but structure check):
```bash
ls -la /Users/chasemcd/Repositories/interactive-gym/interactive_gym/server/static/js/probe_connection.js
grep -c "export class ProbeConnection" /Users/chasemcd/Repositories/interactive-gym/interactive_gym/server/static/js/probe_connection.js
```
  </verify>
  <done>
ProbeConnection class exists with constructor, start(), isReady(), getRTT(), close() methods
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate ProbeManager into client</name>
  <files>interactive_gym/server/static/js/index.js</files>
  <action>
Add probe handling to the main client entry point.

1. First, read index.js to understand its structure
2. Add import for ProbeConnection at the top (with other imports)
3. Add ProbeManager object to handle probe lifecycle
4. Register probe event handlers when socket connects

Add the following integration code:

Near the top with other imports:
```javascript
import { ProbeConnection } from './probe_connection.js';
```

After socket initialization (find where socket is created/connected), add ProbeManager:
```javascript
/**
 * Manages probe connections during matchmaking.
 * Handles probe_prepare -> ProbeConnection -> measurement -> probe_result flow.
 */
const ProbeManager = {
    activeProbe: null,
    mySubjectId: null,

    /**
     * Initialize probe handling with socket and subject identity.
     * @param {Object} socket - SocketIO socket
     * @param {string} subjectId - This participant's subject_id
     */
    init(socket, subjectId) {
        this.socket = socket;
        this.mySubjectId = subjectId;

        // Handle server requesting probe connection
        socket.on('probe_prepare', (data) => this._handleProbePrepare(data));

        // Handle server signaling probe start
        socket.on('probe_start', (data) => this._handleProbeStart(data));

        console.log('[ProbeManager] Initialized for subject', subjectId);
    },

    _handleProbePrepare(data) {
        const { probe_session_id, peer_subject_id, turn_username, turn_credential } = data;

        console.log(`[ProbeManager] Preparing probe ${probe_session_id} with peer ${peer_subject_id}`);

        // Close any existing probe
        if (this.activeProbe) {
            console.warn('[ProbeManager] Closing existing probe before new one');
            this.activeProbe.close();
        }

        // Create new probe connection
        this.activeProbe = new ProbeConnection(
            this.socket,
            probe_session_id,
            this.mySubjectId,
            peer_subject_id,
            { turnUsername: turn_username, turnCredential: turn_credential }
        );

        // Set up callbacks
        this.activeProbe.onConnected = () => this._onProbeConnected(probe_session_id);
        this.activeProbe.onFailed = () => this._onProbeFailed(probe_session_id);

        // Signal ready to server
        this.socket.emit('probe_ready', { probe_session_id });
    },

    _handleProbeStart(data) {
        const { probe_session_id } = data;

        if (!this.activeProbe || this.activeProbe.probeSessionId !== probe_session_id) {
            console.warn(`[ProbeManager] probe_start for unknown session ${probe_session_id}`);
            return;
        }

        console.log(`[ProbeManager] Starting probe ${probe_session_id}`);
        this.activeProbe.start();
    },

    async _onProbeConnected(probeSessionId) {
        console.log(`[ProbeManager] Probe ${probeSessionId} connected, measuring RTT`);

        // Give connection a moment to stabilize, then measure RTT
        await new Promise(resolve => setTimeout(resolve, 500));

        // Get RTT measurement
        const rtt = await this.activeProbe.getRTT();
        console.log(`[ProbeManager] Probe ${probeSessionId} RTT: ${rtt}ms`);

        // Report result to server
        this.socket.emit('probe_result', {
            probe_session_id: probeSessionId,
            rtt_ms: rtt,
            success: rtt !== null,
        });

        // Clean up probe connection
        this._cleanupProbe();
    },

    _onProbeFailed(probeSessionId) {
        console.log(`[ProbeManager] Probe ${probeSessionId} failed`);

        // Report failure to server
        this.socket.emit('probe_result', {
            probe_session_id: probeSessionId,
            rtt_ms: null,
            success: false,
        });

        // Clean up probe connection
        this._cleanupProbe();
    },

    _cleanupProbe() {
        if (this.activeProbe) {
            this.activeProbe.close();
            this.activeProbe = null;
        }
    },
};
```

Then, find where the subject_id is established (after register_subject success or similar) and add:
```javascript
ProbeManager.init(socket, subjectId);
```

Look for patterns like:
- socket.on('registered', ...)
- socket.on('connect', ...)
- Where interactiveGymGlobals.subject_id is set

The exact location will depend on index.js structure. The key is to call ProbeManager.init() once the socket and subject_id are both available.
  </action>
  <verify>
```bash
# Check ProbeConnection import exists
grep -c "import.*ProbeConnection" /Users/chasemcd/Repositories/interactive-gym/interactive_gym/server/static/js/index.js

# Check ProbeManager exists
grep -c "ProbeManager" /Users/chasemcd/Repositories/interactive-gym/interactive_gym/server/static/js/index.js

# Check probe event handlers registered
grep -c "probe_prepare\|probe_start" /Users/chasemcd/Repositories/interactive-gym/interactive_gym/server/static/js/index.js
```
  </verify>
  <done>
index.js imports ProbeConnection, defines ProbeManager, registers probe event handlers, initializes ProbeManager with socket and subject_id
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Verify file structure:
```bash
ls -la /Users/chasemcd/Repositories/interactive-gym/interactive_gym/server/static/js/probe_connection.js
```

2. Verify probe_connection.js has required exports:
```bash
grep "export class ProbeConnection" /Users/chasemcd/Repositories/interactive-gym/interactive_gym/server/static/js/probe_connection.js
```

3. Verify index.js integration:
```bash
grep -E "ProbeManager|probe_prepare|ProbeConnection" /Users/chasemcd/Repositories/interactive-gym/interactive_gym/server/static/js/index.js | head -10
```
</verification>

<success_criteria>
- [ ] probe_connection.js exists with ProbeConnection class
- [ ] ProbeConnection wraps WebRTCManager and uses probe_signal events
- [ ] ProbeConnection has start(), isReady(), getRTT(), close() methods
- [ ] index.js imports ProbeConnection
- [ ] index.js has ProbeManager object with init(), event handlers
- [ ] ProbeManager.init() called when socket and subject_id available
- [ ] probe_prepare handler creates ProbeConnection and emits probe_ready
- [ ] probe_start handler calls activeProbe.start()
- [ ] Probe results reported via probe_result event
</success_criteria>

<output>
After completion, create `.planning/phases/57-p2p-probe-infrastructure/57-02-SUMMARY.md`
</output>
