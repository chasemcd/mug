---
phase: 57-p2p-probe-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/probe_coordinator.py
  - interactive_gym/server/app.py
autonomous: true

must_haves:
  truths:
    - "Server can create probe session between two subject_ids"
    - "Server can relay WebRTC signals for probe connections"
    - "Server can receive and route probe measurement results"
    - "Probe sessions are cleaned up after timeout or completion"
  artifacts:
    - path: "interactive_gym/server/probe_coordinator.py"
      provides: "ProbeCoordinator class for server-side probe orchestration"
      exports: ["ProbeCoordinator"]
    - path: "interactive_gym/server/app.py"
      provides: "SocketIO handlers for probe signaling"
      contains: ["probe_prepare", "probe_ready", "probe_signal", "probe_result"]
  key_links:
    - from: "interactive_gym/server/app.py"
      to: "interactive_gym/server/probe_coordinator.py"
      via: "PROBE_COORDINATOR global instance"
      pattern: "PROBE_COORDINATOR\\."
---

<objective>
Create server-side P2P probe infrastructure that enables RTT measurement between matchmaking candidates before game creation.

Purpose: Phase 57 establishes probe connections for RTT measurement. This plan creates the server-side orchestration layer that manages probe sessions independently of games (no game_id exists during probing).

Output: ProbeCoordinator class and SocketIO handlers that enable:
- Creating probe sessions between two candidates
- Relaying WebRTC signaling for probe connections
- Receiving measurement results and triggering callbacks
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/57-p2p-probe-infrastructure/57-RESEARCH.md

@interactive_gym/server/app.py
@interactive_gym/server/pyodide_game_coordinator.py
@interactive_gym/server/matchmaker.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProbeCoordinator class</name>
  <files>interactive_gym/server/probe_coordinator.py</files>
  <action>
Create the ProbeCoordinator class following the research document specification:

```python
# interactive_gym/server/probe_coordinator.py
from __future__ import annotations

import logging
import time
import uuid
from typing import Any, Callable

import flask_socketio

logger = logging.getLogger(__name__)


class ProbeCoordinator:
    """Manages WebRTC probe connections for RTT measurement.

    Probes are temporary DataChannel connections between matchmaking candidates.
    They exist independently of games - no game_id is needed.

    Usage:
        coordinator = ProbeCoordinator(sio, get_socket_fn)
        probe_id = coordinator.create_probe(subject_a, subject_b, on_complete)
        # ... wait for client-side probe to complete ...
        # on_complete(subject_a, subject_b, rtt_ms) called when done
    """

    def __init__(
        self,
        sio: flask_socketio.SocketIO,
        get_socket_for_subject: Callable[[str], str | None],
        turn_username: str | None = None,
        turn_credential: str | None = None,
    ):
        """Initialize ProbeCoordinator.

        Args:
            sio: Flask-SocketIO instance
            get_socket_for_subject: Callable that returns socket_id for a subject_id
            turn_username: TURN server username (optional)
            turn_credential: TURN server credential (optional)
        """
        ...
```

Required methods:
1. `create_probe(subject_a, subject_b, on_complete) -> str`: Create probe session, emit probe_prepare to both clients
2. `handle_ready(probe_session_id, subject_id)`: Track ready state, emit probe_start when both ready
3. `handle_signal(probe_session_id, target_subject_id, signal_type, payload, sender_socket_id)`: Relay WebRTC signals
4. `handle_result(probe_session_id, rtt_ms, success)`: Process measurement result, call on_complete, cleanup
5. `cleanup_stale_probes()`: Remove probes that exceeded timeout (15s default)

State tracking per probe session:
- probe_session_id: unique identifier
- subject_a, subject_b: participant identifiers
- socket_a, socket_b: current socket IDs (looked up fresh)
- ready_count: number of clients ready (0, 1, or 2)
- state: 'preparing' | 'connecting' | 'measuring' | 'complete' | 'failed'
- created_at: timestamp for timeout detection
- on_complete: callback for result delivery

Follow the research code example closely. Key behaviors:
- If either socket is missing at create_probe time, immediately call on_complete with None RTT
- probe_prepare event includes: probe_session_id, peer_subject_id, turn_username, turn_credential
- probe_start emitted only after BOTH clients report ready
- Signals routed by looking up target socket from session state
- Result handler cleans up session after calling callback
  </action>
  <verify>
Run Python syntax check:
```bash
python -c "from interactive_gym.server.probe_coordinator import ProbeCoordinator; print('OK')"
```
  </verify>
  <done>
ProbeCoordinator class exists with all required methods, imports cleanly, handles full probe lifecycle
  </done>
</task>

<task type="auto">
  <name>Task 2: Add SocketIO probe handlers and wire ProbeCoordinator</name>
  <files>interactive_gym/server/app.py</files>
  <action>
Add probe signaling handlers to app.py:

1. Add import at top:
```python
from interactive_gym.server.probe_coordinator import ProbeCoordinator
```

2. Add global PROBE_COORDINATOR after existing globals (~line 128):
```python
# Probe coordinator for P2P RTT measurement (Phase 57)
PROBE_COORDINATOR: ProbeCoordinator | None = None
```

3. Add helper function to get socket for subject (needed by ProbeCoordinator):
```python
def get_socket_for_subject(subject_id: str) -> str | None:
    """Get current socket_id for a subject_id from PARTICIPANT_SESSIONS."""
    session = PARTICIPANT_SESSIONS.get(subject_id)
    if session and session.is_connected:
        return session.socket_id
    return None
```

4. Initialize PROBE_COORDINATOR in run() function (after socketio init, around line 2100+):
```python
global PROBE_COORDINATOR
PROBE_COORDINATOR = ProbeCoordinator(
    sio=socketio,
    get_socket_for_subject=get_socket_for_subject,
    turn_username=CONFIG.turn_username,
    turn_credential=CONFIG.turn_credential,
)
```

5. Add SocketIO handlers for probe events (after webrtc_signal handler, ~line 1672):

```python
@socketio.on('probe_ready')
def handle_probe_ready(data):
    """Handle client reporting ready for probe connection."""
    if PROBE_COORDINATOR is None:
        logger.warning("Probe ready received but no coordinator")
        return

    probe_session_id = data.get('probe_session_id')
    subject_id = get_subject_id_from_session_id(flask.request.sid)

    logger.debug(f"[Probe] Ready: session={probe_session_id}, subject={subject_id}")
    PROBE_COORDINATOR.handle_ready(probe_session_id, subject_id)


@socketio.on('probe_signal')
def handle_probe_signal(data):
    """Relay WebRTC signaling for probe connections."""
    if PROBE_COORDINATOR is None:
        logger.warning("Probe signal received but no coordinator")
        return

    PROBE_COORDINATOR.handle_signal(
        probe_session_id=data.get('probe_session_id'),
        target_subject_id=data.get('target_subject_id'),
        signal_type=data.get('type'),
        payload=data.get('payload'),
        sender_socket_id=flask.request.sid
    )


@socketio.on('probe_result')
def handle_probe_result(data):
    """Handle probe measurement result from client."""
    if PROBE_COORDINATOR is None:
        logger.warning("Probe result received but no coordinator")
        return

    probe_session_id = data.get('probe_session_id')
    rtt_ms = data.get('rtt_ms')
    success = data.get('success', False)

    logger.info(f"[Probe] Result: session={probe_session_id}, rtt={rtt_ms}ms, success={success}")
    PROBE_COORDINATOR.handle_result(probe_session_id, rtt_ms, success)
```

Key considerations:
- Use existing get_subject_id_from_session_id() to map socket to subject
- Log at DEBUG level for routine operations, INFO for results
- All handlers check PROBE_COORDINATOR exists before using
  </action>
  <verify>
Run syntax check and verify handlers registered:
```bash
python -c "from interactive_gym.server import app; print('Handlers registered')"
```
  </verify>
  <done>
SocketIO handlers for probe_ready, probe_signal, probe_result exist and route to ProbeCoordinator
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Verify ProbeCoordinator can be instantiated:
```bash
python -c "
from interactive_gym.server.probe_coordinator import ProbeCoordinator

# Mock dependencies
class MockSIO:
    def emit(self, *args, **kwargs): pass

pc = ProbeCoordinator(MockSIO(), lambda x: 'socket_123')
print('ProbeCoordinator instantiates OK')
print(f'Methods: {[m for m in dir(pc) if not m.startswith(\"_\")]}')
"
```

2. Verify app.py still loads without errors:
```bash
cd /Users/chasemcd/Repositories/interactive-gym && python -c "from interactive_gym.server import app; print('app.py loads OK')"
```
</verification>

<success_criteria>
- [ ] ProbeCoordinator class exists at interactive_gym/server/probe_coordinator.py
- [ ] ProbeCoordinator has create_probe, handle_ready, handle_signal, handle_result, cleanup_stale_probes methods
- [ ] app.py has PROBE_COORDINATOR global
- [ ] app.py has probe_ready, probe_signal, probe_result SocketIO handlers
- [ ] PROBE_COORDINATOR initialized in run() with TURN credentials from CONFIG
- [ ] All files pass Python syntax validation
</success_criteria>

<output>
After completion, create `.planning/phases/57-p2p-probe-infrastructure/57-01-SUMMARY.md`
</output>
