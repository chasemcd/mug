---
phase: 53-session-lifecycle
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/remote_game.py
  - interactive_gym/server/game_manager.py
  - interactive_gym/server/pyodide_game_coordinator.py
  - interactive_gym/server/app.py
autonomous: true

must_haves:
  truths:
    - "Session state is queryable via game.session_state"
    - "State transitions are validated before executing"
    - "Invalid transitions are logged and rejected"
    - "All lifecycle phases (WAITING, MATCHED, VALIDATING, PLAYING, ENDED) are represented"
  artifacts:
    - path: "interactive_gym/server/remote_game.py"
      provides: "SessionState enum and transition_to() method"
      contains: "class SessionState"
    - path: "interactive_gym/server/game_manager.py"
      provides: "State transitions at add_subject, start_game, cleanup_game"
      contains: "transition_to"
    - path: "interactive_gym/server/pyodide_game_coordinator.py"
      provides: "State transitions at validation start/complete"
      contains: "transition_to"
  key_links:
    - from: "GameManager._create_game"
      to: "SessionState.WAITING"
      via: "session_state initialization"
      pattern: "session_state.*WAITING"
    - from: "GameManager.start_game"
      to: "SessionState.PLAYING"
      via: "transition_to call"
      pattern: "transition_to.*PLAYING"
    - from: "GameManager.cleanup_game"
      to: "SessionState.ENDED"
      via: "transition_to call"
      pattern: "transition_to.*ENDED"
---

<objective>
Add explicit session lifecycle states to RemoteGameV2 so session state is always queryable and transitions are validated.

Purpose: SESS-01 requires explicit states (WAITING -> MATCHED -> VALIDATING -> PLAYING -> ENDED). Currently state is tracked implicitly across multiple data structures (`waiting_games`, `active_games`, `is_active`). This creates fragmented state that's hard to query and debug.

Output: SessionState enum in remote_game.py, transition validation, and all transition points updated to use explicit state changes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/53-session-lifecycle/53-RESEARCH.md
@.planning/phases/52-comprehensive-cleanup/52-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SessionState enum and transition_to() method</name>
  <files>interactive_gym/server/remote_game.py</files>
  <action>
    Add SessionState enum at module level (after imports, before GameStatus):

    ```python
    from enum import Enum, auto

    class SessionState(Enum):
        """Session lifecycle states per SESS-01."""
        WAITING = auto()     # In waiting room, waiting for players
        MATCHED = auto()     # All players matched, about to validate
        VALIDATING = auto()  # P2P validation in progress
        PLAYING = auto()     # Game running
        ENDED = auto()       # Terminal, session will be destroyed
    ```

    Add to RemoteGameV2.__init__():
    - `self.session_state = SessionState.WAITING`

    Add transition_to() method to RemoteGameV2:

    ```python
    # Class constant for valid transitions
    VALID_TRANSITIONS = {
        SessionState.WAITING: {SessionState.MATCHED, SessionState.ENDED},
        SessionState.MATCHED: {SessionState.VALIDATING, SessionState.ENDED},
        SessionState.VALIDATING: {SessionState.PLAYING, SessionState.WAITING, SessionState.ENDED},
        SessionState.PLAYING: {SessionState.ENDED},
        SessionState.ENDED: set(),  # Terminal state
    }

    def transition_to(self, new_state: SessionState) -> bool:
        """Transition session to new state if valid.

        Args:
            new_state: Target session state

        Returns:
            True if transition successful, False if invalid
        """
        if new_state not in self.VALID_TRANSITIONS.get(self.session_state, set()):
            logger.error(
                f"Invalid session transition: {self.session_state} -> {new_state}. "
                f"Valid transitions from {self.session_state}: {self.VALID_TRANSITIONS.get(self.session_state, set())}"
            )
            return False

        old_state = self.session_state
        self.session_state = new_state
        logger.info(f"Session {self.game_id}: {old_state.name} -> {new_state.name}")
        return True
    ```

    Note: Keep existing GameStatus for game-loop state (Active/Reset/Done). SessionState is orthogonal - it tracks overall lifecycle while GameStatus tracks game-loop phase.
  </action>
  <verify>
    Run: `python -c "from interactive_gym.server.remote_game import SessionState, RemoteGameV2; print(SessionState.WAITING)"`
    Expected: `SessionState.WAITING` printed without errors
  </verify>
  <done>
    SessionState enum exists with 5 states, RemoteGameV2 has session_state attribute initialized to WAITING, transition_to() method validates transitions and logs state changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add state transitions to GameManager</name>
  <files>interactive_gym/server/game_manager.py</files>
  <action>
    Update imports at top of file:
    ```python
    from interactive_gym.server.remote_game import RemoteGameV2, GameStatus, SessionState
    ```

    In _create_game(): Session already starts in WAITING (from Task 1 __init__). No change needed, but add a comment:
    ```python
    # Game starts in SessionState.WAITING (set in RemoteGameV2.__init__)
    ```

    In add_subject_to_game() and _add_to_fifo_queue(): When game becomes ready to start, transition to MATCHED before calling start_game:
    ```python
    # Before calling self.start_game(game), add:
    game.transition_to(SessionState.MATCHED)
    ```

    In _create_game_for_group(): Same pattern - transition to MATCHED before start_game.

    In start_game():
    - For non-pyodide games (run_through_pyodide=False), transition directly to PLAYING:
      ```python
      game.transition_to(SessionState.PLAYING)
      ```
    - For pyodide multiplayer games, the transition to VALIDATING happens in coordinator (Task 3), so check if pyodide_multiplayer and only transition to PLAYING if not:
      ```python
      if not self.scene.pyodide_multiplayer:
          game.transition_to(SessionState.PLAYING)
      ```

    In cleanup_game(): Transition to ENDED before any cleanup:
    ```python
    # At the very start, after the idempotent guard:
    game = self.games[game_id]
    game.transition_to(SessionState.ENDED)
    ```

    In leave_game() when cleanup_game is called: No change needed - cleanup_game handles the ENDED transition.
  </action>
  <verify>
    Run: `grep -n "transition_to" interactive_gym/server/game_manager.py | head -20`
    Expected: Multiple lines showing transition_to calls at key points (start_game, cleanup_game, add_subject_to_game)
  </verify>
  <done>
    GameManager calls transition_to() at all lifecycle points: WAITING at creation (implicit), MATCHED when ready, PLAYING at game start (non-pyodide), ENDED at cleanup.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add state transitions to PyodideGameCoordinator</name>
  <files>interactive_gym/server/pyodide_game_coordinator.py, interactive_gym/server/app.py</files>
  <action>
    For PyodideGameCoordinator, the coordinator doesn't hold RemoteGameV2 references directly - it has its own PyodideGameState. The transition needs to happen via a callback or by getting the game from GameManager.

    **Option A (Recommended - simpler):** Add game_manager reference to coordinator and call transition_to on the RemoteGameV2.

    In pyodide_game_coordinator.py __init__:
    ```python
    def __init__(self, sio: flask_socketio.SocketIO, game_manager_getter: callable = None):
        ...
        self.get_game_manager = game_manager_getter  # Returns GameManager for a game_id
    ```

    In start_validation() - called when P2P validation begins:
    ```python
    def start_validation(self, game_id: str) -> bool:
        ...
        # Transition RemoteGameV2 to VALIDATING if we have access
        if self.get_game_manager:
            gm = self.get_game_manager(game_id)
            if gm:
                game = gm.games.get(game_id)
                if game:
                    from interactive_gym.server.remote_game import SessionState
                    game.transition_to(SessionState.VALIDATING)
        ...
    ```

    In _start_game() - called when all players validated (or non-P2P game ready):
    ```python
    def _start_game(self, game_id: str):
        ...
        # Transition to PLAYING
        if self.get_game_manager:
            gm = self.get_game_manager(game_id)
            if gm:
                game = gm.games.get(game_id)
                if game:
                    from interactive_gym.server.remote_game import SessionState
                    game.transition_to(SessionState.PLAYING)
        ...
    ```

    **In app.py:** Update PyodideGameCoordinator instantiation to pass the game_manager getter:
    ```python
    def get_game_manager_for_game(game_id):
        # Look up which scene owns this game
        for stager_instance in stagers.values():
            for scene_id, gm in stager_instance.game_managers.items():
                if game_id in gm.games:
                    return gm
        return None

    pyodide_coordinator = pyodide_game_coordinator.PyodideGameCoordinator(
        sio,
        game_manager_getter=get_game_manager_for_game
    )
    ```

    Alternative if this is too invasive: Keep transitions in GameManager by having app.py handlers call back to GameManager methods that do the transitions. The key is that VALIDATING and PLAYING transitions happen at the right time.
  </action>
  <verify>
    Run full test suite to verify no regressions:
    ```bash
    cd /Users/chasemcd/Repositories/interactive-gym && python -m pytest tests/e2e/test_infrastructure.py -v --timeout=60
    ```
    Expected: Tests pass (validates game lifecycle still works)
  </verify>
  <done>
    P2P validation phase transitions RemoteGameV2 to VALIDATING when start_validation() called, and to PLAYING when validation completes. All session state transitions are explicit and logged.
  </done>
</task>

</tasks>

<verification>
1. Manual inspection:
   ```bash
   grep -n "SessionState" interactive_gym/server/remote_game.py
   grep -n "transition_to" interactive_gym/server/game_manager.py
   grep -n "transition_to" interactive_gym/server/pyodide_game_coordinator.py
   ```
   Expected: SessionState enum defined, transition_to called at lifecycle points

2. Import verification:
   ```bash
   python -c "from interactive_gym.server.remote_game import SessionState, RemoteGameV2; g = RemoteGameV2.__new__(RemoteGameV2); g.session_state = SessionState.WAITING; print(f'Initial: {g.session_state}')"
   ```
   Expected: `Initial: SessionState.WAITING`

3. E2E smoke test:
   ```bash
   cd /Users/chasemcd/Repositories/interactive-gym && python -m pytest tests/e2e/test_infrastructure.py::test_server_starts_and_responds -v --timeout=30
   ```
   Expected: Pass
</verification>

<success_criteria>
- [ ] SessionState enum with WAITING, MATCHED, VALIDATING, PLAYING, ENDED states exists in remote_game.py
- [ ] RemoteGameV2 has session_state attribute initialized to WAITING
- [ ] transition_to() method validates transitions and logs state changes
- [ ] GameManager calls transition_to at: game creation (WAITING implicit), game ready (MATCHED), game start (PLAYING), cleanup (ENDED)
- [ ] PyodideGameCoordinator triggers VALIDATING and PLAYING transitions for P2P games
- [ ] E2E tests pass (no regressions)
- [ ] SESS-01 requirement met: explicit states queryable via game.session_state
- [ ] SESS-02 requirement met: session destroyed (not reused) when ENDED - already ensured by Phase 52 cleanup_game()
</success_criteria>

<output>
After completion, create `.planning/phases/53-session-lifecycle/53-01-SUMMARY.md`
</output>
