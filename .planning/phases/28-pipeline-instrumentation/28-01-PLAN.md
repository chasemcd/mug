---
phase: 28-pipeline-instrumentation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/static/js/ui_utils.js
  - interactive_gym/server/static/js/phaser_gym_graphics.js
  - interactive_gym/server/static/js/pyodide_multiplayer_game.js
autonomous: true

must_haves:
  truths:
    - "Every keypress captures a timestamp at the moment the browser event fires"
    - "Input queue operations record entry and exit timestamps"
    - "Pyodide env.step() call and return are timestamped"
    - "Render begin and complete are timestamped"
    - "Per-input latency breakdown is computed and logged to console"
  artifacts:
    - path: "interactive_gym/server/static/js/ui_utils.js"
      provides: "Keypress timestamp capture (DIAG-01)"
      contains: "performance.now()"
    - path: "interactive_gym/server/static/js/phaser_gym_graphics.js"
      provides: "Input queue timestamps, render timestamps (DIAG-02, DIAG-05, DIAG-06)"
      contains: "inputTimestamps"
    - path: "interactive_gym/server/static/js/pyodide_multiplayer_game.js"
      provides: "env.step() timestamps, latency breakdown (DIAG-03, DIAG-04, DIAG-07)"
      contains: "pipelineMetrics"
  key_links:
    - from: "ui_utils.js"
      to: "phaser_gym_graphics.js"
      via: "timestamp passed with keypress action"
      pattern: "addHumanKeyPressToBuffer.*timestamp"
    - from: "phaser_gym_graphics.js"
      to: "pyodide_multiplayer_game.js"
      via: "timestamps carried through step() call"
      pattern: "keypressTimestamp"
    - from: "pyodide_multiplayer_game.js"
      to: "console"
      via: "latency breakdown logged"
      pattern: "LATENCY.*queue.*step.*render"
---

<objective>
Add timestamps at each stage of the input-to-render pipeline to diagnose reported 1-2 second input lag.

Purpose: Users report significant local input lag in Overcooked. Before fixing, we must measure where the delay occurs. This phase instruments all pipeline stages so Phase 29 can identify the root cause.

Output: Console logs showing per-input latency breakdown (keypress -> queue -> step -> render).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@interactive_gym/server/static/js/ui_utils.js
@interactive_gym/server/static/js/phaser_gym_graphics.js
@interactive_gym/server/static/js/pyodide_multiplayer_game.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add keypress and input queue timestamps</name>
  <files>
    interactive_gym/server/static/js/ui_utils.js
    interactive_gym/server/static/js/phaser_gym_graphics.js
  </files>
  <action>
Add timestamp capture at the keypress event and propagate through the input buffer.

**In ui_utils.js:**
1. In the keydown handler (~line 28), capture `performance.now()` at the very first line BEFORE any other processing
2. Pass the timestamp along with the key to `pgg.addHumanKeyPressToBuffer()` - change signature to accept `{key, keypressTimestamp}`

**In phaser_gym_graphics.js:**
1. Update `addHumanKeyPressToBuffer()` (~line 33) to accept `{key, keypressTimestamp}` object instead of just action string
2. Store as `{action, keypressTimestamp}` in the buffer
3. In `getHumanAction()` (~line 493), when shifting from buffer:
   - Capture `queueExitTimestamp = performance.now()` immediately after shift
   - Return `{action, keypressTimestamp, queueExitTimestamp}` instead of just action
4. Update `buildPyodideActionDict()` to propagate timestamps:
   - Collect timestamps from `getHumanAction()` calls
   - Add a new property to the returned actions dict or a parallel structure: `this._pendingInputTimestamps = {playerId: {keypressTimestamp, queueExitTimestamp}}`

Also handle the `pressed_keys` input mode (`updatePressedKeys`):
- When keys first become pressed, record `performance.now()` as keypressTimestamp
- Track this in a parallel Map: `export var pressedKeyTimestamps = {}`
- Update in `updatePressedKeys()` - only set timestamp if key is newly pressed
- In `getCompositePressedKeys()` and `getHumanAction()` pressed_keys branch, return earliest timestamp of currently pressed keys
  </action>
  <verify>
Open browser console, type a key in the game. Verify that `getHumanAction()` now returns an object with `action`, `keypressTimestamp`, and `queueExitTimestamp` properties (add temporary console.log to verify).
  </verify>
  <done>
- Keypress events capture performance.now() timestamp (DIAG-01)
- Input queue entry/exit timestamps are captured (DIAG-02)
- Timestamps flow through to action building
  </done>
</task>

<task type="auto">
  <name>Task 2: Add env.step() and render timestamps with latency logging</name>
  <files>
    interactive_gym/server/static/js/pyodide_multiplayer_game.js
    interactive_gym/server/static/js/phaser_gym_graphics.js
  </files>
  <action>
Add timestamps around env.step() and render operations, compute and log latency breakdown.

**In pyodide_multiplayer_game.js:**
1. Add pipeline metrics storage in constructor or initialization:
   ```javascript
   this.pipelineMetrics = {
     lastInputTimestamps: null,  // {keypressTimestamp, queueExitTimestamp}
     stepCallTimestamp: null,
     stepReturnTimestamp: null,
     enabled: true  // Can be toggled via console
   };
   ```

2. In `step()` method (~line 2133):
   - Accept input timestamps from caller (will come from buildPyodideActionDict)
   - Before calling `stepWithActions()` (~line 2336): `this.pipelineMetrics.stepCallTimestamp = performance.now();` (DIAG-03)
   - After `stepWithActions()` returns (~line 2342): `this.pipelineMetrics.stepReturnTimestamp = performance.now();` (DIAG-04)
   - Store input timestamps for render phase: `this.pipelineMetrics.lastInputTimestamps = inputTimestamps;`

3. Add a method to receive render timestamps and compute breakdown:
   ```javascript
   logPipelineLatency(renderBeginTimestamp, renderCompleteTimestamp) {
     if (!this.pipelineMetrics.enabled || !this.pipelineMetrics.lastInputTimestamps) return;

     const ts = this.pipelineMetrics.lastInputTimestamps;
     const queueTime = ts.queueExitTimestamp - ts.keypressTimestamp;
     const stepTime = this.pipelineMetrics.stepReturnTimestamp - this.pipelineMetrics.stepCallTimestamp;
     const renderTime = renderCompleteTimestamp - renderBeginTimestamp;
     const totalLatency = renderCompleteTimestamp - ts.keypressTimestamp;

     console.log(`[LATENCY] frame=${this.frameNumber} total=${totalLatency.toFixed(1)}ms | queue=${queueTime.toFixed(1)}ms step=${stepTime.toFixed(1)}ms render=${renderTime.toFixed(1)}ms`);

     // Clear for next input
     this.pipelineMetrics.lastInputTimestamps = null;
   }
   ```

**In phaser_gym_graphics.js:**
1. In `processPyodideGame()` (~line 349):
   - Pass timestamps to step() call - get from `this._pendingInputTimestamps`
   - Clear `this._pendingInputTimestamps` after passing

2. In `processRendering()` (~line 572):
   - Capture `renderBeginTimestamp = performance.now();` at start (DIAG-05)
   - After `this.drawState();` completes, capture `renderCompleteTimestamp = performance.now();` (DIAG-06)
   - Call `this.pyodide_remote_game?.logPipelineLatency(renderBeginTimestamp, renderCompleteTimestamp);` (DIAG-07)

**Logging behavior:**
- Log every input for first 50 frames (debugging initial behavior)
- After frame 50, log every 10th frame (reduce noise but maintain visibility)
- Can be disabled by setting `window.pipelineMetricsEnabled = false` in console
  </action>
  <verify>
1. Start game in browser
2. Open console, observe `[LATENCY]` logs appearing
3. Verify breakdown shows queue, step, and render times that sum to approximately total
4. Press keys and verify new latency entries appear within 1-2 frames
  </verify>
  <done>
- env.step() call and return timestamps captured (DIAG-03, DIAG-04)
- Render begin/complete timestamps captured (DIAG-05, DIAG-06)
- Per-input latency breakdown computed and logged (DIAG-07)
- Console shows: `[LATENCY] frame=N total=Xms | queue=Yms step=Zms render=Wms`
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify instrumentation in single-player and multiplayer</name>
  <files>
    interactive_gym/server/static/js/pyodide_remote_game.js
  </files>
  <action>
Ensure instrumentation works for both single-player (pyodide_remote_game.js) and multiplayer (pyodide_multiplayer_game.js) modes.

**In pyodide_remote_game.js:**
1. Add the same `pipelineMetrics` object and `logPipelineLatency()` method as in multiplayer
2. Instrument `step()` method with stepCallTimestamp and stepReturnTimestamp
3. Ensure phaser_gym_graphics.js calls work correctly for single-player games

**Test both modes:**
1. Single-player: Start a single-player game, verify latency logs appear
2. Multiplayer: Start a multiplayer game, verify latency logs appear for local inputs

**Edge cases to handle:**
- No input this frame (default action used) - skip latency logging for that frame
- Fast-forward frames - skip latency logging (not real-time input)
- Background/foreground transitions - skip latency logging during transition frames
  </action>
  <verify>
1. Run single-player game: `[LATENCY]` logs appear with reasonable values
2. Run multiplayer game: `[LATENCY]` logs appear with reasonable values
3. Both show breakdown of queue/step/render times
4. No errors in console from missing properties or methods
  </verify>
  <done>
- Pipeline instrumentation works in single-player mode
- Pipeline instrumentation works in multiplayer mode
- Edge cases handled (no input, fast-forward, background transitions)
- Ready for Phase 29 diagnosis
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Start any game (single-player or multiplayer)
2. Open browser console
3. Observe `[LATENCY] frame=N total=Xms | queue=Yms step=Zms render=Wms` logs
4. Verify:
   - queue time: should be near 0ms for immediate keypresses, may be 50-100ms+ if input was queued
   - step time: Pyodide execution time, typically 10-50ms
   - render time: Phaser draw time, typically 1-10ms
   - total time: should equal queue + step + render (approximately)
5. Press keys during gameplay and verify latency entries reflect the action
6. Run `window.pipelineMetricsEnabled = false` in console, verify logging stops
</verification>

<success_criteria>
- All 7 DIAG requirements met:
  - DIAG-01: Keypress timestamp via performance.now()
  - DIAG-02: Input queue entry/exit timestamps
  - DIAG-03: env.step() call timestamp
  - DIAG-04: env.step() return timestamp
  - DIAG-05: Render begin timestamp
  - DIAG-06: Render complete timestamp
  - DIAG-07: Per-input latency breakdown computed and logged
- Console output format: `[LATENCY] frame=N total=Xms | queue=Yms step=Zms render=Wms`
- Works in both single-player and multiplayer modes
- Instrumentation can be toggled off via console
</success_criteria>

<output>
After completion, create `.planning/phases/28-pipeline-instrumentation/28-01-SUMMARY.md`
</output>
