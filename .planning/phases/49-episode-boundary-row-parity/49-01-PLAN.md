---
phase: 49-episode-boundary-row-parity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/static/js/pyodide_multiplayer_game.js
  - tests/e2e/test_data_comparison.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Both players export exactly the same number of rows (0 tolerance)"
    - "Fast-forward processing stops at episode boundary, not after"
    - "_promoteRemainingAtBoundary() only promotes frames within episode boundary"
  artifacts:
    - path: "interactive_gym/server/static/js/pyodide_multiplayer_game.js"
      provides: "Episode boundary guards in fast-forward path"
      contains: "syncedTerminationFrame"
  key_links:
    - from: "_performFastForward()"
      to: "syncedTerminationFrame"
      via: "maxFrame cap before building frame list"
      pattern: "Math\\.min.*syncedTerminationFrame"
    - from: "_promoteRemainingAtBoundary()"
      to: "syncedTerminationFrame"
      via: "frame filter during promotion"
      pattern: "frame >= terminationFrame"
---

<objective>
Fix episode boundary row count mismatch when one player is backgrounded at episode end.

Purpose: When Player 1 backgrounds near episode boundary (frame 440 of max_steps=450), Player 2 continues to frame 450 and broadcasts episode end. Player 1's fast-forward currently processes ALL buffered inputs beyond the boundary, resulting in 512 rows vs 450 expected. This phase caps fast-forward processing at syncedTerminationFrame to ensure both players export identical row counts.

Output: Both players export exactly max_steps rows (450) regardless of focus loss timing at episode boundary. test_focus_loss_episode_boundary_parity passes without xfail marker.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-episode-boundary-row-parity/49-RESEARCH.md
@.planning/phases/48-isfocused-column-consistency/48-01-SUMMARY.md
@.planning/phases/38-episode-boundary/38-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Cap fast-forward maxFrame at episode boundary</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
In `_performFastForward()`, after computing `maxFrame` from buffered inputs (around line 4911, after the for loop that processes bufferedInputs), add episode boundary check:

```javascript
// Phase 49 (BOUND-02): Cap fast-forward at episode boundary
const sync = this.p2pEpisodeSync;
if (sync && sync.syncedTerminationFrame !== null && sync.syncedTerminationFrame !== undefined) {
    if (maxFrame > sync.syncedTerminationFrame) {
        p2pLog.debug(`Fast-forward capped at episode boundary: ${maxFrame} -> ${sync.syncedTerminationFrame}`);
        maxFrame = sync.syncedTerminationFrame;
    }
}
```

This MUST be placed BEFORE the `framesToProcess` calculation (line 4914) and BEFORE building the `fastForwardFrames` array (line 4969 loop).

The existing pattern in _processStep() (line 2449-2450) provides the reference:
```javascript
const shouldStoreFrame = !sync.localEpisodeEndDetected &&
    (sync.syncedTerminationFrame === null || this.frameNumber < sync.syncedTerminationFrame);
```

Also add a boundary check in the storeFrameData loop (around line 5068-5077) as a defensive guard:

```javascript
// Phase 49 (BOUND-03): Skip frames at or beyond episode boundary
const terminationFrame = this.p2pEpisodeSync?.syncedTerminationFrame;
for (const frameData of ffResult.per_frame_data) {
    // Skip frames at or beyond episode boundary
    if (terminationFrame !== null && terminationFrame !== undefined) {
        if (frameData.frame >= terminationFrame) {
            p2pLog.debug(`Fast-forward: skipping post-boundary frame ${frameData.frame}`);
            continue;
        }
    }
    this.storeFrameData(frameData.frame, {
        // ... existing code ...
    });
}
```

This provides defense-in-depth: the maxFrame cap prevents extra frames from being processed, and the storeFrameData guard prevents any that slip through from being recorded.
  </action>
  <verify>
Run grep to confirm both guards are in place:
```bash
grep -n "syncedTerminationFrame" interactive_gym/server/static/js/pyodide_multiplayer_game.js | grep -i "fast-forward\|BOUND"
```
Expected: At least 2 new occurrences with BOUND comments.
  </verify>
  <done>Fast-forward respects episode boundary: maxFrame capped at syncedTerminationFrame, storeFrameData skips post-boundary frames</done>
</task>

<task type="auto">
  <name>Task 2: Update _promoteRemainingAtBoundary to filter frames</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Update `_promoteRemainingAtBoundary()` (lines 3002-3016) to filter out frames at or beyond the episode boundary during promotion. This handles the case where frames were stored in speculativeFrameData before the boundary was known.

Replace the current implementation:

```javascript
_promoteRemainingAtBoundary() {
    const remaining = this.speculativeFrameData.size;
    if (remaining === 0) return;

    // Phase 49 (BOUND-03): Only promote frames within episode boundary
    const terminationFrame = this.p2pEpisodeSync?.syncedTerminationFrame;

    console.warn(`[Episode Boundary] Promoting ${remaining} unconfirmed frames ` +
        `at episode end (confirmedFrame=${this.confirmedFrame}, frameNumber=${this.frameNumber})`);

    let promoted = 0;
    let skipped = 0;
    for (const [frame, data] of this.speculativeFrameData.entries()) {
        // Skip frames at or beyond episode boundary
        if (terminationFrame !== null && terminationFrame !== undefined && frame >= terminationFrame) {
            p2pLog.debug(`[Episode Boundary] Skipping post-boundary frame ${frame}`);
            skipped++;
            continue;
        }
        this.frameDataBuffer.set(frame, { ...data, wasSpeculative: true });
        promoted++;
    }
    this.speculativeFrameData.clear();

    if (skipped > 0) {
        p2pLog.info(`[Episode Boundary] Promoted ${promoted} frames, skipped ${skipped} post-boundary frames`);
    }
}
```

Key changes:
1. Get terminationFrame from p2pEpisodeSync
2. Skip frames where frame >= terminationFrame
3. Track and log skipped frames for debugging
4. Clear speculativeFrameData regardless (cleanup)
  </action>
  <verify>
Run grep to confirm the update:
```bash
grep -A 25 "_promoteRemainingAtBoundary" interactive_gym/server/static/js/pyodide_multiplayer_game.js | head -30
```
Expected: Shows terminationFrame check and skipped counter.
  </verify>
  <done>_promoteRemainingAtBoundary filters out frames at or beyond syncedTerminationFrame</done>
</task>

<task type="auto">
  <name>Task 3: Remove xfail marker and verify test passes</name>
  <files>tests/e2e/test_data_comparison.py</files>
  <action>
1. Remove the xfail marker from test_focus_loss_episode_boundary_parity (line 506):

Before:
```python
@pytest.mark.timeout(300)
@pytest.mark.xfail(reason="Known issue: row count mismatch at episode boundary when player backgrounded - Phase 49 fix")
def test_focus_loss_episode_boundary_parity(flask_server, player_contexts, clean_data_dir):
```

After:
```python
@pytest.mark.timeout(300)
def test_focus_loss_episode_boundary_parity(flask_server, player_contexts, clean_data_dir):
```

2. Update the docstring to remove the xfail note (lines 524-531). Remove this paragraph:
```
    NOTE: This test is marked xfail because there are known issues with episode
    boundary handling when one player is backgrounded:
    1. Row count mismatch: the backgrounded player may record frames beyond the
       episode boundary due to fast-forward processing after episode ends
    2. Column mismatch: isFocused columns only present for player who lost focus
    These are edge cases in the dual-buffer data recording system that should
    be addressed in a future phase.
```

3. Run the test to verify it passes:
```bash
python -m pytest tests/e2e/test_data_comparison.py::test_focus_loss_episode_boundary_parity -v --headed --timeout=300
```

Note: This test requires headed mode (WebRTC needs real browser). The test takes ~2-3 minutes to complete.
  </action>
  <verify>
Test passes without xfail:
```bash
python -m pytest tests/e2e/test_data_comparison.py::test_focus_loss_episode_boundary_parity -v --headed --timeout=300
```
Expected: PASSED (not XPASS or FAILED)
  </verify>
  <done>test_focus_loss_episode_boundary_parity passes without xfail marker, both players export identical row counts</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Unit verification:** Grep confirms boundary guards exist in both fast-forward and promotion paths
2. **Integration verification:** test_focus_loss_episode_boundary_parity passes
3. **Regression verification:** test_focus_loss_mid_episode_parity still passes (column fix from Phase 48)

```bash
# Full verification suite
python -m pytest tests/e2e/test_data_comparison.py::test_focus_loss_mid_episode_parity tests/e2e/test_data_comparison.py::test_focus_loss_episode_boundary_parity -v --headed --timeout=300
```

Expected: Both tests PASSED.
</verification>

<success_criteria>
1. Both players export exactly the same number of rows (0 tolerance) - verified by test passing
2. Fast-forward processing stops at episode boundary (maxFrame capped at syncedTerminationFrame)
3. _promoteRemainingAtBoundary() only promotes frames within boundary (skips post-boundary frames)
4. test_focus_loss_episode_boundary_parity passes without xfail marker
5. No regression in test_focus_loss_mid_episode_parity
</success_criteria>

<output>
After completion, create `.planning/phases/49-episode-boundary-row-parity/49-01-SUMMARY.md`
</output>
