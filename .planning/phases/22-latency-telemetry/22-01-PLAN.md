---
phase: 22-latency-telemetry
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/static/js/webrtc_manager.js
  - interactive_gym/server/static/js/pyodide_multiplayer_game.js
autonomous: true
user_setup: []

must_haves:
  truths:
    - "P2P latency (RTT) is measured periodically during gameplay without blocking the game loop"
    - "Latency statistics (min, median, mean, max) are available after the session"
    - "Latency data is included in session data exports"
  artifacts:
    - path: "interactive_gym/server/static/js/webrtc_manager.js"
      provides: "LatencyTelemetry class with sample collection and stats computation"
      contains: "class LatencyTelemetry"
    - path: "interactive_gym/server/static/js/pyodide_multiplayer_game.js"
      provides: "Latency telemetry integration and export wiring"
      contains: "latencyTelemetry"
  key_links:
    - from: "pyodide_multiplayer_game.js"
      to: "LatencyTelemetry"
      via: "instantiation in onDataChannelOpen"
      pattern: "new LatencyTelemetry"
    - from: "exportSessionMetrics"
      to: "latencyTelemetry.getStats()"
      via: "latency property in export"
      pattern: "latency.*getStats"
---

<objective>
Implement async latency telemetry that measures P2P round-trip time periodically during gameplay and exports aggregate statistics (min, median, mean, max) in session data.

Purpose: Provides researchers with P2P connection quality metrics for correlation with behavioral data. Completes v1.3 P2P Connection Validation milestone.

Output: LatencyTelemetry class in webrtc_manager.js, integration in pyodide_multiplayer_game.js, latency stats in session exports.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 20-02 established export patterns
@.planning/phases/20-mid-game-reconnection/20-02-SUMMARY.md

# Phase 21 establishes context for final v1.3 phase
@.planning/phases/21-per-round-health-check/21-01-SUMMARY.md

# Key implementation files
@interactive_gym/server/static/js/webrtc_manager.js
@interactive_gym/server/static/js/pyodide_multiplayer_game.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add LatencyTelemetry class to webrtc_manager.js</name>
  <files>interactive_gym/server/static/js/webrtc_manager.js</files>
  <action>
Add a new `LatencyTelemetry` class after the existing `ConnectionQualityMonitor` class.

The class should:

1. **Constructor:**
   - Accept `peerConnection` and optional `options` object
   - `options.pollInterval` - polling interval in ms (default: 1000 for ~1Hz sampling)
   - `options.maxSamples` - max samples to retain (default: 600 for ~10 min at 1Hz)
   - Initialize `samples` as empty array
   - Initialize `intervalId` as null

2. **start() method:**
   - Start interval calling `_poll()` at `pollInterval`

3. **stop() method:**
   - Clear interval if running

4. **async _poll() method:**
   - Guard: return early if `!this.pc` or `pc.connectionState !== 'connected'`
   - Call `await this.pc.getStats()`
   - Find the selected candidate pair (same pattern as ConnectionQualityMonitor._extractQualityMetrics)
   - Extract `currentRoundTripTime` from the pair (in seconds, convert to ms)
   - If valid RTT value exists:
     - Push `{ timestamp: Date.now(), rttMs: rtt }` to samples array
     - If samples exceed maxSamples, shift oldest

5. **getStats() method:**
   - Return null if samples.length === 0
   - Compute and return object with:
     - `sampleCount: number` - total samples collected
     - `minMs: number` - minimum RTT
     - `maxMs: number` - maximum RTT
     - `meanMs: number` - arithmetic mean (sum / count)
     - `medianMs: number` - middle value (sort copy, pick middle)
     - `samples: array` - the raw samples array (for detailed analysis)

6. **getSamples() method:**
   - Return copy of samples array

Export the class alongside existing exports:
```javascript
export { WebRTCManager, ConnectionQualityMonitor, LatencyTelemetry };
```
  </action>
  <verify>
Grep for `class LatencyTelemetry` in webrtc_manager.js confirms class exists.
Grep for `export.*LatencyTelemetry` confirms proper export.
  </verify>
  <done>
LatencyTelemetry class exists with start(), stop(), _poll(), getStats(), getSamples() methods. Polls getStats() at configurable interval, stores RTT samples, computes min/median/mean/max statistics.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate LatencyTelemetry into pyodide_multiplayer_game.js</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Wire LatencyTelemetry into the multiplayer game:

1. **Add import:**
   At the top where WebRTCManager is imported, add LatencyTelemetry:
   ```javascript
   import { WebRTCManager, LatencyTelemetry } from './webrtc_manager.js';
   ```

2. **Add property:**
   In constructor or initialization section, add:
   ```javascript
   this.latencyTelemetry = null;
   ```

3. **Start telemetry in onDataChannelOpen:**
   In the existing onDataChannelOpen handler (where P2PInputSender is initialized), after the connection is confirmed ready:
   ```javascript
   // Start latency telemetry (Phase 22 - LAT-01)
   if (!this.latencyTelemetry && this.webrtcManager?.peerConnection) {
       this.latencyTelemetry = new LatencyTelemetry(this.webrtcManager.peerConnection, {
           pollInterval: 1000,  // 1Hz sampling
           maxSamples: 600      // ~10 minutes of data
       });
       this.latencyTelemetry.start();
       p2pLog.info('Latency telemetry started');
   }
   ```
   Note: Guard with null check to prevent re-initialization on DataChannel reopen (same pattern as Phase 20-02).

4. **Stop telemetry on cleanup:**
   In the cleanup/destroy path (where webrtcManager.close() is called), add before the close:
   ```javascript
   if (this.latencyTelemetry) {
       this.latencyTelemetry.stop();
       // Don't null it - we need stats for export
   }
   ```

5. **Add getLatencyStats() helper method:**
   ```javascript
   /**
    * Get P2P latency statistics for export.
    * @returns {Object|null} Latency stats or null if unavailable
    */
   getLatencyStats() {
       return this.latencyTelemetry?.getStats() || null;
   }
   ```

6. **Wire into exportSessionMetrics():**
   Add latency stats to the return object, after the `reconnection` property:
   ```javascript
   // P2P latency telemetry (Phase 22 - LAT-01, LAT-02)
   latency: this.getLatencyStats()
   ```

7. **Wire into exportValidationData():**
   Add latency stats after the reconnection property:
   ```javascript
   // P2P latency telemetry (Phase 22 - LAT-01, LAT-02)
   latency: this.getLatencyStats()
   ```

8. **Wire into exportMultiplayerMetrics():**
   Add latency stats in the appropriate section of the return object.
  </action>
  <verify>
Run `grep -n "LatencyTelemetry" interactive_gym/server/static/js/pyodide_multiplayer_game.js` to confirm:
- Import statement exists
- Class instantiation in onDataChannelOpen
- Integration with export methods

Check that latency property appears in all three export methods.
  </verify>
  <done>
LatencyTelemetry is instantiated when DataChannel opens, starts polling immediately, and latency stats (min, median, mean, max) are included in exportSessionMetrics(), exportValidationData(), and exportMultiplayerMetrics().
  </done>
</task>

</tasks>

<verification>
1. Code review:
   - `LatencyTelemetry` class exists in webrtc_manager.js
   - Class is exported
   - Import statement in pyodide_multiplayer_game.js
   - Instantiation in onDataChannelOpen
   - Export methods include latency stats

2. Logical verification:
   - Polling is async (uses await getStats()) - non-blocking (LAT-01)
   - Stats computation includes min, median, mean, max (LAT-02)
   - Data included in session exports (LAT-02)
</verification>

<success_criteria>
- [ ] LatencyTelemetry class polls RTCPeerConnection.getStats() at 1Hz (LAT-01)
- [ ] Polling is async/non-blocking (LAT-01)
- [ ] getStats() returns min, median, mean, max (LAT-02)
- [ ] exportSessionMetrics() includes latency object
- [ ] exportValidationData() includes latency object
- [ ] exportMultiplayerMetrics() includes latency object
- [ ] All code compiles (no syntax errors)
</success_criteria>

<output>
After completion, create `.planning/phases/22-latency-telemetry/22-01-SUMMARY.md`
</output>
