---
phase: 55-matchmaker-base-class
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/matchmaker.py
  - interactive_gym/server/game_manager.py
autonomous: true

must_haves:
  truths:
    - "Matchmaker.find_match() is an abstract method that cannot be instantiated directly"
    - "FIFOMatchmaker produces identical matching behavior to current code"
    - "GameManager delegates matching decisions to matchmaker instance"
  artifacts:
    - path: "interactive_gym/server/matchmaker.py"
      provides: "Matchmaker ABC and FIFOMatchmaker implementation"
      exports: ["Matchmaker", "MatchCandidate", "FIFOMatchmaker"]
    - path: "interactive_gym/server/game_manager.py"
      provides: "GameManager with matchmaker delegation"
      contains: "self.matchmaker.find_match"
  key_links:
    - from: "interactive_gym/server/game_manager.py"
      to: "interactive_gym/server/matchmaker.py"
      via: "import and delegation"
      pattern: "from interactive_gym.server.matchmaker import"
---

<objective>
Create the Matchmaker abstract base class and FIFOMatchmaker default implementation, then refactor GameManager to delegate matching decisions.

Purpose: Establish the pluggable matchmaking abstraction that allows researchers to customize how participants are grouped together. This is the foundation for custom matchmaking strategies.

Output:
- `matchmaker.py` module with Matchmaker ABC, MatchCandidate dataclass, FIFOMatchmaker
- GameManager refactored to use matchmaker delegation
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/55-matchmaker-base-class/55-RESEARCH.md

# Prior phase provides ParticipantStateTracker integration patterns
@.planning/phases/54-participant-state-tracker/54-01-SUMMARY.md

# Current implementation to refactor
@interactive_gym/server/game_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create matchmaker.py with Matchmaker ABC and FIFOMatchmaker</name>
  <files>interactive_gym/server/matchmaker.py</files>
  <action>
Create new file `interactive_gym/server/matchmaker.py` with:

1. **MatchCandidate dataclass** - context for matchmaking decisions:
   ```python
   @dataclass
   class MatchCandidate:
       subject_id: str
       rtt_ms: int | None = None
       # Future: custom attributes from Phase 56
   ```

2. **Matchmaker ABC** - abstract base class:
   ```python
   class Matchmaker(ABC):
       @abstractmethod
       def find_match(
           self,
           arriving: MatchCandidate,
           waiting: list[MatchCandidate],
           group_size: int,
       ) -> list[MatchCandidate] | None:
           """Return matched list including arriving, or None to wait."""
           ...
   ```

3. **FIFOMatchmaker** - default implementation matching current behavior:
   ```python
   class FIFOMatchmaker(Matchmaker):
       def find_match(self, arriving, waiting, group_size):
           if len(waiting) + 1 < group_size:
               return None
           # Take first (group_size - 1) waiting + arriving
           return waiting[:group_size - 1] + [arriving]
   ```

Include proper docstrings explaining:
- arriving is the participant who just entered the waitroom
- waiting is the list of participants already waiting
- group_size is the number needed for a full game
- Return list MUST include arriving if match found
- Return None to continue waiting

Use Python standard library only (abc, dataclasses, typing).
  </action>
  <verify>
```bash
python -c "from interactive_gym.server.matchmaker import Matchmaker, MatchCandidate, FIFOMatchmaker; print('imports OK')"
python -c "
from interactive_gym.server.matchmaker import Matchmaker, MatchCandidate, FIFOMatchmaker
# Test ABC enforcement
try:
    Matchmaker()
except TypeError as e:
    print('ABC enforced:', 'abstract' in str(e))
# Test FIFOMatchmaker
m = FIFOMatchmaker()
c1, c2 = MatchCandidate('a'), MatchCandidate('b')
assert m.find_match(c1, [], 2) is None  # Need 2, only have 1
assert len(m.find_match(c2, [c1], 2)) == 2  # Now have 2
print('FIFOMatchmaker works')
"
```
  </verify>
  <done>
- Matchmaker ABC with @abstractmethod find_match() exists
- MatchCandidate dataclass with subject_id and optional rtt_ms exists
- FIFOMatchmaker default implementation matches current FIFO behavior
- Direct instantiation of Matchmaker raises TypeError
  </done>
</task>

<task type="auto">
  <name>Task 2: Add matchmaker parameter to GameManager</name>
  <files>interactive_gym/server/game_manager.py</files>
  <action>
Modify `GameManager.__init__()` to accept matchmaker parameter:

1. Add import at top of file:
   ```python
   from interactive_gym.server.matchmaker import Matchmaker, MatchCandidate, FIFOMatchmaker
   ```

2. Add parameter to `__init__()`:
   ```python
   def __init__(
       self,
       scene: gym_scene.GymScene,
       ...
       matchmaker: Matchmaker | None = None,  # NEW - add after participant_state_tracker
   ):
       ...
       self.matchmaker = matchmaker or FIFOMatchmaker()
   ```

The default `FIFOMatchmaker()` ensures backward compatibility - existing code continues to work without specifying a matchmaker.
  </action>
  <verify>
```bash
python -c "
from interactive_gym.server.game_manager import GameManager
from interactive_gym.server.matchmaker import FIFOMatchmaker, Matchmaker
import inspect
# Check matchmaker parameter exists
sig = inspect.signature(GameManager.__init__)
assert 'matchmaker' in sig.parameters, 'matchmaker param missing'
print('matchmaker parameter exists')
"
```
  </verify>
  <done>
- GameManager.__init__() accepts optional matchmaker parameter
- Default is FIFOMatchmaker() when not provided
- Import statement added for matchmaker module
  </done>
</task>

<task type="auto">
  <name>Task 3: Refactor _add_to_fifo_queue to delegate to matchmaker</name>
  <files>interactive_gym/server/game_manager.py</files>
  <action>
Refactor `_add_to_fifo_queue()` to use matchmaker delegation:

1. Build MatchCandidate for arriving participant:
   ```python
   arriving = MatchCandidate(
       subject_id=subject_id,
       rtt_ms=self.get_subject_rtt(subject_id) if self.get_subject_rtt else None,
   )
   ```

2. Build waiting list from current waiting participants:
   - Get subject_ids from games in self.waiting_games
   - For each, create MatchCandidate with their RTT if available

3. Determine group_size:
   ```python
   group_size = len([
       p for p in self.scene.policy_mapping.values()
       if p == configuration_constants.PolicyTypes.Human
   ])
   ```

4. Call matchmaker:
   ```python
   matched = self.matchmaker.find_match(arriving, waiting, group_size)
   ```

5. Handle result:
   - If `matched is None`: Add arriving to waitroom (existing logic for single participant)
   - If `matched is not None`: Create game with all matched participants

**Key insight:** The current `_add_to_fifo_queue()` has RTT-based filtering built in. For now, keep that logic AS-IS and only delegate the final matching decision to the matchmaker. The FIFOMatchmaker will produce identical behavior to current code because:
- Current code iterates waiting_games to find RTT-compatible game
- If found, adds participant to that game
- If game fills up, starts the game

The refactor preserves this exact flow - matchmaker just decides "is it time to match?" given the participants. The RTT filtering happens BEFORE calling matchmaker (when building the waiting list).

**Minimal change approach:**
- Keep existing `_is_rtt_compatible()` logic
- Keep existing game creation/start logic
- Only change: Instead of hardcoded "if len(waiting) + 1 >= group_size then match", delegate to `self.matchmaker.find_match()`
  </action>
  <verify>
```bash
# Run existing E2E tests to verify behavior unchanged
cd /Users/chasemcd/Repositories/interactive-gym && python -m pytest tests/e2e/test_multiplayer_basic.py -v -x --timeout=180 2>&1 | head -50
```
  </verify>
  <done>
- _add_to_fifo_queue() builds MatchCandidate for arriving participant
- _add_to_fifo_queue() builds waiting list as list[MatchCandidate]
- _add_to_fifo_queue() calls self.matchmaker.find_match()
- Existing E2E tests pass (behavior preserved)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Unit verification:**
```bash
python -c "
from interactive_gym.server.matchmaker import Matchmaker, MatchCandidate, FIFOMatchmaker
from interactive_gym.server.game_manager import GameManager

# Verify ABC enforcement
try:
    Matchmaker()
    print('FAIL: Should not instantiate ABC')
except TypeError:
    print('PASS: ABC enforcement works')

# Verify FIFOMatchmaker logic
m = FIFOMatchmaker()
c1 = MatchCandidate('p1', rtt_ms=50)
c2 = MatchCandidate('p2', rtt_ms=60)
c3 = MatchCandidate('p3', rtt_ms=70)

# 2-player game
assert m.find_match(c1, [], 2) is None  # Need partner
assert len(m.find_match(c2, [c1], 2)) == 2  # Both included
print('PASS: 2-player matching')

# 3-player game
assert m.find_match(c1, [], 3) is None
assert m.find_match(c2, [c1], 3) is None
result = m.find_match(c3, [c1, c2], 3)
assert len(result) == 3
assert c3 in result  # arriving must be included
print('PASS: 3-player matching')

print('All unit tests pass')
"
```

2. **E2E verification:** Run full test suite to ensure matching behavior unchanged
```bash
cd /Users/chasemcd/Repositories/interactive-gym && python -m pytest tests/e2e/ -v --timeout=180 -x
```
</verification>

<success_criteria>
- Matchmaker ABC exists with abstract find_match() method
- MatchCandidate dataclass provides context for matching decisions
- FIFOMatchmaker implements current FIFO matching behavior
- GameManager accepts matchmaker parameter (optional, defaults to FIFOMatchmaker)
- GameManager._add_to_fifo_queue() delegates to self.matchmaker.find_match()
- All existing E2E tests pass (behavior preserved)
</success_criteria>

<output>
After completion, create `.planning/phases/55-matchmaker-base-class/55-01-SUMMARY.md`
</output>
