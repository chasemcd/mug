---
phase: 55-matchmaker-base-class
plan: 02
type: execute
wave: 2
depends_on: ["55-01"]
files_modified:
  - interactive_gym/scenes/gym_scene.py
  - interactive_gym/server/app.py
autonomous: true

must_haves:
  truths:
    - "Researcher can configure custom matchmaker via scene.matchmaking(matchmaker=...)"
    - "Custom matchmaker is passed through to GameManager"
    - "Existing scenes without matchmaker config continue to work (backward compatible)"
  artifacts:
    - path: "interactive_gym/scenes/gym_scene.py"
      provides: "GymScene.matchmaking() with matchmaker parameter"
      contains: "matchmaker"
    - path: "interactive_gym/server/app.py"
      provides: "Matchmaker wiring from scene to GameManager"
      contains: "matchmaker="
  key_links:
    - from: "interactive_gym/scenes/gym_scene.py"
      to: "interactive_gym/server/game_manager.py"
      via: "scene._matchmaker passed to GameManager"
      pattern: "matchmaker=.*_matchmaker"
---

<objective>
Integrate matchmaker configuration into the scene API and wire it through to GameManager instantiation.

Purpose: Allow researchers to configure custom matchmaking strategies per-scene via the existing fluent API pattern used throughout the codebase.

Output:
- GymScene.matchmaking() accepts optional matchmaker parameter
- app.py passes scene's matchmaker to GameManager
- Full end-to-end wiring verified with E2E tests
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/55-matchmaker-base-class/55-RESEARCH.md

# Prior plan provides Matchmaker ABC and GameManager integration
@.planning/phases/55-matchmaker-base-class/55-01-SUMMARY.md

# Files to modify
@interactive_gym/scenes/gym_scene.py
@interactive_gym/server/app.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add matchmaker parameter to GymScene.matchmaking()</name>
  <files>interactive_gym/scenes/gym_scene.py</files>
  <action>
Modify GymScene to support matchmaker configuration:

1. Add import at top of file (with other imports):
   ```python
   from interactive_gym.server.matchmaker import Matchmaker
   ```
   Note: Import inside TYPE_CHECKING block to avoid circular imports:
   ```python
   from typing import TYPE_CHECKING
   if TYPE_CHECKING:
       from interactive_gym.server.matchmaker import Matchmaker
   ```

2. Add instance variable in `__init__()`:
   ```python
   # Matchmaker settings (Phase 55)
   self._matchmaker: "Matchmaker | None" = None  # Custom matchmaker, None uses default FIFO
   ```

3. Extend `matchmaking()` method to accept matchmaker parameter:
   ```python
   def matchmaking(
       self,
       hide_lobby_count: bool = NotProvided,
       max_rtt: int = NotProvided,
       matchmaker: "Matchmaker" = NotProvided,  # NEW
   ):
       """Configure matchmaking and lobby settings for the GymScene.

       :param hide_lobby_count: If True, hides the participant count display in the waitroom.
           Participants will only see the countdown timer, not how many are waiting.
           Defaults to NotProvided (False).
       :type hide_lobby_count: bool, optional
       :param max_rtt: Maximum RTT difference (in milliseconds) allowed between participants
           when pairing. If a participant's RTT differs from another by more than this value,
           they will not be paired together. Set to None to disable RTT-based pairing.
           Defaults to NotProvided (None).
       :type max_rtt: int, optional
       :param matchmaker: Custom Matchmaker instance for participant grouping logic.
           Must be a subclass of Matchmaker with find_match() implemented.
           Defaults to NotProvided (uses FIFOMatchmaker).
       :type matchmaker: Matchmaker, optional
       :return: The GymScene instance
       :rtype: GymScene

       Example:
           from interactive_gym.server.matchmaker import FIFOMatchmaker

           scene.matchmaking(
               hide_lobby_count=True,
               max_rtt=50,
               matchmaker=FIFOMatchmaker(),  # or custom subclass
           )
       """
       if hide_lobby_count is not NotProvided:
           self.hide_lobby_count = hide_lobby_count

       if max_rtt is not NotProvided:
           if max_rtt is not None and max_rtt <= 0:
               raise ValueError("max_rtt must be a positive integer or None")
           self.matchmaking_max_rtt = max_rtt

       if matchmaker is not NotProvided:
           # Runtime import to avoid circular dependency
           from interactive_gym.server.matchmaker import Matchmaker as MatchmakerABC
           if not isinstance(matchmaker, MatchmakerABC):
               raise TypeError("matchmaker must be a Matchmaker subclass instance")
           self._matchmaker = matchmaker

       return self
   ```

4. Add property to access matchmaker (or None for default):
   ```python
   @property
   def matchmaker(self) -> "Matchmaker | None":
       """Return configured matchmaker, or None for default FIFO."""
       return self._matchmaker
   ```
  </action>
  <verify>
```bash
python -c "
from interactive_gym.scenes.gym_scene import GymScene
from interactive_gym.server.matchmaker import FIFOMatchmaker, Matchmaker

# Test matchmaker parameter works
scene = GymScene()
scene.matchmaking(matchmaker=FIFOMatchmaker())
assert scene.matchmaker is not None
assert isinstance(scene.matchmaker, Matchmaker)
print('PASS: matchmaker parameter accepted')

# Test default is None
scene2 = GymScene()
assert scene2.matchmaker is None
print('PASS: default is None')

# Test type validation
try:
    scene3 = GymScene()
    scene3.matchmaking(matchmaker='not a matchmaker')
except TypeError as e:
    print('PASS: type validation works')
"
```
  </verify>
  <done>
- GymScene has _matchmaker instance variable (default None)
- GymScene.matchmaking() accepts matchmaker parameter
- Type validation ensures matchmaker is Matchmaker subclass
- Property scene.matchmaker returns configured matchmaker or None
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire matchmaker from scene to GameManager in app.py</name>
  <files>interactive_gym/server/app.py</files>
  <action>
Find where GameManager is instantiated and pass the scene's matchmaker.

1. Locate GameManager instantiation in app.py (search for "GameManager("):
   ```python
   game_manager = GameManager(
       scene=scene,
       experiment_config=experiment_config,
       sio=sio,
       ...
   )
   ```

2. Add matchmaker parameter to the instantiation:
   ```python
   game_manager = GameManager(
       scene=scene,
       experiment_config=experiment_config,
       sio=sio,
       ...
       matchmaker=scene.matchmaker,  # NEW - Pass scene's configured matchmaker (or None for default)
   )
   ```

Note: GameManager.__init__() already handles None by defaulting to FIFOMatchmaker() (from Plan 55-01), so passing None is safe and maintains backward compatibility.
  </action>
  <verify>
```bash
# Verify the wiring is in place by checking the code
grep -n "matchmaker=" /Users/chasemcd/Repositories/interactive-gym/interactive_gym/server/app.py | head -5
```
  </verify>
  <done>
- GameManager instantiation in app.py includes matchmaker=scene.matchmaker
- None is passed if scene has no custom matchmaker (GameManager defaults to FIFO)
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify E2E tests pass with full wiring</name>
  <files></files>
  <action>
Run the full E2E test suite to verify:
1. Existing matchmaking behavior is preserved (FIFOMatchmaker as default)
2. No regressions in multiplayer functionality
3. All tests that exercise the waiting room and matchmaking pass

This verifies MATCH-04 (FIFOMatchmaker default implementation preserves current behavior) and MATCH-05 (matchmaker configurable per-scene).

**IMPORTANT:** E2E tests MUST be run in headed mode (not headless). This is required because Playwright's headless mode sets document.hidden=true, which causes FocusManager to skip frame processing.
  </action>
  <verify>
```bash
cd /Users/chasemcd/Repositories/interactive-gym && python -m pytest tests/e2e/ -v --timeout=180 --headed 2>&1 | tail -30
```
  </verify>
  <done>
- All E2E tests pass
- Multiplayer matchmaking works identically to before
- No regressions in waiting room functionality
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Integration test:**
```bash
python -c "
from interactive_gym.scenes.gym_scene import GymScene
from interactive_gym.server.matchmaker import FIFOMatchmaker, Matchmaker, MatchCandidate

# Create scene with custom matchmaker
class TestMatchmaker(Matchmaker):
    def find_match(self, arriving, waiting, group_size):
        # Always match immediately (for testing)
        return [arriving] + waiting[:group_size - 1] if len(waiting) + 1 >= group_size else None

scene = GymScene()
scene.matchmaking(matchmaker=TestMatchmaker())

# Verify matchmaker is accessible
assert scene.matchmaker is not None
assert isinstance(scene.matchmaker, Matchmaker)
print('PASS: Custom matchmaker configured and accessible')

# Verify default behavior
scene2 = GymScene()
assert scene2.matchmaker is None
print('PASS: Default matchmaker is None (GameManager will use FIFO)')

print('All integration tests pass')
"
```

2. **E2E verification (MUST run headed):**
```bash
cd /Users/chasemcd/Repositories/interactive-gym && python -m pytest tests/e2e/ -v --timeout=180 --headed -x
```
</verification>

<success_criteria>
- GymScene.matchmaking() accepts matchmaker parameter
- Scene stores matchmaker in _matchmaker attribute
- Type validation rejects non-Matchmaker instances
- app.py passes scene.matchmaker to GameManager
- All E2E tests pass (MATCH-04: default behavior preserved)
- Custom matchmaker can be configured per-scene (MATCH-05)
</success_criteria>

<output>
After completion, create `.planning/phases/55-matchmaker-base-class/55-02-SUMMARY.md`
</output>
