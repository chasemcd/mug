---
phase: 25-focus-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/static/js/pyodide_multiplayer_game.js
autonomous: true

must_haves:
  truths:
    - "Tab visibility changes are detected immediately via Page Visibility API"
    - "Duration of each background period is tracked with start/end timestamps"
    - "When backgrounded, local player's actions default to idle/no-op (defaultAction)"
    - "Partner inputs received via WebRTC are buffered while player is backgrounded"
  artifacts:
    - path: "interactive_gym/server/static/js/pyodide_multiplayer_game.js"
      provides: "FocusManager class with visibility detection, background state tracking, input buffering"
      contains: "class FocusManager"
    - path: "interactive_gym/server/static/js/pyodide_multiplayer_game.js"
      provides: "Integration in _handleWorkerTick and _processQueuedInputs"
      contains: "this.focusManager"
  key_links:
    - from: "FocusManager"
      to: "_handleWorkerTick"
      via: "isBackgrounded check for local input override"
      pattern: "focusManager.*isBackgrounded"
    - from: "FocusManager"
      to: "_processQueuedInputs"
      via: "skip processing when backgrounded"
      pattern: "focusManager.*isBackgrounded"
    - from: "_handleInputPacket"
      to: "backgroundInputBuffer"
      via: "buffer partner inputs when backgrounded"
      pattern: "backgroundInputBuffer"
---

<objective>
Detect when participant tabs away and handle background state for multiplayer games

Purpose: Enable graceful handling when a player tabs away - their inputs become idle/no-op, and partner inputs are buffered for later fast-forward (Phase 26). This prevents desync without interrupting the focused partner's experience.

Output: FocusManager class with visibility detection, background period tracking, local input override, and partner input buffering.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-web-worker-timer/24-01-SUMMARY.md

# Key source files
@interactive_gym/server/static/js/pyodide_multiplayer_game.js (search for GameTimerWorker, _handleWorkerTick, _handleInputPacket, _processQueuedInputs)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FocusManager class with visibility detection and background tracking</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Create a new `FocusManager` class near the top of the file (after GameTimerWorker, before the P2P message protocol section).

FocusManager responsibilities:
1. Listen for `visibilitychange` events via Page Visibility API
2. Track whether tab is currently backgrounded (`isBackgrounded` property)
3. Track background periods with timestamps (`backgroundPeriods` array of `{start, end}`)
4. Provide method to get current background period duration if backgrounded
5. Buffer partner inputs while backgrounded for later processing

Class structure:
```javascript
/**
 * FocusManager - Detects tab visibility changes and manages background state.
 *
 * When tab is backgrounded:
 * - Local player's actions default to idle/no-op (defaultAction)
 * - Partner inputs are buffered for fast-forward on refocus (Phase 26)
 * - Game loop continues via Web Worker (Phase 24)
 *
 * Different from ContinuousMonitor which handles exclusion. FocusManager
 * handles graceful background operation for multiplayer sync.
 */
class FocusManager {
    constructor() {
        this.isBackgrounded = document.hidden;
        this.backgroundStartTime = document.hidden ? performance.now() : null;
        this.backgroundPeriods = [];  // [{start: number, end: number, durationMs: number}]
        this.backgroundInputBuffer = [];  // Inputs received while backgrounded

        this._setupVisibilityListener();
    }

    _setupVisibilityListener() {
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                this._onBackgrounded();
            } else {
                this._onForegrounded();
            }
        });
    }

    _onBackgrounded() {
        this.isBackgrounded = true;
        this.backgroundStartTime = performance.now();
        p2pLog.info('Tab backgrounded - local inputs will use defaultAction');
    }

    _onForegrounded() {
        if (this.backgroundStartTime !== null) {
            const end = performance.now();
            const durationMs = end - this.backgroundStartTime;
            this.backgroundPeriods.push({
                start: this.backgroundStartTime,
                end: end,
                durationMs: durationMs
            });
            p2pLog.info(`Tab foregrounded after ${durationMs.toFixed(0)}ms - buffered ${this.backgroundInputBuffer.length} inputs`);
        }
        this.isBackgrounded = false;
        this.backgroundStartTime = null;
    }

    /**
     * Get current background duration in ms, or 0 if not backgrounded.
     */
    getCurrentBackgroundDuration() {
        if (!this.isBackgrounded || this.backgroundStartTime === null) {
            return 0;
        }
        return performance.now() - this.backgroundStartTime;
    }

    /**
     * Buffer a partner input packet received while backgrounded.
     * @param {Object} packet - Decoded input packet {playerId, inputs, currentFrame}
     */
    bufferInput(packet) {
        this.backgroundInputBuffer.push(packet);
    }

    /**
     * Drain all buffered inputs (for fast-forward on refocus).
     * @returns {Array} Array of buffered packets
     */
    drainBufferedInputs() {
        const buffered = this.backgroundInputBuffer;
        this.backgroundInputBuffer = [];
        return buffered;
    }

    /**
     * Get background periods for telemetry export.
     * @returns {Array} Array of {start, end, durationMs}
     */
    getBackgroundPeriods() {
        return [...this.backgroundPeriods];
    }

    /**
     * Reset state (e.g., on new episode).
     */
    reset() {
        this.backgroundPeriods = [];
        this.backgroundInputBuffer = [];
        // Don't reset isBackgrounded or backgroundStartTime - those reflect current state
    }

    /**
     * Destroy the manager (cleanup).
     */
    destroy() {
        // Listener cleanup not strictly needed since page will unload,
        // but good practice for testing scenarios
        this.backgroundInputBuffer = [];
    }
}
```
  </action>
  <verify>
Grep for `class FocusManager` in pyodide_multiplayer_game.js - should find the new class.
Verify the class has: isBackgrounded property, backgroundPeriods array, backgroundInputBuffer array, bufferInput/drainBufferedInputs methods.
  </verify>
  <done>
FocusManager class exists with Page Visibility API listener, background state tracking, background period recording with timestamps, and input buffering methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate FocusManager with multiplayer game loop</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Integrate FocusManager into MultiplayerPyodideGame to:
1. Use idle/no-op for local input when backgrounded
2. Buffer partner inputs when backgrounded instead of processing them
3. Clean up on game end

**Step 2a: Add focusManager property to constructor**

In the `MultiplayerPyodideGame` constructor, after the timer worker properties (around line ~700 where `this.timerWorker = null;` is), add:
```javascript
// Focus management (Phase 25)
this.focusManager = new FocusManager();
```

**Step 2b: Modify _handleInputPacket to buffer inputs when backgrounded**

In `_handleInputPacket()` method (around line 5298), modify it to buffer inputs when tab is backgrounded instead of adding to pendingInputPackets:

```javascript
_handleInputPacket(buffer) {
    const packet = decodeInputPacket(buffer);
    if (!packet) {
        p2pLog.warn('Failed to decode input packet');
        return;
    }

    // Convert numeric player index back to player ID
    const playerId = this.indexToPlayerId[packet.playerId];
    if (playerId === undefined) {
        p2pLog.warn(`Unknown player index: ${packet.playerId}`);
        return;
    }

    // Phase 25: Buffer partner inputs when tab is backgrounded
    // They'll be processed on refocus for fast-forward (Phase 26)
    if (this.focusManager && this.focusManager.isBackgrounded) {
        this.focusManager.bufferInput({
            playerId: playerId,
            inputs: packet.inputs,
            currentFrame: packet.currentFrame
        });
        p2pLog.debug(`Buffered input from player ${playerId} (backgrounded)`);
        return;
    }

    // Normal processing: queue for synchronous processing at frame start
    this.pendingInputPackets.push({
        playerId: playerId,
        inputs: packet.inputs,
        currentFrame: packet.currentFrame
    });

    // Track P2P input reception for metrics
    this.p2pMetrics.inputsReceivedViaP2P++;

    // Update connection health monitor
    if (this.connectionHealth) {
        this.connectionHealth.recordReceivedInput(packet.currentFrame);
    }
}
```

**Step 2c: Modify _handleWorkerTick to skip game logic when backgrounded**

In `_handleWorkerTick()` method (around line 4524), add a check to skip processing when backgrounded. When backgrounded, the game loop still "ticks" but local input becomes defaultAction and we don't advance the simulation frame (partner will continue playing; we'll catch up on refocus).

```javascript
_handleWorkerTick(timestamp) {
    // Skip if game is done
    if (this.state === 'done') {
        return;
    }

    // Skip if paused for reconnection (Phase 20)
    if (this.reconnectionState.isPaused) {
        return;
    }

    // Phase 25: Skip processing when tab is backgrounded
    // Worker keeps ticking (so we know elapsed time), but we don't advance frames.
    // Partner inputs are buffered; we'll fast-forward on refocus (Phase 26).
    if (this.focusManager && this.focusManager.isBackgrounded) {
        return;
    }

    // Skip if already processing a tick (prevents overlapping async operations)
    if (this.isProcessingTick) {
        return;
    }

    // Mark as processing - will be cleared by callback when complete
    this.isProcessingTick = true;

    // Trigger the registered tick callback (Phaser's processPyodideGame)
    if (this.tickCallback) {
        this.tickCallback();
    } else {
        // No callback registered, clear processing flag
        this.isProcessingTick = false;
    }
}
```

**Step 2d: Clean up FocusManager on game termination**

Find the `_destroyTimerWorker()` method (around line 4565) and add FocusManager cleanup there:

```javascript
_destroyTimerWorker() {
    if (this.timerWorker) {
        this.timerWorker.destroy();
        this.timerWorker = null;
        p2pLog.info('Web Worker timer destroyed');
    }
    // Phase 25: Clean up focus manager
    if (this.focusManager) {
        this.focusManager.destroy();
    }
}
```

**Step 2e: Reset FocusManager on episode reset**

In `resetGameState()` method (around line 4159), add:
```javascript
// Phase 25: Reset focus tracking for new episode
if (this.focusManager) {
    this.focusManager.reset();
}
```
  </action>
  <verify>
1. Grep for `this.focusManager = new FocusManager` - should find initialization in constructor
2. Grep for `focusManager.isBackgrounded` in _handleInputPacket - should find buffering logic
3. Grep for `focusManager.isBackgrounded` in _handleWorkerTick - should find skip logic
4. Grep for `focusManager.destroy` in _destroyTimerWorker - should find cleanup
5. Grep for `focusManager.reset` in resetGameState - should find reset call
  </verify>
  <done>
FocusManager is instantiated in constructor, integrated with _handleInputPacket (buffer partner inputs), _handleWorkerTick (skip processing when backgrounded), and properly cleaned up on game termination and episode reset.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify background behavior with console logging</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Add diagnostic logging to verify the focus detection system works correctly. This helps with testing and provides telemetry for Phase 27.

**Step 3a: Add periodic background status logging in _handleWorkerTick**

When backgrounded, log the current background duration every 5 seconds (roughly - we'll use frame count approximation). Add this at the start of `_handleWorkerTick` after the background check:

```javascript
_handleWorkerTick(timestamp) {
    // ... existing checks ...

    // Phase 25: Skip processing when tab is backgrounded
    if (this.focusManager && this.focusManager.isBackgrounded) {
        // Log background status periodically (every ~50 ticks at 10 FPS = 5 seconds)
        if (!this._backgroundLogCounter) this._backgroundLogCounter = 0;
        this._backgroundLogCounter++;
        if (this._backgroundLogCounter % 50 === 0) {
            const duration = this.focusManager.getCurrentBackgroundDuration();
            const buffered = this.focusManager.backgroundInputBuffer.length;
            p2pLog.info(`Still backgrounded: ${(duration/1000).toFixed(1)}s, ${buffered} inputs buffered`);
        }
        return;
    }
    // Reset counter when not backgrounded
    this._backgroundLogCounter = 0;

    // ... rest of method ...
}
```

**Step 3b: Log background periods on foregrounding**

The FocusManager already logs on foreground, but enhance it to show total periods:

In FocusManager._onForegrounded(), after pushing the new period:
```javascript
_onForegrounded() {
    if (this.backgroundStartTime !== null) {
        const end = performance.now();
        const durationMs = end - this.backgroundStartTime;
        this.backgroundPeriods.push({
            start: this.backgroundStartTime,
            end: end,
            durationMs: durationMs
        });
        const totalPeriods = this.backgroundPeriods.length;
        const totalDuration = this.backgroundPeriods.reduce((sum, p) => sum + p.durationMs, 0);
        p2pLog.info(`Tab foregrounded after ${durationMs.toFixed(0)}ms - buffered ${this.backgroundInputBuffer.length} inputs (${totalPeriods} periods, ${(totalDuration/1000).toFixed(1)}s total)`);
    }
    this.isBackgrounded = false;
    this.backgroundStartTime = null;
}
```

**Step 3c: Add method to export focus telemetry**

Add a method to FocusManager that Phase 27 can use for telemetry export:

```javascript
/**
 * Get focus telemetry for session export.
 * @returns {Object} {backgroundPeriods: Array, totalBackgroundMs: number, periodCount: number}
 */
getTelemetry() {
    const periods = this.getBackgroundPeriods();
    const totalMs = periods.reduce((sum, p) => sum + p.durationMs, 0);
    return {
        backgroundPeriods: periods,
        totalBackgroundMs: totalMs,
        periodCount: periods.length,
        currentlyBackgrounded: this.isBackgrounded,
        bufferedInputCount: this.backgroundInputBuffer.length
    };
}
```
  </action>
  <verify>
1. Grep for `_backgroundLogCounter` - should find periodic logging logic
2. Grep for `getTelemetry` in FocusManager - should find telemetry export method
3. Grep for `totalPeriods` - should find enhanced foreground logging
  </verify>
  <done>
Diagnostic logging added for background state monitoring. Periodic logs during background, enhanced foreground logs with totals, and getTelemetry() method for Phase 27 export.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **FOCUS-01 - Tab visibility detection:**
   - FocusManager listens to `visibilitychange` event
   - `isBackgrounded` property reflects current state
   - Logging confirms detection works

2. **FOCUS-02 - Background period tracking:**
   - `backgroundPeriods` array stores `{start, end, durationMs}` for each period
   - `getCurrentBackgroundDuration()` returns live duration
   - `getTelemetry()` provides export-ready data

3. **BG-01 - Idle/no-op for backgrounded player:**
   - `_handleWorkerTick()` skips processing when backgrounded
   - Local player doesn't send inputs (keyboard isn't read)
   - Game loop doesn't advance frames while backgrounded (partner continues; we catch up later)

4. **BG-02 - Partner input buffering:**
   - `_handleInputPacket()` routes to `focusManager.bufferInput()` when backgrounded
   - Inputs stored in `backgroundInputBuffer` array
   - `drainBufferedInputs()` ready for Phase 26 fast-forward

Run verification:
```bash
grep -n "class FocusManager" interactive_gym/server/static/js/pyodide_multiplayer_game.js
grep -n "focusManager.isBackgrounded" interactive_gym/server/static/js/pyodide_multiplayer_game.js
grep -n "bufferInput\|drainBufferedInputs" interactive_gym/server/static/js/pyodide_multiplayer_game.js
```
</verification>

<success_criteria>
1. FocusManager class exists with Page Visibility API integration
2. Background periods tracked with start/end timestamps
3. _handleWorkerTick skips frame processing when backgrounded
4. _handleInputPacket buffers partner inputs when backgrounded
5. Cleanup on game termination and episode reset
6. Telemetry method ready for Phase 27 export
</success_criteria>

<output>
After completion, create `.planning/phases/25-focus-detection/25-01-SUMMARY.md` using the summary template.
</output>
