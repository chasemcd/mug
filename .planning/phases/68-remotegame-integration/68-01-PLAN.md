---
phase: 68-remotegame-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/static/js/pyodide_remote_game.js
  - interactive_gym/server/static/js/pyodide_worker.js
autonomous: true

must_haves:
  truths:
    - "RemoteGame initializes without blocking the main thread"
    - "Single-player step() executes via Worker postMessage round-trip"
    - "Single-player reset() executes via Worker postMessage round-trip"
    - "render_state arrives on main thread for Phaser rendering"
    - "Existing single-player demo works identically to before"
  artifacts:
    - path: "interactive_gym/server/static/js/pyodide_remote_game.js"
      provides: "RemoteGame using PyodideWorker"
      contains: "PyodideWorker"
    - path: "interactive_gym/server/static/js/pyodide_worker.js"
      provides: "Worker with on_game_step_code support"
      contains: "on_game_step_code"
  key_links:
    - from: "interactive_gym/server/static/js/pyodide_remote_game.js"
      to: "interactive_gym/server/static/js/PyodideWorker.js"
      via: "import and instantiation"
      pattern: "import.*PyodideWorker"
    - from: "interactive_gym/server/static/js/pyodide_remote_game.js"
      to: "/api/step"
      via: "worker.step() async call"
      pattern: "this\\.worker\\.step"
---

<objective>
Migrate the single-player RemoteGame class to use PyodideWorker for all Pyodide operations.

Purpose: Move Pyodide execution off the main thread so Socket.IO can respond to pings during initialization and game execution. This addresses the root cause of false disconnects during concurrent game startup.

Output:
- Modified `pyodide_remote_game.js` that uses PyodideWorker instead of direct Pyodide calls
- Modified `pyodide_worker.js` with support for environment-specific code injection
- Single-player games work identically to before (backward compatible)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/67-core-worker-infrastructure/67-01-SUMMARY.md

# Key files for this phase
@interactive_gym/server/static/js/pyodide_remote_game.js
@interactive_gym/server/static/js/PyodideWorker.js
@interactive_gym/server/static/js/pyodide_worker.js
@interactive_gym/server/static/js/phaser_gym_graphics.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend pyodide_worker.js for environment code injection</name>
  <files>interactive_gym/server/static/js/pyodide_worker.js</files>
  <action>
Modify `pyodide_worker.js` to support the RemoteGame's environment-specific features:

1. **Update handleInitEnv** to accept `on_game_step_code` in payload:
   - Store `on_game_step_code` in Worker global scope for use in step()
   - The existing envCode execution is sufficient for environment initialization

2. **Update handleStep** to:
   - Execute `on_game_step_code` before the step (if provided during initEnv)
   - Handle obs/rewards/terminateds/truncateds normalization in Python:
     - Convert non-dict obs to dict with "human" key
     - Convert scalar rewards to dict with "human" key
     - Convert boolean terminateds/truncateds to dict with "human" key
   - Return render_state as-is (no modification needed - Phaser handles it)

3. **Update handleReset** to:
   - Apply same obs normalization as step()
   - Return render_state as-is

The Python code patterns for normalization come from the existing `pyodide_remote_game.js` step() and reset() methods:

```python
# Obs normalization
if not isinstance(obs, dict):
    obs = obs.reshape(-1).astype(np.float32)
elif isinstance(obs, dict) and isinstance([*obs.values()][0], dict):
    obs = {k: {kk: vv.reshape(-1).astype(np.float32) for kk, vv in v.items()} for k, v in obs.items()}
elif isinstance(obs, dict):
    obs = {k: v.reshape(-1).astype(np.float32) for k, v in obs.items()}

if not isinstance(obs, dict):
    obs = {"human": obs}

# Rewards normalization
if isinstance(rewards, (float, int)):
    rewards = {"human": rewards}

# terminateds/truncateds normalization
if not isinstance(terminateds, dict):
    terminateds = {"human": terminateds}
if not isinstance(truncateds, dict):
    truncateds = {"human": truncateds}
```

Note: The render_state processing (RGB array to canvas) happens on the main thread in RemoteGame, not in the Worker. The Worker just passes render_state through.
  </action>
  <verify>
1. `cat interactive_gym/server/static/js/pyodide_worker.js | grep -A5 "on_game_step_code"` shows storage of step code
2. `cat interactive_gym/server/static/js/pyodide_worker.js | grep "isinstance(obs, dict)"` shows normalization logic
3. No syntax errors: `node --check interactive_gym/server/static/js/pyodide_worker.js` (should fail gracefully since it uses importScripts)
  </verify>
  <done>
pyodide_worker.js handles environment initialization with on_game_step_code, applies obs/rewards normalization in step/reset, and returns properly structured results.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate RemoteGame to use PyodideWorker</name>
  <files>interactive_gym/server/static/js/pyodide_remote_game.js</files>
  <action>
Rewrite `pyodide_remote_game.js` to use `PyodideWorker` instead of direct Pyodide calls:

1. **Add import** at top of file:
   ```javascript
   import { PyodideWorker } from './PyodideWorker.js';
   ```

2. **Modify constructor**:
   - Replace `this.pyodide = null` with `this.worker = null`
   - Remove `this.micropip = null` (handled by Worker)
   - Keep all other attributes (config, state, step_num, etc.)

3. **Rewrite initialize()**:
   ```javascript
   async initialize() {
       // Create Worker with progress callback
       this.worker = new PyodideWorker({
           onProgress: (stage, message) => {
               console.log(`[RemoteGame:${stage}] ${message}`);
           }
       });

       // Initialize Worker (loads Pyodide in background)
       await this.worker.init();

       // Install required packages
       if (this.config.packages_to_install?.length > 0) {
           console.log("Installing packages via Worker:", this.config.packages_to_install);
           await this.worker.installPackages(this.config.packages_to_install);
           this.installed_packages.push(...this.config.packages_to_install);
       }

       // Initialize environment with code injection
       // Build envCode that sets up globals and creates env
       const envCode = `
import js
interactive_gym_globals = dict(js.window.interactiveGymGlobals.object_entries())
${this.config.environment_initialization_code}
       `;

       await this.worker.initEnv(envCode, {
           on_game_step_code: this.config.on_game_step_code || ''
       });

       this.state = "ready";
       this.pyodideReady = true;
   }
   ```

4. **Rewrite reinitialize_environment()**:
   - Check for new packages and install via `this.worker.installPackages()`
   - Re-run `this.worker.initEnv()` with new config
   - Call `this.setAttributes(config)` as before

5. **Rewrite reset()**:
   ```javascript
   async reset() {
       this.shouldReset = false;
       console.log("Resetting the environment");

       await this.showEpisodeTransition();

       const startTime = performance.now();
       const result = await this.worker.reset();
       const endTime = performance.now();
       console.log(`Reset operation took ${endTime - startTime} milliseconds`);

       let { obs, infos, render_state } = result;

       // Convert obs Map to proper format if needed (Worker returns JS objects)
       obs = this._convertObsToMap(obs);

       // Process render_state (RGB array to binary image) - same as before
       render_state = this._processRenderState(render_state);

       this.step_num = 0;
       // ... rest of existing reset logic (cumulative_rewards, HUD)

       return [obs, infos, render_state];
   }
   ```

6. **Rewrite step()**:
   ```javascript
   async step(actions) {
       this.pipelineMetrics.stepCallTimestamp = performance.now();

       const result = await this.worker.step(actions);

       this.pipelineMetrics.stepReturnTimestamp = performance.now();

       let { obs, rewards, terminateds, truncateds, infos, render_state } = result;

       // Convert to Maps for consistency with existing code
       obs = this._convertObsToMap(obs);
       rewards = this._convertToMap(rewards);
       terminateds = this._convertToMap(terminateds);
       truncateds = this._convertToMap(truncateds);

       // ... rest of existing step logic (cumulative_rewards, render_state processing, episode completion)

       return [obs, rewards, terminateds, truncateds, infos, render_state];
   }
   ```

7. **Add helper methods** for data conversion:
   ```javascript
   _convertObsToMap(obs) {
       // Worker returns plain objects, convert to Map for compatibility
       if (obs instanceof Map) return obs;
       return new Map(Object.entries(obs));
   }

   _convertToMap(obj) {
       if (obj instanceof Map) return obj;
       return new Map(Object.entries(obj));
   }

   _processRenderState(render_state) {
       // Keep existing RGB array to binary image conversion logic
       // Returns { game_state_objects, game_image_base64, step }
   }
   ```

8. **Add cleanup** - Add destroy method for proper cleanup:
   ```javascript
   destroy() {
       if (this.worker) {
           this.worker.destroy();
           this.worker = null;
       }
   }
   ```

Key differences from before:
- No direct `this.pyodide.runPythonAsync()` calls
- All Python execution goes through `this.worker.step()` / `this.worker.reset()`
- Data comes back as plain JS objects (not PyProxy), convert to Map for compatibility

Preserve all existing features:
- Pipeline latency metrics (setInputTimestamps, logPipelineLatency)
- Episode transition UI (showEpisodeTransition)
- HUD updates (getHUDText, updateHUDText)
- Episode completion detection and data emission
  </action>
  <verify>
1. File has PyodideWorker import: `grep "import.*PyodideWorker" interactive_gym/server/static/js/pyodide_remote_game.js`
2. No direct loadPyodide calls: `grep "loadPyodide" interactive_gym/server/static/js/pyodide_remote_game.js` returns nothing
3. Uses worker.step(): `grep "this.worker.step" interactive_gym/server/static/js/pyodide_remote_game.js`
4. Uses worker.reset(): `grep "this.worker.reset" interactive_gym/server/static/js/pyodide_remote_game.js`
5. No syntax errors visible in file structure
  </verify>
  <done>
RemoteGame class uses PyodideWorker for all Pyodide operations. Initialize, step, reset, and reinitialize all go through Worker postMessage. Existing API surface unchanged (constructor signature, step/reset return values, HUD, episode handling).
  </done>
</task>

<task type="auto">
  <name>Task 3: Browser verification and backward compatibility test</name>
  <files>interactive_gym/server/static/js/test_pyodide_worker.html</files>
  <action>
Update the existing test page to verify RemoteGame integration works correctly:

1. **Extend test_pyodide_worker.html** to include a RemoteGame test section:
   - Add a "Test RemoteGame" button
   - Create a minimal config object matching RemoteGame constructor expectations
   - Test initialize() -> reset() -> step() -> step() -> step() sequence
   - Verify render_state comes back with expected structure
   - Log all results to the page

2. **Add test config** matching single-player demo structure:
   ```javascript
   const testConfig = {
       scene_id: 'test_scene',
       interactive_gym_globals: {},
       packages_to_install: [],  // No extra packages for basic test
       environment_initialization_code: `
import gymnasium
env = gymnasium.make("CartPole-v1", render_mode="rgb_array")
       `,
       on_game_step_code: '',
       num_episodes: 1,
       max_steps: 100,
       fps: 10,
       hud_score_carry_over: false
   };
   ```

3. **Add test sequence**:
   ```javascript
   async function testRemoteGame() {
       log('Creating RemoteGame...');
       const game = new RemoteGame(testConfig);

       // Wait for initialization
       while (!game.pyodideReady) {
           await new Promise(r => setTimeout(r, 100));
           log('Waiting for pyodideReady...');
       }
       log('RemoteGame initialized!');

       // Test reset
       const [obs, infos, render_state] = await game.reset();
       log(`Reset: obs keys=${[...obs.keys()]}, render_state.step=${render_state.step}`);

       // Test a few steps
       for (let i = 0; i < 3; i++) {
           const actions = { 0: Math.floor(Math.random() * 2) };
           const [obs2, rewards, terminateds, truncateds, infos2, render_state2] = await game.step(actions);
           log(`Step ${i+1}: rewards=${[...rewards.values()][0]}, step=${render_state2.step}`);
       }

       log('RemoteGame test complete!');
       game.destroy();
   }
   ```

4. **Verify non-blocking behavior**:
   - Keep the existing ping interval test
   - RemoteGame initialization should NOT block pings
   - Log ping count during RemoteGame init to prove non-blocking

5. **Add import** for RemoteGame module:
   - Need to use ES6 module script tag
   - Or inline the test to avoid module loading complexity
  </action>
  <verify>
Manual browser test:
1. Start dev server: `python -m interactive_gym.run`
2. Open browser to `http://localhost:5001/static/js/test_pyodide_worker.html`
3. Click "Test RemoteGame" button
4. Verify:
   - Pings continue during initialization (non-blocking proven)
   - Reset returns obs Map with keys, render_state with step=0
   - Step returns rewards, incremented step numbers
   - No console errors
  </verify>
  <done>
Browser test page verifies RemoteGame works with PyodideWorker backend. Non-blocking initialization proven by ping continuity. Reset and step operations return expected data structures.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Code verification:**
   - `pyodide_remote_game.js` imports and uses PyodideWorker
   - `pyodide_worker.js` handles on_game_step_code and normalization
   - No direct Pyodide calls remain in RemoteGame

2. **Functional verification:**
   - Browser test page shows RemoteGame working
   - Pings not blocked during initialization
   - Step/reset return correct data structures

3. **Backward compatibility:**
   - Existing single-player demos should work unchanged
   - No API surface changes to RemoteGame
   - index.js instantiation unchanged
</verification>

<success_criteria>
Phase 68 is complete when:
1. RemoteGame.initialize() uses PyodideWorker.init() and installPackages()
2. RemoteGame.step() uses PyodideWorker.step() (postMessage round-trip)
3. RemoteGame.reset() uses PyodideWorker.reset() (postMessage round-trip)
4. render_state arrives on main thread (Phaser receives it via addStateToBuffer)
5. Browser test demonstrates non-blocking initialization
6. Single-player games work identically to before (backward compatible)
</success_criteria>

<output>
After completion, create `.planning/phases/68-remotegame-integration/68-01-SUMMARY.md`
</output>
