---
phase: 68-remotegame-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/static/js/pyodide_remote_game.js
  - interactive_gym/server/static/js/pyodide_worker.js
autonomous: true

must_haves:
  truths:
    - "RemoteGame initializes without blocking the main thread"
    - "Single-player step() executes via Worker postMessage round-trip"
    - "Single-player reset() executes via Worker postMessage round-trip"
    - "render_state arrives on main thread for Phaser rendering"
    - "Existing single-player demo works identically to before"
  artifacts:
    - path: "interactive_gym/server/static/js/pyodide_remote_game.js"
      provides: "RemoteGame using PyodideWorker"
      contains: "PyodideWorker"
    - path: "interactive_gym/server/static/js/pyodide_worker.js"
      provides: "Worker with on_game_step_code support"
      contains: "on_game_step_code"
  key_links:
    - from: "interactive_gym/server/static/js/pyodide_remote_game.js"
      to: "interactive_gym/server/static/js/PyodideWorker.js"
      via: "import and instantiation"
      pattern: "import.*PyodideWorker"
    - from: "interactive_gym/server/static/js/pyodide_remote_game.js"
      to: "/api/step"
      via: "worker.step() async call"
      pattern: "this\\.worker\\.step"
---

<objective>
Migrate the single-player RemoteGame class to use PyodideWorker for all Pyodide operations.

Purpose: Move Pyodide execution off the main thread so Socket.IO can respond to pings during initialization and game execution. This addresses the root cause of false disconnects during concurrent game startup.

Output:
- Modified `pyodide_remote_game.js` that uses PyodideWorker instead of direct Pyodide calls
- Modified `pyodide_worker.js` with support for environment-specific code injection
- Single-player games work identically to before (backward compatible)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/67-core-worker-infrastructure/67-01-SUMMARY.md

# Key files for this phase
@interactive_gym/server/static/js/pyodide_remote_game.js
@interactive_gym/server/static/js/PyodideWorker.js
@interactive_gym/server/static/js/pyodide_worker.js
@interactive_gym/server/static/js/phaser_gym_graphics.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend pyodide_worker.js for environment code injection</name>
  <files>interactive_gym/server/static/js/pyodide_worker.js</files>
  <action>
Modify `pyodide_worker.js` to support the RemoteGame's environment-specific features:

1. **Add Worker-level storage for on_game_step_code** at the top with other globals:
   ```javascript
   // READY gate pattern - prevents race conditions
   let pyodide = null;
   let pyodideReady = false;
   const messageQueue = [];
   let onGameStepCode = '';  // <-- ADD THIS LINE: Stores code to run before each step
   ```

2. **Update handleInitEnv** to extract and store `on_game_step_code` from globals:
   ```javascript
   async function handleInitEnv(id, payload) {
       // Extract on_game_step_code if present, store in Worker-level variable
       // Remove it from globals before setting Python globals
       if (payload.globals) {
           if (payload.globals.on_game_step_code !== undefined) {
               onGameStepCode = payload.globals.on_game_step_code || '';
               delete payload.globals.on_game_step_code;  // Don't set as Python global
           }
           for (const [key, value] of Object.entries(payload.globals)) {
               pyodide.globals.set(key, pyodide.toPy(value));
           }
       }

       // Run environment initialization code
       await pyodide.runPythonAsync(payload.envCode);

       self.postMessage({ type: 'envReady', id });
   }
   ```

3. **Update handleStep** to inject `on_game_step_code` and apply normalization:
   ```javascript
   async function handleStep(id, payload) {
       // Convert actions to Python-compatible format
       const pyActions = JSON.stringify(payload.actions);

       // Build Python code: on_game_step_code first, then step, then normalize
       const result = await pyodide.runPythonAsync(`
   import json
   import numpy as np

   # Run any environment-specific pre-step code (e.g., policy calls)
   ${onGameStepCode}

   agent_actions = json.loads('''${pyActions}''')
   obs, rewards, terminateds, truncateds, infos = env.step(agent_actions)
   render_state = env.render()

   # Normalize obs to dict with numpy arrays flattened
   if not isinstance(obs, dict):
       obs = obs.reshape(-1).astype(np.float32)
   elif isinstance(obs, dict) and len(obs) > 0 and isinstance([*obs.values()][0], dict):
       obs = {k: {kk: vv.reshape(-1).astype(np.float32) for kk, vv in v.items()} for k, v in obs.items()}
   elif isinstance(obs, dict):
       obs = {k: v.reshape(-1).astype(np.float32) if hasattr(v, 'reshape') else v for k, v in obs.items()}

   if not isinstance(obs, dict):
       obs = {"human": obs}

   # Normalize rewards to dict
   if isinstance(rewards, (float, int)):
       rewards = {"human": rewards}

   # Normalize terminateds/truncateds to dict
   if not isinstance(terminateds, dict):
       terminateds = {"human": terminateds}
   if not isinstance(truncateds, dict):
       truncateds = {"human": truncateds}

   (obs, rewards, terminateds, truncateds, infos, render_state)
       `);

       // Convert PyProxy to JS objects for transfer across Worker boundary
       const jsResult = result.toJs({ depth: 2 });
       result.destroy();  // Prevent memory leak

       const [obs, rewards, terminateds, truncateds, infos, render_state] = jsResult;

       self.postMessage({
           type: 'result',
           id,
           result: { obs, rewards, terminateds, truncateds, infos, render_state }
       });
   }
   ```

4. **Update handleReset** to apply same obs normalization:
   ```javascript
   async function handleReset(id, payload) {
       const seedValue = payload.seed !== null && payload.seed !== undefined
           ? payload.seed
           : 'None';

       const result = await pyodide.runPythonAsync(`
   import numpy as np
   obs, infos = env.reset(seed=${seedValue})
   render_state = env.render()

   # Normalize obs to dict with numpy arrays flattened
   if not isinstance(obs, dict):
       obs = obs.reshape(-1).astype(np.float32)
   elif isinstance(obs, dict) and len(obs) > 0 and isinstance([*obs.values()][0], dict):
       obs = {k: {kk: vv.reshape(-1).astype(np.float32) for kk, vv in v.items()} for k, v in obs.items()}
   elif isinstance(obs, dict):
       obs = {k: v.reshape(-1).astype(np.float32) if hasattr(v, 'reshape') else v for k, v in obs.items()}

   if not isinstance(obs, dict):
       obs = {"human": obs}

   (obs, infos, render_state)
       `);

       // Convert PyProxy to JS objects for transfer
       const jsResult = result.toJs({ depth: 2 });
       result.destroy();  // Prevent memory leak

       const [obs, infos, render_state] = jsResult;

       self.postMessage({
           type: 'result',
           id,
           result: { obs, infos, render_state }
       });
   }
   ```

Note: The render_state processing (RGB array to canvas) happens on the main thread in RemoteGame, not in the Worker. The Worker just passes render_state through.
  </action>
  <verify>
1. `grep "let onGameStepCode" interactive_gym/server/static/js/pyodide_worker.js` shows Worker-level storage
2. `grep -A3 "payload.globals.on_game_step_code" interactive_gym/server/static/js/pyodide_worker.js` shows extraction and deletion from globals
3. `grep "onGameStepCode}" interactive_gym/server/static/js/pyodide_worker.js` shows injection in step (template literal)
4. `grep "isinstance(obs, dict)" interactive_gym/server/static/js/pyodide_worker.js` shows normalization logic
  </verify>
  <done>
pyodide_worker.js stores on_game_step_code in Worker-level variable during initEnv, injects it into Python execution string before step(), applies obs/rewards normalization in step/reset, and returns properly structured results.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate RemoteGame to use PyodideWorker</name>
  <files>interactive_gym/server/static/js/pyodide_remote_game.js</files>
  <action>
Rewrite `pyodide_remote_game.js` to use `PyodideWorker` instead of direct Pyodide calls:

1. **Add import** at top of file:
   ```javascript
   import { PyodideWorker } from './PyodideWorker.js';
   ```

2. **Modify constructor**:
   - Replace `this.pyodide = null` with `this.worker = null`
   - Remove `this.micropip = null` (handled by Worker)
   - Keep all other attributes (config, state, step_num, etc.)

3. **Rewrite initialize()**:
   ```javascript
   async initialize() {
       // Create Worker with progress callback
       this.worker = new PyodideWorker({
           onProgress: (stage, message) => {
               console.log(`[RemoteGame:${stage}] ${message}`);
           }
       });

       // Initialize Worker (loads Pyodide in background)
       await this.worker.init();

       // Install required packages
       if (this.config.packages_to_install?.length > 0) {
           console.log("Installing packages via Worker:", this.config.packages_to_install);
           await this.worker.installPackages(this.config.packages_to_install);
           this.installed_packages.push(...this.config.packages_to_install);
       }

       // Initialize environment with code injection
       // Build envCode that sets up globals and creates env
       const envCode = `
import js
interactive_gym_globals = dict(js.window.interactiveGymGlobals.object_entries())
${this.config.environment_initialization_code}
       `;

       await this.worker.initEnv(envCode, {
           on_game_step_code: this.config.on_game_step_code || ''
       });

       this.state = "ready";
       this.pyodideReady = true;
   }
   ```

4. **Rewrite reinitialize_environment()**:
   - Check for new packages and install via `this.worker.installPackages()`
   - Re-run `this.worker.initEnv()` with new config
   - Call `this.setAttributes(config)` as before

5. **Rewrite reset()**:
   ```javascript
   async reset() {
       this.shouldReset = false;
       console.log("Resetting the environment");

       await this.showEpisodeTransition();

       const startTime = performance.now();
       const result = await this.worker.reset();
       const endTime = performance.now();
       console.log(`Reset operation took ${endTime - startTime} milliseconds`);

       let { obs, infos, render_state } = result;

       // Convert obs Map to proper format if needed (Worker returns JS objects)
       obs = this._convertObsToMap(obs);

       // Process render_state (RGB array to binary image) - same as before
       render_state = this._processRenderState(render_state);

       this.step_num = 0;
       // ... rest of existing reset logic (cumulative_rewards, HUD)

       return [obs, infos, render_state];
   }
   ```

6. **Rewrite step()**:
   ```javascript
   async step(actions) {
       this.pipelineMetrics.stepCallTimestamp = performance.now();

       const result = await this.worker.step(actions);

       this.pipelineMetrics.stepReturnTimestamp = performance.now();

       let { obs, rewards, terminateds, truncateds, infos, render_state } = result;

       // Convert to Maps for consistency with existing code
       obs = this._convertObsToMap(obs);
       rewards = this._convertToMap(rewards);
       terminateds = this._convertToMap(terminateds);
       truncateds = this._convertToMap(truncateds);

       // ... rest of existing step logic (cumulative_rewards, render_state processing, episode completion)

       return [obs, rewards, terminateds, truncateds, infos, render_state];
   }
   ```

7. **Add helper methods** for data conversion:
   ```javascript
   _convertObsToMap(obs) {
       // Worker returns plain objects, convert to Map for compatibility
       if (obs instanceof Map) return obs;
       return new Map(Object.entries(obs));
   }

   _convertToMap(obj) {
       if (obj instanceof Map) return obj;
       return new Map(Object.entries(obj));
   }

   _processRenderState(render_state) {
       // Keep existing RGB array to binary image conversion logic
       // Returns { game_state_objects, game_image_base64, step }
   }
   ```

8. **Add cleanup** - Add destroy method for proper cleanup:
   ```javascript
   destroy() {
       if (this.worker) {
           this.worker.destroy();
           this.worker = null;
       }
   }
   ```

Key differences from before:
- No direct `this.pyodide.runPythonAsync()` calls
- All Python execution goes through `this.worker.step()` / `this.worker.reset()`
- Data comes back as plain JS objects (not PyProxy), convert to Map for compatibility

Preserve all existing features:
- Pipeline latency metrics (setInputTimestamps, logPipelineLatency)
- Episode transition UI (showEpisodeTransition)
- HUD updates (getHUDText, updateHUDText)
- Episode completion detection and data emission
  </action>
  <verify>
1. File has PyodideWorker import: `grep "import.*PyodideWorker" interactive_gym/server/static/js/pyodide_remote_game.js`
2. No direct loadPyodide calls: `grep "loadPyodide" interactive_gym/server/static/js/pyodide_remote_game.js` returns nothing
3. Uses worker.step(): `grep "this.worker.step" interactive_gym/server/static/js/pyodide_remote_game.js`
4. Uses worker.reset(): `grep "this.worker.reset" interactive_gym/server/static/js/pyodide_remote_game.js`
5. No syntax errors visible in file structure
  </verify>
  <done>
RemoteGame class uses PyodideWorker for all Pyodide operations. Initialize, step, reset, and reinitialize all go through Worker postMessage. Existing API surface unchanged (constructor signature, step/reset return values, HUD, episode handling).
  </done>
</task>

<task type="auto">
  <name>Task 3: Browser verification test for PyodideWorker with RemoteGame-like operations</name>
  <files>interactive_gym/server/static/js/test_pyodide_worker.html</files>
  <action>
Update the existing test page to verify PyodideWorker supports RemoteGame operations. Test the Worker directly rather than instantiating RemoteGame (which has ES6 module dependencies that complicate browser testing).

1. **Add "Test RemoteGame Operations" section** to the existing test page that exercises the exact sequence RemoteGame uses:

2. **Test initEnv with on_game_step_code in globals**:
   ```javascript
   async function testRemoteGameOperations() {
       log('=== Testing RemoteGame-like operations ===');

       // Create fresh worker
       const worker = new PyodideWorker({
           onProgress: (stage, msg) => log(`[Progress:${stage}] ${msg}`)
       });

       await worker.init();
       log('Worker initialized');

       // Test initEnv with on_game_step_code (like RemoteGame does)
       const envCode = `
import gymnasium
env = gymnasium.make("CartPole-v1", render_mode="rgb_array")
print("Environment created!")
       `;

       // Pass on_game_step_code in globals - Worker should extract and store it
       await worker.initEnv(envCode, {
           on_game_step_code: '# Pre-step code would go here\npass'
       });
       log('Environment initialized with on_game_step_code');

       // Test reset - verify obs normalization to dict with "human" key
       const resetResult = await worker.reset();
       log(`Reset result: obs keys = ${Object.keys(resetResult.obs)}`);
       log(`  - Has "human" key: ${resetResult.obs.hasOwnProperty("human")}`);
       log(`  - render_state present: ${resetResult.render_state !== undefined}`);

       // Test step - verify rewards/terminateds/truncateds normalization
       const stepResult = await worker.step({ 0: 1 });
       log(`Step result:`);
       log(`  - obs keys: ${Object.keys(stepResult.obs)}`);
       log(`  - rewards keys: ${Object.keys(stepResult.rewards)}`);
       log(`  - terminateds keys: ${Object.keys(stepResult.terminateds)}`);
       log(`  - truncateds keys: ${Object.keys(stepResult.truncateds)}`);

       // Verify all are normalized to dicts with expected keys
       const hasHumanKeys =
           stepResult.obs.hasOwnProperty("human") &&
           stepResult.rewards.hasOwnProperty("human") &&
           stepResult.terminateds.hasOwnProperty("human") &&
           stepResult.truncateds.hasOwnProperty("human");

       log(`All results normalized to dicts with "human" key: ${hasHumanKeys}`);

       // Run a few more steps to ensure stability
       for (let i = 0; i < 3; i++) {
           const r = await worker.step({ 0: Math.floor(Math.random() * 2) });
           log(`Step ${i+2}: reward=${r.rewards.human}, terminated=${r.terminateds.human}`);
       }

       worker.destroy();
       log('=== RemoteGame operations test complete ===');

       return hasHumanKeys;
   }
   ```

3. **Add button to trigger test**:
   ```html
   <button onclick="testRemoteGameOperations()">Test RemoteGame Operations</button>
   ```

4. **Verify non-blocking behavior** by running ping interval alongside:
   - Keep the existing ping counter
   - Start pings before test, verify they continue during initEnv
   - Log ping count at key points to prove non-blocking

5. **Key verifications**:
   - initEnv accepts globals with on_game_step_code
   - reset() returns obs as dict with "human" key (not raw numpy array)
   - step() returns rewards/terminateds/truncateds as dicts with "human" key
   - render_state passes through from Python
   - Pings not blocked during any operation
  </action>
  <verify>
Manual browser test:
1. Start dev server: `python -m interactive_gym.run`
2. Open browser to `http://localhost:5001/static/js/test_pyodide_worker.html`
3. Click "Test RemoteGame Operations" button
4. Verify:
   - Pings continue during initialization (non-blocking proven)
   - Reset returns obs with "human" key
   - Step returns rewards/terminateds/truncateds with "human" keys
   - All logged values show proper normalization
   - No console errors
  </verify>
  <done>
Browser test page verifies PyodideWorker handles RemoteGame operations correctly: initEnv with on_game_step_code, reset with obs normalization, step with full result normalization. Non-blocking initialization proven by ping continuity.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Code verification:**
   - `pyodide_remote_game.js` imports and uses PyodideWorker
   - `pyodide_worker.js` handles on_game_step_code (extracts from globals, stores in Worker variable, injects in step)
   - `pyodide_worker.js` normalizes obs/rewards/terminateds/truncateds to dicts
   - No direct Pyodide calls remain in RemoteGame

2. **Functional verification:**
   - Browser test page shows PyodideWorker handles RemoteGame operations
   - on_game_step_code is stored during initEnv and injected during step
   - All results normalized to dicts with "human" key
   - Pings not blocked during initialization

3. **Backward compatibility:**
   - Existing single-player demos should work unchanged
   - No API surface changes to RemoteGame
   - index.js instantiation unchanged
</verification>

<success_criteria>
Phase 68 is complete when:
1. RemoteGame.initialize() uses PyodideWorker.init() and installPackages()
2. RemoteGame.step() uses PyodideWorker.step() (postMessage round-trip)
3. RemoteGame.reset() uses PyodideWorker.reset() (postMessage round-trip)
4. Worker extracts on_game_step_code from globals during initEnv and stores it
5. Worker injects on_game_step_code into Python execution during step
6. Worker normalizes obs/rewards/terminateds/truncateds to dicts
7. render_state arrives on main thread (Phaser receives it via addStateToBuffer)
8. Browser test demonstrates non-blocking initialization and proper normalization
9. Single-player games work identically to before (backward compatible)
</success_criteria>

<output>
After completion, create `.planning/phases/68-remotegame-integration/68-01-SUMMARY.md`
</output>
