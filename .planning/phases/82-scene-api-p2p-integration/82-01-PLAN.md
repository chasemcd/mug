---
phase: 82-scene-api-p2p-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/unit/test_latency_fifo_integration.py
  - interactive_gym/examples/cogrid/scenes/scenes.py
  - interactive_gym/examples/cogrid/overcooked_human_human_multiplayer.py
autonomous: true

must_haves:
  truths:
    - "scene.matchmaking(matchmaker=LatencyFIFOMatchmaker(max_server_rtt_ms=200, max_p2p_rtt_ms=150)) stores the matchmaker and it is retrievable via scene.matchmaker"
    - "GameManager needs_probe evaluates True when LatencyFIFOMatchmaker has max_p2p_rtt_ms set and probe_coordinator exists"
    - "GameManager needs_probe evaluates False when LatencyFIFOMatchmaker has max_p2p_rtt_ms=None"
    - "should_reject_for_rtt correctly rejects/accepts based on LatencyFIFOMatchmaker's max_p2p_rtt_ms"
    - "Full flow: find_match -> probe accepted -> game created"
    - "Full flow: find_match -> probe rejected -> candidates stay in waitroom"
    - "Example config demonstrates LatencyFIFOMatchmaker usage for researchers"
  artifacts:
    - path: "tests/unit/test_latency_fifo_integration.py"
      provides: "Integration tests for LatencyFIFOMatchmaker scene API and P2P probe wiring"
      min_lines: 100
    - path: "interactive_gym/examples/cogrid/scenes/scenes.py"
      provides: "Updated cramped_room_human_human scene with LatencyFIFOMatchmaker"
      contains: "LatencyFIFOMatchmaker"
    - path: "interactive_gym/examples/cogrid/overcooked_human_human_multiplayer.py"
      provides: "Import comment or config showing LatencyFIFOMatchmaker usage"
  key_links:
    - from: "tests/unit/test_latency_fifo_integration.py"
      to: "interactive_gym/scenes/gym_scene.py"
      via: "GymScene.matchmaking(matchmaker=LatencyFIFOMatchmaker(...))"
      pattern: "matchmaking.*LatencyFIFOMatchmaker"
    - from: "tests/unit/test_latency_fifo_integration.py"
      to: "interactive_gym/server/game_manager.py"
      via: "needs_probe condition verification with mock probe_coordinator"
      pattern: "needs_probe"
---

<objective>
Verify that LatencyFIFOMatchmaker integrates correctly with the scene.matchmaking() API and the P2P probe coordination flow, then update the example experiment to demonstrate the new matchmaker.

Purpose: Complete MATCH-03 (P2P probe integration) and MATCH-05 (scene API configuration) — the final requirements for v1.21 Latency-Aware Matchmaking. Research confirmed all code paths exist; this plan proves they work together via integration tests and provides researcher-facing documentation via the example config.

Output: Integration test suite proving end-to-end wiring + updated example config showing LatencyFIFOMatchmaker usage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/82-scene-api-p2p-integration/82-RESEARCH.md
@.planning/phases/81-latency-fifo-matchmaker-core/81-01-SUMMARY.md

Key source files to reference during implementation:
@interactive_gym/server/matchmaker.py — LatencyFIFOMatchmaker, Matchmaker base, MatchCandidate
@interactive_gym/scenes/gym_scene.py — GymScene.matchmaking() method (lines 540-593)
@interactive_gym/server/game_manager.py — _add_to_fifo_queue() needs_probe check (lines 527-537), _probe_and_create_game(), _on_probe_complete()
@interactive_gym/examples/cogrid/scenes/scenes.py — cramped_room_human_human scene definition (line 426-482)
@tests/unit/test_latency_fifo_matchmaker.py — Existing Phase 81 unit tests (pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integration tests for scene API and P2P probe wiring</name>
  <files>tests/unit/test_latency_fifo_integration.py</files>
  <action>
Create `tests/unit/test_latency_fifo_integration.py` with a `TestLatencyFIFOIntegration` class covering these test cases:

**Scene API tests (MATCH-05):**

1. `test_scene_stores_latency_fifo_matchmaker` — Create a GymScene, call `.matchmaking(matchmaker=LatencyFIFOMatchmaker(max_server_rtt_ms=200, max_p2p_rtt_ms=150))`, assert `scene.matchmaker` returns the LatencyFIFOMatchmaker instance with correct `max_server_rtt_ms=200` and `max_p2p_rtt_ms=150`.

2. `test_scene_stores_latency_fifo_without_p2p` — Same as above but with `LatencyFIFOMatchmaker(max_server_rtt_ms=200)` (no max_p2p_rtt_ms). Assert `scene.matchmaker.max_p2p_rtt_ms is None`.

3. `test_scene_matchmaker_type_validation` — Verify `scene.matchmaking(matchmaker="not_a_matchmaker")` raises `TypeError`.

**P2P probe decision tests (MATCH-03):**

4. `test_needs_probe_true_when_p2p_set` — Create a LatencyFIFOMatchmaker with `max_p2p_rtt_ms=150`. Create a `MagicMock()` for probe_coordinator. Evaluate the `needs_probe` expression: `(probe_coordinator is not None and matchmaker.max_p2p_rtt_ms is not None)`. Assert it is True.

5. `test_needs_probe_false_when_p2p_not_set` — Same but with `max_p2p_rtt_ms=None`. Assert `needs_probe` is False.

6. `test_needs_probe_false_when_no_probe_coordinator` — `max_p2p_rtt_ms=150` but `probe_coordinator=None`. Assert `needs_probe` is False.

**Rejection/acceptance tests (MATCH-03):**

7. `test_should_reject_accepts_under_threshold` — `LatencyFIFOMatchmaker(max_server_rtt_ms=200, max_p2p_rtt_ms=150)`, `should_reject_for_rtt(100.0)` returns False.

8. `test_should_reject_accepts_at_boundary` — Same matchmaker, `should_reject_for_rtt(150.0)` returns False (boundary inclusive).

9. `test_should_reject_rejects_over_threshold` — Same matchmaker, `should_reject_for_rtt(151.0)` returns True.

10. `test_should_reject_rejects_none_measurement` — Same matchmaker, `should_reject_for_rtt(None)` returns True (failed measurement).

11. `test_should_reject_accepts_all_when_no_p2p_threshold` — `LatencyFIFOMatchmaker(max_server_rtt_ms=200)` (no max_p2p_rtt_ms), `should_reject_for_rtt(9999.0)` returns False (no threshold means accept all).

**Full flow integration tests (MATCH-03 end-to-end):**

12. `test_full_flow_probe_accepted_game_created` — This tests the complete logical flow:
    - Create `LatencyFIFOMatchmaker(max_server_rtt_ms=200, max_p2p_rtt_ms=150)`
    - Create two MatchCandidates with rtt_ms=50 and rtt_ms=60
    - Call `find_match()` — assert match is returned (50+60=110 <= 200)
    - Evaluate needs_probe with a mock probe_coordinator — assert True
    - Call `should_reject_for_rtt(80.0)` (simulating probe result of 80ms) — assert False (accepted)
    - Document: game would be created at this point

13. `test_full_flow_probe_rejected_candidates_stay` — Same setup but:
    - Call `find_match()` — assert match returned
    - Call `should_reject_for_rtt(200.0)` (simulating probe result of 200ms) — assert True (rejected)
    - Document: candidates would remain in waitroom at this point

14. `test_full_flow_no_probe_game_created_immediately` — LatencyFIFOMatchmaker without max_p2p_rtt_ms:
    - Call `find_match()` — assert match returned
    - Evaluate needs_probe with probe_coordinator=mock — assert False (no p2p threshold)
    - Document: game would be created immediately, no probe needed

Follow the existing test style from `test_latency_fifo_matchmaker.py` — class-based, descriptive docstrings, direct assertions.

Import from: `interactive_gym.server.matchmaker` (LatencyFIFOMatchmaker, MatchCandidate), `interactive_gym.scenes.gym_scene` (GymScene), `unittest.mock` (MagicMock).
  </action>
  <verify>
Run `python -m pytest tests/unit/test_latency_fifo_integration.py -v` — all 14 tests pass.
Run `python -m pytest tests/unit/ -v` — all tests (Phase 81 + Phase 82) pass together with no failures.
  </verify>
  <done>14 integration tests pass covering scene API storage (MATCH-05), needs_probe decision logic (MATCH-03), rejection/acceptance (MATCH-03), and full logical flow (MATCH-03).</done>
</task>

<task type="auto">
  <name>Task 2: Update example config to demonstrate LatencyFIFOMatchmaker</name>
  <files>interactive_gym/examples/cogrid/scenes/scenes.py, interactive_gym/examples/cogrid/overcooked_human_human_multiplayer.py</files>
  <action>
**In `interactive_gym/examples/cogrid/scenes/scenes.py`:**

Update the `cramped_room_human_human` scene definition (around line 470) to replace the existing `.matchmaking(hide_lobby_count=True, max_rtt=100)` call with one that demonstrates LatencyFIFOMatchmaker:

```python
.matchmaking(
    matchmaker=LatencyFIFOMatchmaker(
        max_server_rtt_ms=200,   # Stage 1: skip if sum of server RTTs > 200ms
        max_p2p_rtt_ms=150,      # Stage 2: reject if actual P2P RTT > 150ms
    ),
    hide_lobby_count=True,
)
```

Add the necessary import near the top of the file (after the existing imports):
```python
from interactive_gym.server.matchmaker import LatencyFIFOMatchmaker
```

Remove the old `max_rtt=100` parameter — it is superseded by the matchmaker's two-stage filtering. The `max_rtt` parameter measured RTT *difference* between players which is a different (and less useful) metric than the sum-of-RTTs heuristic.

**Important:** Only update `cramped_room_human_human`. The deepcopy-based variants (counter_circuit_human_human, forced_coordination_human_human, etc.) will inherit this change automatically since they are `copy.deepcopy(cramped_room_human_human)`.

**In `interactive_gym/examples/cogrid/overcooked_human_human_multiplayer.py`:**

Add a comment near the top of the file (after the docstring, before imports) explaining the latency-aware matchmaking option:

```python
# Latency-aware matchmaking: The cramped_room_human_human scene in scenes.py
# uses LatencyFIFOMatchmaker for two-stage latency filtering:
#   Stage 1 (pre-filter): Skips candidates where sum of server RTTs > max_server_rtt_ms
#   Stage 2 (post-filter): Rejects matches where actual P2P RTT > max_p2p_rtt_ms
# To disable latency filtering, use the default FIFOMatchmaker (no matchmaker= argument).
```

This provides researchers with context when they look at the example.
  </action>
  <verify>
Run `python -c "from interactive_gym.examples.cogrid.scenes.scenes import cramped_room_human_human; m = cramped_room_human_human.matchmaker; print(type(m).__name__, m.max_server_rtt_ms, m.max_p2p_rtt_ms)"` — prints `LatencyFIFOMatchmaker 200 150`.

Run `python -c "from interactive_gym.examples.cogrid.scenes.scenes import counter_circuit_human_human; m = counter_circuit_human_human.matchmaker; print(type(m).__name__, m.max_server_rtt_ms, m.max_p2p_rtt_ms)"` — prints `LatencyFIFOMatchmaker 200 150` (inherited via deepcopy).

Run `python -m pytest tests/unit/ -v` — all tests still pass (no regressions from import change).
  </verify>
  <done>Example experiment config uses LatencyFIFOMatchmaker with both thresholds. All deepcopy variants inherit the config. Researchers can see the recommended usage pattern in the example code.</done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/unit/ -v` — all unit + integration tests pass (Phase 81 + Phase 82)
2. `python -c "from interactive_gym.server.matchmaker import LatencyFIFOMatchmaker; m = LatencyFIFOMatchmaker(max_server_rtt_ms=200, max_p2p_rtt_ms=150); print(m.max_server_rtt_ms, m.max_p2p_rtt_ms)"` — prints `200 150`
3. `python -c "from interactive_gym.examples.cogrid.scenes.scenes import cramped_room_human_human; print(type(cramped_room_human_human.matchmaker).__name__)"` — prints `LatencyFIFOMatchmaker`
4. MATCH-03 covered: Integration tests verify needs_probe, should_reject_for_rtt, and full flow (probe accepted/rejected)
5. MATCH-05 covered: Integration tests verify scene.matchmaking() stores and returns LatencyFIFOMatchmaker
</verification>

<success_criteria>
- 14 integration tests pass in tests/unit/test_latency_fifo_integration.py
- All 13 existing Phase 81 unit tests continue to pass (no regression)
- Example config (cramped_room_human_human) uses LatencyFIFOMatchmaker with max_server_rtt_ms=200 and max_p2p_rtt_ms=150
- All deepcopy variants inherit the LatencyFIFOMatchmaker config
- MATCH-03 (P2P probe integration) is verified by tests
- MATCH-05 (scene API configuration) is verified by tests
</success_criteria>

<output>
After completion, create `.planning/phases/82-scene-api-p2p-integration/82-01-SUMMARY.md`
</output>
