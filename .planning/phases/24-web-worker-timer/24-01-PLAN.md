---
phase: 24-web-worker-timer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/static/js/pyodide_multiplayer_game.js
  - interactive_gym/server/static/js/phaser_gym_graphics.js
autonomous: true

must_haves:
  truths:
    - "Game timing runs in Web Worker, not main thread setInterval"
    - "When tab is backgrounded, Worker timer continues at target interval"
    - "Main thread receives tick messages via postMessage"
    - "Game logic advances on Worker ticks, not Phaser RAF"
    - "Rendering still uses Phaser RAF (separate from game logic timing)"
  artifacts:
    - path: "interactive_gym/server/static/js/pyodide_multiplayer_game.js"
      provides: "GameTimerWorker class, Worker integration"
      contains: "class GameTimerWorker"
    - path: "interactive_gym/server/static/js/phaser_gym_graphics.js"
      provides: "Decoupled rendering loop"
      contains: "processPyodideGame"
  key_links:
    - from: "GameTimerWorker"
      to: "MultiplayerPyodideGame"
      via: "onTick callback"
      pattern: "timerWorker\\.onTick"
    - from: "Worker setInterval"
      to: "postMessage"
      via: "self.postMessage in Worker code"
      pattern: "self\\.postMessage.*tick"
---

<objective>
Implement Web Worker-based game timing to prevent browser throttling when tabs are backgrounded.

Purpose: Browsers throttle main-thread timers (setInterval, requestAnimationFrame) when tabs are backgrounded - reducing to 1/second or 1/minute. This causes desync in multiplayer games. Web Workers are exempt from this throttling, providing reliable timing regardless of tab visibility.

Output: GameTimerWorker class that runs timing in a dedicated Worker, with integration into the multiplayer game loop so game logic advances on Worker ticks rather than Phaser's throttle-prone RAF loop.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-web-worker-timer/24-RESEARCH.md

Key existing code:
- `phaser_gym_graphics.js`: Phaser scene with `update()` method that calls `processPyodideGame()`
- `pyodide_multiplayer_game.js`: MultiplayerPyodideGame class with `step()` method
- Game FPS configured via `this.config.fps` (default 10fps = 100ms intervals)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GameTimerWorker class with inline Blob Worker</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Add a new `GameTimerWorker` class at the top of the file (after imports, before other classes) that:

1. Creates an inline Web Worker via Blob URL (no separate file needed):
   - Worker code as a string containing setInterval logic
   - Worker posts `{ type: 'tick', timestamp: performance.now() }` messages at target interval
   - Worker responds to 'start', 'stop', 'setInterval' commands

2. Class structure:
   ```javascript
   class GameTimerWorker {
     constructor(targetFps = 10)  // 10fps = 100ms interval by default
     _createWorker()              // Create Blob URL and Worker instance
     start()                      // Send 'start' command to Worker
     stop()                       // Send 'stop' command to Worker
     setFps(fps)                  // Update tick interval
     destroy()                    // Terminate Worker, revoke Blob URL (memory cleanup)
   }
   ```

3. Expose `onTick` callback property for external code to receive ticks

4. Include error handling in Worker's onerror

5. Use performance.now() for high-precision timestamps

Reference research pattern from `24-RESEARCH.md` - the "Complete GameTimerWorker Implementation" section provides verified code.

Do NOT add any `isProcessingTick` guard yet - that belongs in the integration (Task 2). This task creates a standalone, reusable timer class.
  </action>
  <verify>
Manual code review:
- GameTimerWorker class exists with constructor, start(), stop(), setFps(), destroy() methods
- Worker code string contains setInterval and self.postMessage
- Blob URL created via URL.createObjectURL
- URL.revokeObjectURL called in destroy() method
  </verify>
  <done>
GameTimerWorker class added to pyodide_multiplayer_game.js, ready for integration with game loop.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate Worker timing with multiplayer game loop</name>
  <files>
    interactive_gym/server/static/js/pyodide_multiplayer_game.js
    interactive_gym/server/static/js/phaser_gym_graphics.js
  </files>
  <action>
Modify the game loop to use Worker ticks for game logic while keeping Phaser RAF for rendering.

**In `pyodide_multiplayer_game.js` - MultiplayerPyodideGame class:**

1. Add instance properties in constructor:
   - `this.timerWorker = null` - GameTimerWorker instance
   - `this.isProcessingTick = false` - Guard against overlapping ticks
   - `this.tickCallback = null` - Callback to trigger game step from external code

2. Add initialization method `_initTimerWorker()` called after P2P setup completes:
   - Create GameTimerWorker with `this.config.fps || 10`
   - Set `timerWorker.onTick = (timestamp) => this._handleWorkerTick(timestamp)`
   - Call `timerWorker.start()`

3. Add `_handleWorkerTick(timestamp)` method:
   - Skip if `this.state === 'done'` or `this.reconnectionState.isPaused`
   - Skip if `this.isProcessingTick` (prevents overlapping async operations)
   - Set `this.isProcessingTick = true`
   - Call `this.tickCallback?.()` if set (to trigger Phaser's processPyodideGame)
   - Note: isProcessingTick is cleared by the callback when complete

4. Add `registerTickCallback(callback)` method:
   - Store callback for external code to receive tick notifications
   - This allows Phaser to still orchestrate the game step, just triggered by Worker

5. Modify cleanup (`_cleanup` or wherever game end is handled):
   - Call `this.timerWorker?.destroy()` to clean up Worker

6. Call `_initTimerWorker()` at end of `_handleMatchStart()` after P2P ready gate passes

**In `phaser_gym_graphics.js` - GymScene class:**

1. In `create()` method, after setting `this.pyodide_remote_game`:
   - If `this.pyodide_remote_game.registerTickCallback` exists (multiplayer mode):
     - Register callback: `this.pyodide_remote_game.registerTickCallback(() => this.onWorkerTick())`

2. Add `onWorkerTick()` method:
   - Call `this.processPyodideGame()` (existing method)
   - Clear `this.pyodide_remote_game.isProcessingTick` after completion

3. Modify `update()` method:
   - Keep existing rendering via `this.processRendering()`
   - For multiplayer games WITH Worker timing: Do NOT call processPyodideGame (Worker handles it)
   - For single-player games or games without Worker: Keep existing processPyodideGame call
   - Detection: Check `this.pyodide_remote_game?.timerWorker` to know if Worker is active

The result: Phaser's `update()` still runs (at whatever rate browser allows), but only renders. Game logic (`processPyodideGame` -> `step()`) is triggered by Worker ticks, which continue at full speed even when backgrounded.
  </action>
  <verify>
Test by:
1. Run multiplayer game in browser
2. Open browser console, check for no errors
3. Verify game runs at expected FPS
4. Background the tab for 10+ seconds
5. Foreground the tab
6. Check console logs: game should have continued advancing frames while backgrounded (no gap)

Code verification:
- `_initTimerWorker()` creates and starts GameTimerWorker
- `_handleWorkerTick()` has guards for done/paused/processing states
- `update()` in Phaser checks `timerWorker` before calling processPyodideGame
- Worker destroyed on game end
  </verify>
  <done>
Worker timing integrated with game loop. Game logic advances on Worker ticks (unthrottled). Rendering still uses Phaser RAF.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Worker exists and runs:**
   - GameTimerWorker class defined in pyodide_multiplayer_game.js
   - Worker created via Blob URL (no separate .js file)
   - Worker sends tick messages at configured FPS

2. **Integration works:**
   - Multiplayer game initializes Worker after P2P ready
   - Worker ticks trigger processPyodideGame
   - Phaser update() only renders (does not redundantly step game logic)

3. **Background tab behavior:**
   - Background tab for 10+ seconds
   - Frame counter should continue advancing (not frozen)
   - On foreground, no large frame gap visible

4. **Memory cleanup:**
   - Worker terminated on game end
   - Blob URL revoked (no memory leak)
</verification>

<success_criteria>
- [x] WORK-01: Game timing logic runs in Web Worker (unthrottled when backgrounded)
  - GameTimerWorker runs setInterval in dedicated Worker thread
  - processPyodideGame triggered by Worker ticks, not RAF

- [x] WORK-02: Worker maintains accurate game clock even when main thread is throttled
  - Worker exempt from browser throttling
  - Timestamps from performance.now() maintain accuracy
  - No frame gaps when tab backgrounded then foregrounded
</success_criteria>

<output>
After completion, create `.planning/phases/24-web-worker-timer/24-01-SUMMARY.md` following template at @~/.claude/get-shit-done/templates/summary.md
</output>
