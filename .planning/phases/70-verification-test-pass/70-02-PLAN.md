---
phase: 70-verification-test-pass
plan: 02
type: execute
wave: 2
depends_on: ["70-01"]
files_modified: []
autonomous: true

must_haves:
  truths:
    - "Full unit test suite passes with zero failures"
    - "Every parameter from old API is settable through new API methods"
    - "All 10 builder methods return self for method chaining"
    - "No references to removed method names exist in any Python file under interactive_gym/"
  artifacts: []
  key_links:
    - from: "interactive_gym/scenes/gym_scene.py"
      to: "interactive_gym/scenes/gym_scene.py"
      via: "return self in every builder method"
      pattern: "return self"
---

<objective>
Verify zero functionality change across the entire codebase: run full test suite, audit parameter coverage, and confirm method chaining.

Purpose: This plan addresses all three Phase 70 requirements (VERF-01, VERF-02, VERF-03) through verification-only tasks. No code changes expected -- if tests fail or gaps are found, the plan will document them for gap closure.

Output: Verification results confirming all requirements met, or a clear list of gaps to address.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/70-verification-test-pass/70-01-SUMMARY.md
@interactive_gym/scenes/gym_scene.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Run full test suite and verify zero regressions (VERF-01)</name>
  <files></files>
  <action>
Run the full unit test suite:

```bash
python -m pytest tests/unit/ -v
```

Expected: All 27 tests pass.

Then verify all example files can be imported without errors. Run each import individually:

```python
# Test that all example files import cleanly
python -c "from interactive_gym.examples.cogrid.scenes import scenes; print('scenes OK')"
python -c "from interactive_gym.examples.cogrid.scenes import controllable_scenes; print('controllable_scenes OK')"
python -c "from interactive_gym.examples.slime_volleyball import slimevb_human_human; print('slime_vb_hh OK')"
python -c "from interactive_gym.examples.slime_volleyball import human_ai_pyodide_boost; print('slime_vb_ai OK')"
python -c "from interactive_gym.examples.mountain_car import mountain_car_experiment; print('mountain_car OK')"
```

Then verify zero references to any removed method name in Python files under interactive_gym/:

```bash
grep -rn '\.pyodide\(\|\.user_experience\(\|\.focus_loss_config\(\|\.player_grouping\(\|\.continuous_monitoring\(\|\.exclusion_callbacks\(\|\.reconnection_config\(\|\.partner_disconnect_message_config\(\|\.player_pairing\(' interactive_gym/ --include='*.py'
```

Expected: Zero matches.

Do NOT run e2e tests (they require headed browser mode and a running server). The unit tests + import verification are the correctness gate.
  </action>
  <verify>All 27 unit tests pass. All example imports succeed. Zero removed method references in interactive_gym/**/*.py.</verify>
  <done>VERF-01 satisfied: full test suite passes with zero failures, all example files import cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Audit parameter coverage and method chaining (VERF-02, VERF-03)</name>
  <files></files>
  <action>
**VERF-02: Parameter coverage audit.**

Verify that every attribute initialized in GymScene.__init__ is settable through at least one new API builder method. The complete mapping is:

OLD METHOD -> NEW METHOD (param name mapping):

**pyodide() -> runtime()** (6 params, direct rename):
- run_through_pyodide -> run_through_pyodide
- environment_initialization_code -> environment_initialization_code
- environment_initialization_code_filepath -> environment_initialization_code_filepath (added in runtime)
- on_game_step_code -> on_game_step_code
- packages_to_install -> packages_to_install
- restart_pyodide -> restart_pyodide

**pyodide() sync params -> multiplayer()** (7 params):
- pyodide_multiplayer -> multiplayer (renamed param)
- server_authoritative -> server_authoritative
- state_broadcast_interval -> state_broadcast_interval
- realtime_mode -> realtime_mode
- input_buffer_size -> input_buffer_size
- input_delay -> input_delay
- input_confirmation_timeout_ms -> input_confirmation_timeout_ms

**matchmaking() -> matchmaking() AND multiplayer()** (3 params, both methods work):
- hide_lobby_count -> hide_lobby_count
- max_rtt -> max_rtt (maps to self.matchmaking_max_rtt)
- matchmaker -> matchmaker (maps to self._matchmaker)

**player_grouping() -> multiplayer()** (2 params):
- wait_for_known_group -> wait_for_known_group
- group_wait_timeout -> group_wait_timeout

**continuous_monitoring() -> multiplayer()** (7 params):
- continuous_monitoring_enabled -> continuous_monitoring_enabled
- continuous_max_ping -> continuous_max_ping
- continuous_ping_violation_window -> continuous_ping_violation_window
- continuous_ping_required_violations -> continuous_ping_required_violations
- continuous_tab_warning_ms -> continuous_tab_warning_ms
- continuous_tab_exclude_ms -> continuous_tab_exclude_ms
- continuous_exclusion_messages -> continuous_exclusion_messages

**exclusion_callbacks() -> multiplayer()** (2 params, one renamed):
- continuous_callback -> continuous_callback (maps to self.continuous_exclusion_callback)
- continuous_callback_interval_frames -> continuous_callback_interval_frames

**reconnection_config() -> multiplayer()** (1 param):
- reconnection_timeout_ms -> reconnection_timeout_ms

**partner_disconnect_message_config() -> multiplayer()** (2 params):
- partner_disconnect_message -> partner_disconnect_message
- partner_disconnect_show_completion_code -> partner_disconnect_show_completion_code

**focus_loss_config() -> multiplayer()** (3 params, one renamed):
- timeout_ms -> focus_loss_timeout_ms (renamed)
- focus_loss_message -> focus_loss_message
- pause_on_partner_background -> pause_on_partner_background

**user_experience() -> content() + waitroom()** (split):
content() gets: scene_header, scene_body, scene_body_filepath, in_game_scene_body, in_game_scene_body_filepath, game_page_html_fn
waitroom() gets: timeout (was waitroom_timeout), timeout_redirect_url (was waitroom_timeout_redirect_url), timeout_scene_id (was waitroom_timeout_scene_id), timeout_message (was waitroom_timeout_message)

**rendering() asset params -> assets()** (5 params moved):
assets() gets: preload_specs, assets_dir, assets_to_preload, animation_configs, state_init
rendering() retains: fps, env_to_state_fn, hud_text_fn, hud_score_carry_over, location_representation, game_width, game_height, background, rollback_smoothing_duration

Verify this by writing and running a Python script that:
1. Creates a GymScene instance
2. For each attribute in __init__, calls the appropriate new method to set it
3. Asserts the attribute was correctly set
4. Reports any attributes that cannot be set through any new method

```python
from interactive_gym.scenes.gym_scene import GymScene

scene = GymScene()

# Test runtime() params
scene.runtime(run_through_pyodide=True)
assert scene.run_through_pyodide == True

scene.runtime(packages_to_install=["numpy"])
assert "numpy" in scene.packages_to_install

scene.runtime(restart_pyodide=True)
assert scene.restart_pyodide == True

scene.runtime(environment_initialization_code="print('hi')")
assert scene.environment_initialization_code == "print('hi')"

scene.runtime(on_game_step_code="pass")
assert scene.on_game_step_code == "pass"

# Test multiplayer() params - sync
scene.multiplayer(multiplayer=True)
assert scene.pyodide_multiplayer == True

scene.multiplayer(server_authoritative=True)
assert scene.server_authoritative == True

scene.multiplayer(state_broadcast_interval=60)
assert scene.state_broadcast_interval == 60

scene.multiplayer(realtime_mode=False)
assert scene.realtime_mode == False

scene.multiplayer(input_buffer_size=500)
assert scene.input_buffer_size == 500

scene.multiplayer(input_delay=3)
assert scene.input_delay == 3

scene.multiplayer(input_confirmation_timeout_ms=1000)
assert scene.input_confirmation_timeout_ms == 1000

# Test multiplayer() params - player grouping
scene.multiplayer(wait_for_known_group=True)
assert scene.wait_for_known_group == True

scene.multiplayer(group_wait_timeout=30000)
assert scene.group_wait_timeout == 30000

# Test multiplayer() params - continuous monitoring
scene.multiplayer(continuous_max_ping=200)
assert scene.continuous_max_ping == 200
assert scene.continuous_monitoring_enabled == True

scene.multiplayer(continuous_ping_violation_window=10, continuous_ping_required_violations=5)
assert scene.continuous_ping_violation_window == 10
assert scene.continuous_ping_required_violations == 5

scene.multiplayer(continuous_tab_warning_ms=5000)
assert scene.continuous_tab_warning_ms == 5000

scene.multiplayer(continuous_tab_exclude_ms=15000)
assert scene.continuous_tab_exclude_ms == 15000

# Test multiplayer() params - exclusion callbacks
def my_callback(): pass
scene.multiplayer(continuous_callback=my_callback)
assert scene.continuous_exclusion_callback == my_callback

scene.multiplayer(continuous_callback_interval_frames=60)
assert scene.continuous_callback_interval_frames == 60

# Test multiplayer() params - reconnection
scene.multiplayer(reconnection_timeout_ms=10000)
assert scene.reconnection_timeout_ms == 10000

# Test multiplayer() params - partner disconnect
scene.multiplayer(partner_disconnect_message="Partner left")
assert scene.partner_disconnect_message == "Partner left"

scene.multiplayer(partner_disconnect_show_completion_code=False)
assert scene.partner_disconnect_show_completion_code == False

# Test multiplayer() params - focus loss
scene.multiplayer(focus_loss_timeout_ms=20000)
assert scene.focus_loss_timeout_ms == 20000

scene.multiplayer(focus_loss_message="Focus lost")
assert scene.focus_loss_message == "Focus lost"

scene.multiplayer(pause_on_partner_background=True)
assert scene.pause_on_partner_background == True

# Test multiplayer() params - matchmaking (also via matchmaking())
scene.multiplayer(hide_lobby_count=True)
assert scene.hide_lobby_count == True

scene.multiplayer(max_rtt=100)
assert scene.matchmaking_max_rtt == 100

# Test content() params
scene.content(scene_header="Test Header")
assert scene.scene_header == "Test Header"

scene.content(scene_body="<p>body</p>")
assert scene.scene_body == "<p>body</p>"

scene.content(in_game_scene_body="<p>in game</p>")
assert scene.in_game_scene_body == "<p>in game</p>"

# Test waitroom() params
scene.waitroom(timeout=60000)
assert scene.waitroom_timeout == 60000

scene.waitroom(timeout_redirect_url="http://example.com")
assert scene.waitroom_timeout_redirect_url == "http://example.com"

scene.waitroom(timeout_scene_id="fallback_scene")
assert scene.waitroom_timeout_scene_id == "fallback_scene"

scene.waitroom(timeout_message="Please wait")
assert scene.waitroom_timeout_message == "Please wait"

# Test assets() params
scene.assets(assets_dir="/assets/")
assert scene.assets_dir == "/assets/"

scene.assets(assets_to_preload=["sprite.png"])
assert scene.assets_to_preload == ["sprite.png"]

scene.assets(animation_configs=[{"name": "walk"}])
assert scene.animation_configs == [{"name": "walk"}]

scene.assets(state_init=[{"x": 0}])
assert scene.state_init == [{"x": 0}]

# Test rendering() remaining params
scene.rendering(fps=30)
assert scene.fps == 30

scene.rendering(game_width=800, game_height=600)
assert scene.game_width == 800
assert scene.game_height == 600

scene.rendering(background="#000000")
assert scene.background == "#000000"

scene.rendering(rollback_smoothing_duration=200)
assert scene.rollback_smoothing_duration == 200

print("VERF-02 PASSED: All parameters accessible through new API")
```

**VERF-03: Method chaining verification.**

Verify all 10 builder methods return self by chaining them:

```python
from interactive_gym.scenes.gym_scene import GymScene

# Chain all 10 methods in a single expression
result = (
    GymScene()
    .environment(seed=42)
    .rendering(fps=30, game_width=600, game_height=400)
    .assets(assets_dir="./assets/")
    .policies(frame_skip=4)
    .gameplay(num_episodes=1, max_steps=100)
    .content(scene_header="Test")
    .waitroom(timeout=60000)
    .matchmaking(hide_lobby_count=False)
    .runtime(run_through_pyodide=True)
    .multiplayer(multiplayer=True, input_delay=2)
)

assert isinstance(result, GymScene), "Chaining should return GymScene instance"
assert result.env_seed == 42 or result.seed == 42  # environment sets seed
assert result.fps == 30
assert result.assets_dir == "./assets/"
assert result.frame_skip == 4
assert result.num_episodes == 1
assert result.scene_header == "Test"
assert result.waitroom_timeout == 60000
assert result.run_through_pyodide == True
assert result.pyodide_multiplayer == True
assert result.input_delay == 2

print("VERF-03 PASSED: All builder methods return self, full chaining works")
```

Run both scripts. If any assertion fails, document the exact failure for gap closure.
  </action>
  <verify>Both verification scripts run to completion printing PASSED messages. No assertion failures.</verify>
  <done>VERF-02 satisfied: every old API parameter is accessible through new API. VERF-03 satisfied: all 10 builder methods return self, full chaining works.</done>
</task>

</tasks>

<verification>
All three VERF requirements verified:
1. VERF-01: `python -m pytest tests/unit/ -v` passes 27/27
2. VERF-02: Parameter coverage script confirms all old params accessible
3. VERF-03: Method chaining script confirms all 10 methods return self
</verification>

<success_criteria>
- 27/27 unit tests pass
- All example files import without errors
- Zero removed method references in interactive_gym/**/*.py
- Parameter coverage script passes all assertions
- Method chaining script passes all assertions
</success_criteria>

<output>
After completion, create `.planning/phases/70-verification-test-pass/70-02-SUMMARY.md`
</output>
