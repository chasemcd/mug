---
phase: 67-pyodide-preload-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/configurations/experiment_config.py
  - interactive_gym/configurations/remote_config.py
  - interactive_gym/server/app.py
  - interactive_gym/server/static/templates/index.html
  - interactive_gym/server/static/js/index.js
autonomous: true

must_haves:
  truths:
    - "Server detects Pyodide-requiring scenes from experiment config and sends pyodide_config to client"
    - "Client starts loadPyodide() during compatibility check screen when pyodide_config.needs_pyodide is true"
    - "Participant sees progress indicator (spinner + status text) during Pyodide initialization"
    - "Participant cannot click Continue/advance until Pyodide is fully loaded (or fails gracefully)"
    - "If preload fails, participant can still advance (fallback to game-time loading)"
  artifacts:
    - path: "interactive_gym/configurations/experiment_config.py"
      provides: "get_pyodide_config() method on ExperimentConfig"
      contains: "def get_pyodide_config"
    - path: "interactive_gym/configurations/remote_config.py"
      provides: "get_pyodide_config() method on RemoteConfig"
      contains: "def get_pyodide_config"
    - path: "interactive_gym/server/app.py"
      provides: "pyodide_config included in experiment_config socket event"
      contains: "pyodide_config"
    - path: "interactive_gym/server/static/templates/index.html"
      provides: "Pyodide loading indicator element"
      contains: "pyodideLoader"
    - path: "interactive_gym/server/static/js/index.js"
      provides: "preloadPyodide function and advancement gating"
      contains: "preloadPyodide"
  key_links:
    - from: "interactive_gym/server/app.py"
      to: "experiment_config.get_pyodide_config()"
      via: "method call in register_subject handler"
      pattern: "get_pyodide_config"
    - from: "interactive_gym/server/static/js/index.js"
      to: "window.pyodidePreloadStatus"
      via: "preloadPyodide sets status, advanceButton handler checks it"
      pattern: "pyodidePreloadStatus"
    - from: "interactive_gym/server/static/js/index.js"
      to: "window.pyodideInstance"
      via: "preloadPyodide stores loaded instance for Phase 68 consumption"
      pattern: "window\\.pyodideInstance"
---

<objective>
Build the Pyodide pre-loading infrastructure: server detects Pyodide-requiring scenes and sends config to client, client starts loadPyodide() during the compatibility check screen with progress UI and advancement gating.

Purpose: Eliminate 5-15s main-thread blocking during game startup by moving loadPyodide() + package installation to the compat check screen, where blocking is harmless (no game running, no partner connection to maintain).

Output: Server sends pyodide_config in experiment_config event. Client preloads Pyodide and stores on window.pyodideInstance. Progress indicator shows during loading. Advance button is gated until ready.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/67-pyodide-preload-infrastructure/67-RESEARCH.md
@interactive_gym/configurations/experiment_config.py
@interactive_gym/configurations/remote_config.py
@interactive_gym/server/app.py
@interactive_gym/server/static/templates/index.html
@interactive_gym/server/static/js/index.js
@interactive_gym/scenes/stager.py
@interactive_gym/scenes/scene.py
@interactive_gym/scenes/gym_scene.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Server-side Pyodide config detection and emission</name>
  <files>
    interactive_gym/configurations/experiment_config.py
    interactive_gym/configurations/remote_config.py
    interactive_gym/server/app.py
  </files>
  <action>
    **ExperimentConfig (experiment_config.py):**
    Add a `get_pyodide_config()` method to the `ExperimentConfig` class. This method:
    1. Checks if `self.stager` is None -- if so, returns `{"needs_pyodide": False, "packages_to_install": []}`.
    2. Iterates through `self.stager.scenes` (the GENERIC_STAGER scenes, not per-participant copies).
    3. For each scene, calls `scene.unpack()` to recursively resolve SceneWrappers (RandomizeOrder, RepeatScene, etc.) into flat scene lists. The `unpack()` method exists on both `Scene` (returns `[self]`) and `SceneWrapper` (recursively unpacks children).
    4. For each unpacked scene, checks `hasattr(s, 'run_through_pyodide') and s.run_through_pyodide`.
    5. If true, sets `needs_pyodide = True` and collects `s.packages_to_install` into a set (union of all packages across all Pyodide scenes).
    6. Returns `{"needs_pyodide": needs_pyodide, "packages_to_install": list(all_packages)}`.

    Place this method after the existing `get_entry_screening_config()` method for consistent organization.

    **RemoteConfig (remote_config.py):**
    Add a `get_pyodide_config()` method to the `RemoteConfig` class. This is simpler since RemoteConfig has no stager:
    1. Returns `{"needs_pyodide": self.run_through_pyodide, "packages_to_install": self.packages_to_install}`.

    Also add a `get_entry_screening_config()` method to RemoteConfig that returns a dict with all screening values set to None/empty (no screening configured). This prevents the existing `CONFIG.get_entry_screening_config()` call in app.py from crashing when CONFIG is a RemoteConfig. Currently this would crash, but it's not hit in practice because RemoteConfig experiments don't seem to use the new Stager flow. Still, add it for safety:
    ```python
    def get_entry_screening_config(self) -> dict:
        return {
            "device_exclusion": None,
            "browser_requirements": None,
            "browser_blocklist": None,
            "max_ping": self.max_ping,
            "min_ping_measurements": self.min_ping_measurements,
            "exclusion_messages": {},
            "has_entry_callback": False,
        }
    ```

    **app.py:**
    Modify the `register_subject` handler (around line 352-357). Currently it sends:
    ```python
    flask_socketio.emit(
        "experiment_config",
        {"entry_screening": CONFIG.get_entry_screening_config()},
        room=sid,
    )
    ```

    Change to:
    ```python
    experiment_config_data = {
        "entry_screening": CONFIG.get_entry_screening_config(),
    }
    if hasattr(CONFIG, 'get_pyodide_config'):
        experiment_config_data["pyodide_config"] = CONFIG.get_pyodide_config()

    flask_socketio.emit("experiment_config", experiment_config_data, room=sid)
    ```

    Use `hasattr` check for safety so the code works even if CONFIG is an older config type.
  </action>
  <verify>
    1. `python -c "from interactive_gym.configurations.experiment_config import ExperimentConfig; c = ExperimentConfig(); print(c.get_pyodide_config())"` prints `{'needs_pyodide': False, 'packages_to_install': []}` (no stager = no pyodide).
    2. `python -c "from interactive_gym.configurations.remote_config import RemoteConfig; c = RemoteConfig(); print(c.get_pyodide_config())"` prints `{'needs_pyodide': False, 'packages_to_install': []}`.
    3. `python -c "from interactive_gym.configurations.remote_config import RemoteConfig; c = RemoteConfig(); c.run_through_pyodide = True; c.packages_to_install = ['numpy']; print(c.get_pyodide_config())"` prints `{'needs_pyodide': True, 'packages_to_install': ['numpy']}`.
    4. Grep for `pyodide_config` in app.py confirms it's included in the experiment_config emission.
  </verify>
  <done>
    - ExperimentConfig.get_pyodide_config() scans stager scenes and returns needs_pyodide + packages
    - RemoteConfig.get_pyodide_config() returns its own pyodide settings
    - RemoteConfig.get_entry_screening_config() returns safe defaults (no crash on older config path)
    - app.py register_subject includes pyodide_config in experiment_config event
  </done>
</task>

<task type="auto">
  <name>Task 2: Client-side Pyodide preload, progress UI, and advancement gating</name>
  <files>
    interactive_gym/server/static/templates/index.html
    interactive_gym/server/static/js/index.js
  </files>
  <action>
    **index.html:**
    Add a `#pyodideLoader` element after the existing `#screeningLoader` div (around line 291). Use the same styling pattern as `#screeningLoader`:
    ```html
    <!-- Pyodide preloading indicator (Phase 67) -->
    <div id="pyodideLoader" style="display: none;">
        <div class="screening-spinner"></div>
        <div id="pyodideStatus">Loading Python runtime...</div>
    </div>
    ```
    Place it right after the `#screeningLoader` closing div, before `#hudText`.

    **index.js:**

    **A. Add global state variables** near the top of the file (after the existing `var pyodideRemoteGame = null;` on line 201):
    ```javascript
    // Pyodide pre-loading state (Phase 67)
    window.pyodideInstance = null;
    window.pyodideMicropip = null;
    window.pyodideInstalledPackages = [];
    window.pyodidePreloadStatus = 'idle'; // 'idle' | 'loading' | 'ready' | 'error'
    ```

    **B. Add preloadPyodide() function** after the global state variables:
    ```javascript
    /**
     * Pre-load Pyodide during compatibility check screen (Phase 67).
     * Starts loadPyodide() + micropip.install() immediately when experiment_config
     * arrives, storing the result on window.pyodideInstance for Phase 68 to consume.
     *
     * @param {Object} pyodideConfig - {needs_pyodide: bool, packages_to_install: string[]}
     */
    async function preloadPyodide(pyodideConfig) {
        if (!pyodideConfig || !pyodideConfig.needs_pyodide) {
            window.pyodidePreloadStatus = 'ready';
            return;
        }

        console.log('[PyodidePreload] Starting preload...');
        window.pyodidePreloadStatus = 'loading';
        showPyodideProgress('Loading Python runtime...');

        try {
            const pyodide = await loadPyodide();
            console.log('[PyodidePreload] Core loaded, installing micropip...');
            showPyodideProgress('Installing packages...');

            await pyodide.loadPackage("micropip");
            const micropip = pyodide.pyimport("micropip");

            const packages = pyodideConfig.packages_to_install || [];
            if (packages.length > 0) {
                console.log('[PyodidePreload] Installing:', packages);
                await micropip.install(packages);
            }

            window.pyodideInstance = pyodide;
            window.pyodideMicropip = micropip;
            window.pyodideInstalledPackages = packages;
            window.pyodidePreloadStatus = 'ready';
            hidePyodideProgress();
            console.log('[PyodidePreload] Complete');

        } catch (error) {
            console.error('[PyodidePreload] Failed:', error);
            window.pyodidePreloadStatus = 'error';
            showPyodideProgress('Loading failed - will retry when game starts');
            // Don't block advancement -- fallback to game-time loading (Phase 68 handles this)
        }
    }

    function showPyodideProgress(message) {
        const loader = document.getElementById('pyodideLoader');
        const status = document.getElementById('pyodideStatus');
        if (loader) loader.style.display = 'flex';
        if (status) status.textContent = message;
    }

    function hidePyodideProgress() {
        const loader = document.getElementById('pyodideLoader');
        if (loader) loader.style.display = 'none';
    }
    ```

    **C. Modify the experiment_config handler** (around line 512). After the existing `socket.on('experiment_config', async function(data) {` handler, add the Pyodide preload call. Add it BEFORE the entry screening logic, so it runs concurrently:

    Right after `console.log("[ExperimentConfig] Received experiment configuration");` (line 513), add:
    ```javascript
    // Start Pyodide preload concurrently with entry screening (Phase 67)
    // Fire and forget -- don't await, let it run alongside screening
    if (data.pyodide_config) {
        preloadPyodide(data.pyodide_config);
    }
    ```

    This ensures preloading starts immediately and runs in parallel with entry screening. Do NOT await it -- it's fire-and-forget.

    **D. Add advancement gating.** Modify the `#advanceButton` click handler (line 1402). Currently it's:
    ```javascript
    $(function() {
        $('#advanceButton').click( () => {
            $("#advanceButton").hide();
            $("#advanceButton").attr("disabled", true);
            console.log("[AdvanceScene] Continue button clicked...");
            socket.emit("advance_scene", {session_id: window.sessionId});
        })
    })
    ```

    Change to gate on Pyodide readiness:
    ```javascript
    $(function() {
        $('#advanceButton').click( () => {
            // Gate advancement on Pyodide readiness (Phase 67)
            if (window.pyodidePreloadStatus === 'loading') {
                console.log('[AdvanceScene] Blocked - Pyodide still loading');
                return;
            }
            $("#advanceButton").hide();
            $("#advanceButton").attr("disabled", true);
            console.log("[AdvanceScene] Continue button clicked. Subject:", window.subjectName || interactiveGymGlobals?.subjectName);
            socket.emit("advance_scene", {session_id: window.sessionId});
        })
    })
    ```

    **E. Add Pyodide readiness polling for the advance button.** Modify the `startStaticScene` function to disable the advance button while Pyodide is loading, and poll to re-enable it. After the existing `startStaticScene` function sets up the UI (around line 1224), add a check:

    At the END of `startStaticScene(data)`, after `$("#sceneBody").html(data.scene_body);`, add:
    ```javascript
    // Gate advance button on Pyodide readiness (Phase 67)
    if (window.pyodidePreloadStatus === 'loading') {
        $("#advanceButton").attr("disabled", true);
        const pyodideGateInterval = setInterval(() => {
            if (window.pyodidePreloadStatus !== 'loading') {
                $("#advanceButton").attr("disabled", false);
                clearInterval(pyodideGateInterval);
            }
        }, 500);
    }
    ```

    This mirrors the existing `enableStartRefreshInterval()` pattern for the start button.

    **IMPORTANT:** Do NOT modify `RemoteGame`, `MultiplayerPyodideGame`, or `pyodide_remote_game.js` in this task. Those changes are Phase 68. The preloaded instance on `window.pyodideInstance` will be unused until Phase 68. The existing game classes will still call their own `loadPyodide()` -- this double-load is expected and documented in the research.
  </action>
  <verify>
    1. Grep `index.html` for `pyodideLoader` -- element exists.
    2. Grep `index.js` for `preloadPyodide` -- function exists and is called in experiment_config handler.
    3. Grep `index.js` for `pyodidePreloadStatus` -- used in preloadPyodide, advanceButton handler, and startStaticScene.
    4. Grep `index.js` for `showPyodideProgress` and `hidePyodideProgress` -- helper functions exist.
    5. Verify no changes to `pyodide_remote_game.js` or `pyodide_multiplayer_game.js` (those are Phase 68).
  </verify>
  <done>
    - index.html has #pyodideLoader element with spinner and status text
    - index.js has preloadPyodide() that loads Pyodide + micropip + packages, stores on window.pyodideInstance
    - preloadPyodide() is called (fire-and-forget) in experiment_config handler, concurrent with entry screening
    - Advance button is gated: disabled while pyodidePreloadStatus === 'loading', click handler returns early if loading
    - startStaticScene polls and re-enables advance button when loading completes
    - Error handling: preload failure sets status to 'error' but does NOT block advancement (graceful fallback)
    - Progress indicator shows "Loading Python runtime..." then "Installing packages..." then hides on ready
  </done>
</task>

</tasks>

<verification>
After both tasks are complete, verify the full integration:

1. **Server config detection works:**
   ```bash
   python -c "
   from interactive_gym.configurations.experiment_config import ExperimentConfig
   c = ExperimentConfig()
   print('No stager:', c.get_pyodide_config())
   "
   ```
   Expected: `{'needs_pyodide': False, 'packages_to_install': []}`

2. **RemoteConfig also works:**
   ```bash
   python -c "
   from interactive_gym.configurations.remote_config import RemoteConfig
   c = RemoteConfig()
   c.run_through_pyodide = True
   c.packages_to_install = ['numpy', 'pandas']
   print(c.get_pyodide_config())
   print(c.get_entry_screening_config())
   "
   ```

3. **No import errors in app.py:**
   ```bash
   python -c "from interactive_gym.server import app"
   ```

4. **Client-side code syntax valid (no JS errors):**
   Grep for balanced braces and function definitions in the modified sections.

5. **No changes to Phase 68 files:**
   ```bash
   git diff --name-only | grep -v 'experiment_config.py\|remote_config.py\|app.py\|index.html\|index.js'
   ```
   Should show nothing.
</verification>

<success_criteria>
- INIT-01: ExperimentConfig.get_pyodide_config() scans stager scenes, detects run_through_pyodide=True, collects packages_to_install union. RemoteConfig.get_pyodide_config() returns its own settings. app.py includes pyodide_config in experiment_config event.
- INIT-02: Client preloadPyodide() starts loadPyodide() + micropip.install() immediately on experiment_config receipt. Runs concurrently with entry screening. Stores result on window.pyodideInstance.
- INIT-03: #pyodideLoader element shows spinner + status text during loading. Three stages: "Loading Python runtime...", "Installing packages...", then hidden on ready.
- INIT-04: Advance button disabled while loading. Click handler returns early if loading. Polls at 500ms to re-enable when ready. Error state does NOT block advancement (graceful fallback).
</success_criteria>

<output>
After completion, create `.planning/phases/67-pyodide-preload-infrastructure/67-01-SUMMARY.md`
</output>
