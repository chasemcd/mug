---
phase: 56-custom-attributes-logging
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/match_logger.py
  - interactive_gym/server/game_manager.py
  - interactive_gym/server/app.py
autonomous: true

must_haves:
  truths:
    - "Match decisions are recorded with timestamp and participant details"
    - "RTT values are included in match assignment records"
    - "Match logs are accessible for research analysis"
    - "Match events appear in admin activity timeline"
  artifacts:
    - path: "interactive_gym/server/match_logger.py"
      provides: "MatchAssignmentLogger class with log_match() method"
      exports: ["MatchAssignment", "MatchAssignmentLogger"]
    - path: "data/match_logs/{scene_id}_matches.jsonl"
      provides: "JSONL file with match assignment records"
      contains: "subject_id.*rtt_ms"
  key_links:
    - from: "interactive_gym/server/game_manager.py"
      to: "interactive_gym/server/match_logger.py"
      via: "self.match_logger.log_match() call"
      pattern: "match_logger\\.log_match"
    - from: "interactive_gym/server/match_logger.py"
      to: "interactive_gym/server/admin/aggregator.py"
      via: "admin_aggregator.log_activity() call"
      pattern: "admin_aggregator\\.log_activity"
---

<objective>
Add assignment logging to record match decisions for research analysis

Purpose: Researchers need to analyze match decisions (who matched with whom, RTT values, timestamps) for post-experiment analysis. This completes v1.12 requirements DATA-01 and DATA-02.

Output:
- MatchAssignmentLogger class that logs match events to JSONL files and admin dashboard
- GameManager integration that calls logger after match formation
- App.py wiring that creates and passes logger to GameManager
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/56-custom-attributes-logging/56-RESEARCH.md
@.planning/phases/55-matchmaker-base-class/55-01-SUMMARY.md
@.planning/phases/55-matchmaker-base-class/55-02-SUMMARY.md
@interactive_gym/server/matchmaker.py
@interactive_gym/server/game_manager.py
@interactive_gym/server/admin/aggregator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MatchAssignmentLogger class</name>
  <files>interactive_gym/server/match_logger.py</files>
  <action>
Create new file `interactive_gym/server/match_logger.py` with:

1. **MatchAssignment dataclass** - immutable record of a match decision:
   - timestamp: float (Unix timestamp when match formed)
   - scene_id: str (scene where match occurred)
   - game_id: str (unique game identifier)
   - participants: list[dict] (each with subject_id and rtt_ms)
   - matchmaker_class: str (name of matchmaker that formed the match)

2. **MatchAssignmentLogger class**:
   - MATCH_LOGS_DIR = "data/match_logs" (class constant)
   - __init__(admin_aggregator=None): Store aggregator reference, create logs directory with os.makedirs(exist_ok=True)
   - log_match(scene_id, game_id, matched_candidates, matchmaker_class):
     - Build MatchAssignment from parameters
     - If admin_aggregator present, call log_activity("match_formed", ...) with game_id, participant subject_ids, rtt_values, matchmaker name
     - Call _write_to_file() to persist
   - _write_to_file(scene_id, assignment): Append JSON line to {MATCH_LOGS_DIR}/{scene_id}_matches.jsonl

Use TYPE_CHECKING import for MatchCandidate to avoid circular imports.
Follow existing codebase patterns from admin/aggregator.py for:
- Dataclass with default_factory
- JSON serialization via dataclasses.asdict()
- JSONL format for file persistence

Do NOT use threading or background tasks - file I/O is fast at match rate.
  </action>
  <verify>
    - File exists at interactive_gym/server/match_logger.py
    - `python -c "from interactive_gym.server.match_logger import MatchAssignment, MatchAssignmentLogger; print('Import OK')"` succeeds
    - Class has MATCH_LOGS_DIR, log_match(), _write_to_file() methods
  </verify>
  <done>
    - MatchAssignment dataclass defined with all required fields
    - MatchAssignmentLogger class can log to file and admin dashboard
    - Import statement works without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate logger into GameManager</name>
  <files>interactive_gym/server/game_manager.py</files>
  <action>
Modify `interactive_gym/server/game_manager.py`:

1. **Add import** at top of file (after existing matchmaker imports):
   ```python
   from interactive_gym.server.match_logger import MatchAssignmentLogger
   ```

2. **Add parameter to __init__**:
   Add `match_logger: MatchAssignmentLogger | None = None` parameter after `matchmaker` parameter.
   Store as `self.match_logger = match_logger`

3. **Add logging call in _create_game_for_match()**:
   After the game is created and before returning, add logging call:
   ```python
   # Log match assignment (Phase 56)
   if self.match_logger:
       self.match_logger.log_match(
           scene_id=self.scene.scene_id,
           game_id=game.game_id,
           matched_candidates=matched,
           matchmaker_class=type(self.matchmaker).__name__,
       )
   ```
   This should be placed AFTER game creation but BEFORE the `return game` statement.
   The logging must happen inside the lock scope to ensure state consistency.

4. **Also add logging in _create_game_for_group()** (for group reunions):
   Add similar logging call after game creation:
   ```python
   # Log match assignment for group reunion (Phase 56)
   if self.match_logger:
       # Build MatchCandidate list from subject_ids
       from interactive_gym.server.matchmaker import MatchCandidate
       candidates = [
           MatchCandidate(
               subject_id=sid,
               rtt_ms=self.get_subject_rtt(sid) if self.get_subject_rtt else None
           )
           for sid in subject_ids
       ]
       self.match_logger.log_match(
           scene_id=self.scene.scene_id,
           game_id=game.game_id,
           matched_candidates=candidates,
           matchmaker_class="GroupReunion",
       )
   ```

Keep match_logger parameter optional (None default) for backward compatibility.
  </action>
  <verify>
    - `grep -n "match_logger" interactive_gym/server/game_manager.py` shows parameter in __init__ and calls in both methods
    - `python -c "from interactive_gym.server.game_manager import GameManager; print('Import OK')"` succeeds
  </verify>
  <done>
    - GameManager.__init__ accepts match_logger parameter
    - _create_game_for_match() logs match assignments
    - _create_game_for_group() logs group reunion assignments
    - Backward compatibility maintained (parameter is optional)
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire logger through app.py</name>
  <files>interactive_gym/server/app.py</files>
  <action>
Modify `interactive_gym/server/app.py`:

1. **Add import** near other server imports:
   ```python
   from interactive_gym.server.match_logger import MatchAssignmentLogger
   ```

2. **Add module-level variable** after ADMIN_AGGREGATOR declaration:
   ```python
   MATCH_LOGGER: MatchAssignmentLogger | None = None
   ```

3. **Initialize logger** in the `advance_scene` handler, before GameManager creation:
   Find the section where GameManager is created (search for `gm.GameManager(`).
   Before that creation, add:
   ```python
   # Initialize match logger if not already done (Phase 56)
   global MATCH_LOGGER
   if MATCH_LOGGER is None:
       MATCH_LOGGER = MatchAssignmentLogger(admin_aggregator=ADMIN_AGGREGATOR)
   ```

4. **Pass logger to GameManager**:
   In the GameManager constructor call, add `match_logger=MATCH_LOGGER` parameter:
   ```python
   game_manager = gm.GameManager(
       scene=current_scene,
       experiment_config=experiment_config,
       sio=sio,
       pyodide_coordinator=PYODIDE_COORDINATOR,
       pairing_manager=PAIRING_MANAGER,
       get_subject_rtt=_get_subject_rtt,
       participant_state_tracker=PARTICIPANT_TRACKER,
       matchmaker=scene.matchmaker,
       match_logger=MATCH_LOGGER,  # Phase 56
   )
   ```

The logger should be initialized once and reused across all scenes (shared instance).
  </action>
  <verify>
    - `grep -n "MATCH_LOGGER" interactive_gym/server/app.py` shows declaration and usage
    - `grep -n "match_logger=" interactive_gym/server/app.py` shows parameter passed to GameManager
    - Server starts without import errors: `cd /Users/chasemcd/Repositories/interactive-gym && timeout 5 python -c "from interactive_gym.server.app import create_app; print('App imports OK')" 2>&1 || true`
  </verify>
  <done>
    - MATCH_LOGGER module variable declared
    - Logger initialized with ADMIN_AGGREGATOR before GameManager creation
    - Logger passed to GameManager constructor
    - Server imports without errors
  </done>
</task>

</tasks>

<verification>
Run the following checks after all tasks complete:

1. **Import check:**
   ```bash
   python -c "from interactive_gym.server.match_logger import MatchAssignment, MatchAssignmentLogger; print('match_logger OK')"
   python -c "from interactive_gym.server.game_manager import GameManager; print('game_manager OK')"
   python -c "from interactive_gym.server.app import create_app; print('app OK')"
   ```

2. **Integration check:**
   ```bash
   python -c "
from interactive_gym.server.match_logger import MatchAssignmentLogger, MatchAssignment
from interactive_gym.server.matchmaker import MatchCandidate

# Test logger without admin aggregator
logger = MatchAssignmentLogger()

# Test log_match with mock data
candidates = [
    MatchCandidate(subject_id='test-1', rtt_ms=50),
    MatchCandidate(subject_id='test-2', rtt_ms=75)
]
logger.log_match(
    scene_id='test-scene',
    game_id='test-game-123',
    matched_candidates=candidates,
    matchmaker_class='FIFOMatchmaker'
)
print('Logger test OK')

# Verify file was created
import os
assert os.path.exists('data/match_logs/test-scene_matches.jsonl'), 'Log file not created'
print('File created OK')

# Verify content
import json
with open('data/match_logs/test-scene_matches.jsonl') as f:
    record = json.loads(f.readline())
    assert record['scene_id'] == 'test-scene'
    assert record['game_id'] == 'test-game-123'
    assert len(record['participants']) == 2
    assert record['participants'][0]['rtt_ms'] == 50
print('Content verified OK')
"
   ```

3. **Existing tests pass:**
   ```bash
   cd /Users/chasemcd/Repositories/interactive-gym && python -m pytest tests/e2e/test_infrastructure.py -v --headed 2>&1 | head -50
   ```
</verification>

<success_criteria>
Phase 56 is complete when:
- MatchAssignmentLogger class exists and can log match events
- Match logs written to data/match_logs/{scene_id}_matches.jsonl in JSONL format
- Each match record includes: timestamp, scene_id, game_id, participants (with subject_id and rtt_ms), matchmaker_class
- GameManager logs matches after formation (both FIFO and group reunion)
- Admin dashboard receives "match_formed" activity events via log_activity()
- All existing E2E tests pass (no regression)
- DATA-01 requirement satisfied (assignment logging)
- DATA-02 requirement satisfied (RTT exposed - already done in Phase 55, verified here)
</success_criteria>

<output>
After completion, create `.planning/phases/56-custom-attributes-logging/56-01-SUMMARY.md` using the summary template.
</output>
