---
phase: 64-multi-participant-test-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/conftest.py
  - tests/fixtures/multi_participant.py
  - tests/e2e/test_multi_participant.py
autonomous: true

must_haves:
  truths:
    - "6 browser contexts can be launched simultaneously from a single browser instance"
    - "3 concurrent games can be orchestrated with correct player pairing"
    - "Staggered participant arrival correctly pairs intended partners"
  artifacts:
    - path: "tests/conftest.py"
      provides: "multi_participant_contexts fixture yielding 6 pages"
      contains: "def multi_participant_contexts"
    - path: "tests/fixtures/multi_participant.py"
      provides: "GameOrchestrator helper class for multi-game coordination"
      contains: "class GameOrchestrator"
      min_lines: 80
    - path: "tests/e2e/test_multi_participant.py"
      provides: "Validation test for 6-participant infrastructure"
      contains: "def test_three_simultaneous_games"
      min_lines: 100
  key_links:
    - from: "tests/e2e/test_multi_participant.py"
      to: "tests/conftest.py"
      via: "multi_participant_contexts fixture injection"
      pattern: "multi_participant_contexts"
    - from: "tests/e2e/test_multi_participant.py"
      to: "tests/fixtures/multi_participant.py"
      via: "GameOrchestrator import"
      pattern: "from tests.fixtures.multi_participant import"
---

<objective>
Build test infrastructure supporting 6 concurrent participants (3 simultaneous games)

Purpose: Enable stress testing scenarios (STRESS-02 through STRESS-07) that require multiple concurrent games to validate server state management and data parity under realistic load
Output: Pytest fixture for 6 browser contexts, orchestration helper, and validation test proving infrastructure works
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/64-multi-participant-test-infrastructure/64-RESEARCH.md
@tests/conftest.py
@tests/fixtures/game_helpers.py
@tests/fixtures/export_helpers.py
@tests/e2e/test_network_disruption.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add multi_participant_contexts fixture to conftest.py</name>
  <files>tests/conftest.py</files>
  <action>
Add a new fixture `multi_participant_contexts` that creates 6 isolated browser contexts from a single browser instance.

Pattern to follow (from existing `player_contexts` fixture):
- Function-scoped (fresh contexts for each test)
- Use Chrome user agent to pass browser entry screening
- Use try/finally to ensure all contexts are closed even on error
- Yield tuple of 6 pages

Implementation:
```python
@pytest.fixture(scope="function")
def multi_participant_contexts(browser):
    """
    Create 6 isolated browser contexts for multi-participant stress testing.

    Scope: function (fresh contexts for each test)
    Yields: tuple of 6 pages (page1, page2, page3, page4, page5, page6)

    Intended grouping: (page1, page2) = Game 1, (page3, page4) = Game 2, (page5, page6) = Game 3

    Note: Uses standard Chrome user agent to pass browser entry screening.
    Browser contexts are lightweight (KB not MB) so 6 contexts per browser is safe.
    """
    chrome_ua = (
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) "
        "AppleWebKit/537.36 (KHTML, like Gecko) "
        "Chrome/120.0.0.0 Safari/537.36"
    )

    contexts = []
    pages = []

    try:
        for i in range(6):
            ctx = browser.new_context(user_agent=chrome_ua)
            page = ctx.new_page()
            contexts.append(ctx)
            pages.append(page)

        yield tuple(pages)

    finally:
        # Cleanup: close all contexts even on error
        for ctx in contexts:
            try:
                ctx.close()
            except Exception:
                pass
```

Add this after the existing `player_contexts` fixture.

Why 6 contexts from 1 browser:
- Browser contexts are lightweight (KB each, not 50-150MB like separate browsers)
- Playwright supports dozens of contexts per browser
- Shared browser process = faster setup, lower memory
  </action>
  <verify>
Run: `grep -n "def multi_participant_contexts" tests/conftest.py`
Should show the new fixture definition.

Run: `grep -c "browser.new_context" tests/conftest.py`
Should show 3 occurrences (2 in player_contexts, 6 in loop for multi_participant_contexts = 2 + 1 for loop reference).
Actually: Check visually that the fixture creates 6 contexts.
  </verify>
  <done>conftest.py has multi_participant_contexts fixture that yields 6 isolated browser pages</done>
</task>

<task type="auto">
  <name>Task 2: Create GameOrchestrator helper class</name>
  <files>tests/fixtures/multi_participant.py</files>
  <action>
Create a new file `tests/fixtures/multi_participant.py` with the GameOrchestrator class.

This class manages multiple concurrent 2-player games:
- Organizes 6 pages into 3 game pairs
- Handles staggered navigation to ensure correct FIFO matchmaker pairing
- Provides methods for parallel game progression
- Tracks per-game state and identifiers for verification

Implementation:
```python
"""
Multi-participant test orchestration helpers.

Provides GameOrchestrator class for managing 3 concurrent 2-player games,
used by multi-participant stress tests (STRESS-01 through STRESS-07).
"""
import time
from typing import List, Tuple

from playwright.sync_api import Page

from tests.fixtures.game_helpers import (
    wait_for_socket_connected,
    wait_for_game_canvas,
    wait_for_game_object,
    wait_for_episode_complete,
    get_game_state,
    click_advance_button,
    click_start_button,
    get_scene_id,
)
from tests.fixtures.network_helpers import set_tab_visibility
from tests.fixtures.export_helpers import (
    get_experiment_id,
    get_subject_ids_from_pages,
    wait_for_export_files,
    run_comparison,
)


class GameOrchestrator:
    """
    Manages multiple concurrent 2-player games for stress testing.

    Organizes 6 pages into 3 game pairs and provides methods for:
    - Staggered navigation (ensures correct FIFO matchmaker pairing)
    - Parallel game progression through UI flow
    - Episode completion waiting
    - Data parity validation per game

    Usage:
        orchestrator = GameOrchestrator(pages, base_url)
        orchestrator.navigate_all_staggered()
        orchestrator.start_all_games()
        orchestrator.wait_for_all_episodes_complete()
        results = orchestrator.validate_all_data_parity()
    """

    def __init__(self, pages: Tuple[Page, ...], base_url: str):
        """
        Initialize orchestrator with 6 pages organized as 3 game pairs.

        Args:
            pages: Tuple of 6 Playwright Page objects
            base_url: Flask server URL

        Raises:
            ValueError: If pages tuple doesn't contain exactly 6 pages
        """
        if len(pages) != 6:
            raise ValueError(f"Expected 6 pages, got {len(pages)}")

        self.pages = pages
        self.base_url = base_url

        # Organize into game pairs: (page1, page2) = Game 0, etc.
        self.games: List[Tuple[Page, Page]] = [
            (pages[0], pages[1]),  # Game 0
            (pages[2], pages[3]),  # Game 1
            (pages[4], pages[5]),  # Game 2
        ]

        # Per-game tracking (populated after games start)
        self.game_ids: List[str] = [None, None, None]
        self.subject_ids: List[Tuple[str, str]] = [None, None, None]

    def navigate_all_staggered(self, delay_between_pairs_ms: int = 100, delay_between_games_ms: int = 1000) -> None:
        """
        Navigate all participants with staggered timing for correct FIFO pairing.

        The FIFO matchmaker pairs participants in arrival order. To ensure
        (page1, page2) become partners, they must navigate close together
        with a gap before (page3, page4).

        Args:
            delay_between_pairs_ms: Delay between partners in same game (small, ~100ms)
            delay_between_games_ms: Delay between game pairs (larger, ~1000ms)
        """
        for game_idx, (page1, page2) in enumerate(self.games):
            if game_idx > 0:
                # Wait before starting next game pair
                time.sleep(delay_between_games_ms / 1000)

            # Navigate both partners close together
            page1.goto(self.base_url)
            time.sleep(delay_between_pairs_ms / 1000)
            page2.goto(self.base_url)

    def wait_for_all_sockets(self, timeout: int = 30000) -> None:
        """Wait for all 6 participants to establish socket connections."""
        for page in self.pages:
            wait_for_socket_connected(page, timeout=timeout)

    def advance_all_through_instructions(self, timeout: int = 60000) -> None:
        """Click advance button for all participants (pass instruction screens)."""
        for page in self.pages:
            click_advance_button(page, timeout=timeout)

    def start_all_matchmaking(self, timeout: int = 60000) -> None:
        """Click start button for all participants (enter matchmaking)."""
        for page in self.pages:
            click_start_button(page, timeout=timeout)

    def wait_for_all_games_started(self, timeout: int = 120000) -> None:
        """
        Wait for all 6 participants to have game canvas and game object ready.
        Also sets tab visibility for Playwright automation.
        """
        for page in self.pages:
            wait_for_game_canvas(page, timeout=timeout)
            wait_for_game_object(page, timeout=timeout)
            set_tab_visibility(page, visible=True)

    def verify_game_pairings(self) -> None:
        """
        Verify that intended pairs are in the same game.

        Populates self.game_ids with verified game IDs.

        Raises:
            AssertionError: If any pair is not in the same game
        """
        for game_idx, (page1, page2) in enumerate(self.games):
            state1 = get_game_state(page1)
            state2 = get_game_state(page2)

            assert state1["gameId"] == state2["gameId"], (
                f"Game {game_idx}: Players not matched correctly. "
                f"Player 1 gameId={state1['gameId']}, Player 2 gameId={state2['gameId']}"
            )
            assert state1["playerId"] != state2["playerId"], (
                f"Game {game_idx}: Players have same playerId (should be different)"
            )

            self.game_ids[game_idx] = state1["gameId"]
            print(f"Game {game_idx}: Verified pairing, gameId={state1['gameId']}")

    def start_all_games(self) -> None:
        """
        Run all games through the full startup flow.

        This is a convenience method that runs:
        1. navigate_all_staggered
        2. wait_for_all_sockets
        3. advance_all_through_instructions
        4. start_all_matchmaking
        5. wait_for_all_games_started
        6. verify_game_pairings
        """
        print("Starting 3 games with 6 participants...")

        self.navigate_all_staggered()
        self.wait_for_all_sockets()
        self.advance_all_through_instructions()
        self.start_all_matchmaking()
        self.wait_for_all_games_started()
        self.verify_game_pairings()

        print("All 3 games started and verified")

    def wait_for_all_episodes_complete(self, episode_num: int = 1, timeout: int = 180000) -> None:
        """
        Wait for all 6 participants to complete the specified episode.

        Args:
            episode_num: Episode number to wait for (1 = first episode complete)
            timeout: Timeout per participant in milliseconds
        """
        for game_idx, (page1, page2) in enumerate(self.games):
            wait_for_episode_complete(page1, episode_num=episode_num, timeout=timeout)
            wait_for_episode_complete(page2, episode_num=episode_num, timeout=timeout)
            print(f"Game {game_idx}: Episode {episode_num} complete")

    def collect_subject_ids(self) -> None:
        """
        Collect subject IDs from all games for export file lookup.

        Populates self.subject_ids with tuples of (subject1, subject2) per game.
        """
        for game_idx, (page1, page2) in enumerate(self.games):
            self.subject_ids[game_idx] = get_subject_ids_from_pages(page1, page2)

    def validate_all_data_parity(self, episode_num: int = 0, timeout_sec: int = 30) -> List[Tuple[int, str]]:
        """
        Validate data parity for all completed games.

        Args:
            episode_num: Episode number to validate (0-indexed: first episode = 0)
            timeout_sec: Timeout waiting for export files

        Returns:
            List of (exit_code, output) tuples for each game.
            exit_code 0 = parity verified, 1 = divergence found.
        """
        if not any(self.subject_ids):
            self.collect_subject_ids()

        experiment_id = get_experiment_id()
        scene_id = get_scene_id(self.pages[0])

        results = []

        for game_idx, subject_ids in enumerate(self.subject_ids):
            try:
                file1, file2 = wait_for_export_files(
                    experiment_id=experiment_id,
                    scene_id=scene_id,
                    subject_ids=subject_ids,
                    episode_num=episode_num,
                    timeout_sec=timeout_sec
                )
                exit_code, output = run_comparison(file1, file2, verbose=True)
                results.append((exit_code, output))

                if exit_code == 0:
                    print(f"Game {game_idx}: Data parity VERIFIED")
                else:
                    print(f"Game {game_idx}: Data parity FAILED - {output}")

            except TimeoutError as e:
                results.append((1, f"Export files not found: {e}"))
                print(f"Game {game_idx}: Export files not found")

        return results
```

Also update `tests/fixtures/__init__.py` to export the new module (if it has exports, otherwise skip).
  </action>
  <verify>
Run: `python -c "from tests.fixtures.multi_participant import GameOrchestrator; print('Import OK')"`
Should print "Import OK" without errors.

Run: `grep -c "def " tests/fixtures/multi_participant.py`
Should show 10+ method definitions.
  </verify>
  <done>GameOrchestrator class created with methods for managing 3 concurrent games</done>
</task>

<task type="auto">
  <name>Task 3: Create validation test for 6-participant infrastructure</name>
  <files>tests/e2e/test_multi_participant.py</files>
  <action>
Create a new test file `tests/e2e/test_multi_participant.py` that validates the infrastructure works.

This test proves STRESS-01 is satisfied:
- 6 browser contexts launch simultaneously
- 3 concurrent games orchestrated correctly
- All games complete and pass data parity validation

Implementation:
```python
"""
Multi-participant stress tests.

These tests validate infrastructure and scenarios requiring 6 concurrent
participants (3 simultaneous games). Builds on test infrastructure from
Phase 64 (STRESS-01) to enable lifecycle stress tests in Phase 65.

Tests:
- test_three_simultaneous_games: STRESS-01 infrastructure validation
- test_staggered_participant_arrival: Validates FIFO pairing under realistic timing

Requires headed mode for WebRTC:
    pytest tests/e2e/test_multi_participant.py --headed

Or set PWHEADED=1 environment variable.
"""
import pytest
import time

from tests.fixtures.multi_participant import GameOrchestrator
from tests.fixtures.game_helpers import (
    wait_for_socket_connected,
    click_advance_button,
    click_start_button,
    wait_for_game_canvas,
    get_game_state,
)
from tests.fixtures.network_helpers import set_tab_visibility


# =============================================================================
# STRESS-01: Multi-Participant Infrastructure Validation
# =============================================================================

@pytest.mark.timeout(600)  # 10 minutes for 3 concurrent games
def test_three_simultaneous_games(multi_participant_contexts, flask_server):
    """
    STRESS-01: Test infrastructure supports 6 concurrent participants.

    Validates:
    1. 6 browser contexts can be created from single browser
    2. Server handles 3 concurrent game sessions
    3. All intended pairs match correctly via FIFO matchmaker
    4. All games complete successfully
    5. Data parity verified for all games

    This is the infrastructure foundation test. If this passes, the
    infrastructure is ready for lifecycle stress tests in Phase 65.
    """
    pages = multi_participant_contexts  # Tuple of 6 pages
    base_url = flask_server["url"]

    # Create orchestrator
    orchestrator = GameOrchestrator(pages, base_url)

    # Start all 3 games
    orchestrator.start_all_games()

    # Wait for all episodes to complete
    orchestrator.wait_for_all_episodes_complete(episode_num=1, timeout=180000)

    # Validate data parity for all games
    results = orchestrator.validate_all_data_parity(episode_num=0)

    # Assert all games passed parity
    for game_idx, (exit_code, output) in enumerate(results):
        assert exit_code == 0, (
            f"Game {game_idx} data parity failed:\n{output}"
        )

    print(f"\n[STRESS-01] All 3 games completed with verified data parity")


@pytest.mark.timeout(600)  # 10 minutes
def test_staggered_participant_arrival(multi_participant_contexts, flask_server):
    """
    Test that infrastructure handles staggered participant arrival correctly.

    Simulates realistic scenario where participants arrive at different times:
    - Game 1 players arrive first
    - 2 second delay
    - Game 2 players arrive
    - 2 second delay
    - Game 3 players arrive

    Validates that FIFO matchmaker correctly pairs intended partners
    despite significant arrival gaps.
    """
    pages = multi_participant_contexts
    base_url = flask_server["url"]

    STAGGER_DELAY_SEC = 2.0

    games = [
        (pages[0], pages[1]),  # Game 0
        (pages[2], pages[3]),  # Game 1
        (pages[4], pages[5]),  # Game 2
    ]

    # Navigate with large stagger between game pairs
    for game_idx, (page1, page2) in enumerate(games):
        if game_idx > 0:
            print(f"Waiting {STAGGER_DELAY_SEC}s before Game {game_idx}...")
            time.sleep(STAGGER_DELAY_SEC)

        # Navigate partners close together (small gap)
        page1.goto(base_url)
        time.sleep(0.1)  # 100ms gap between partners
        page2.goto(base_url)
        print(f"Game {game_idx}: Both players navigated")

    # Wait for all sockets
    for page in pages:
        wait_for_socket_connected(page, timeout=30000)

    # Advance through instructions
    for page in pages:
        click_advance_button(page, timeout=60000)

    # Start matchmaking
    for page in pages:
        click_start_button(page, timeout=60000)

    # Wait for all game canvases
    for page in pages:
        wait_for_game_canvas(page, timeout=120000)
        set_tab_visibility(page, visible=True)

    # Verify pairings
    for game_idx, (page1, page2) in enumerate(games):
        state1 = get_game_state(page1)
        state2 = get_game_state(page2)

        assert state1["gameId"] == state2["gameId"], (
            f"Game {game_idx}: Players not paired correctly after {STAGGER_DELAY_SEC}s stagger. "
            f"Player 1 gameId={state1['gameId']}, Player 2 gameId={state2['gameId']}"
        )
        print(f"Game {game_idx}: Verified correct pairing, gameId={state1['gameId']}")

    print(f"\n[Staggered Arrival] All 3 games paired correctly with {STAGGER_DELAY_SEC}s stagger")
```
  </action>
  <verify>
Run: `python -c "import tests.e2e.test_multi_participant; print('Import OK')"`
Should print "Import OK" without errors.

Run: `grep -n "def test_" tests/e2e/test_multi_participant.py`
Should show 2 test functions.

Run the actual test (headed mode required):
`pytest tests/e2e/test_multi_participant.py::test_three_simultaneous_games --headed -v --timeout=600`
Should pass (may take 5-10 minutes).
  </verify>
  <done>Multi-participant test file created with infrastructure validation tests</done>
</task>

</tasks>

<verification>
Phase verification (after all tasks):
1. `grep -n "def multi_participant_contexts" tests/conftest.py` shows fixture exists
2. `python -c "from tests.fixtures.multi_participant import GameOrchestrator; print('OK')"` succeeds
3. `pytest tests/e2e/test_multi_participant.py::test_three_simultaneous_games --headed -v` passes
4. Test output shows "All 3 games completed with verified data parity"
</verification>

<success_criteria>
- [ ] multi_participant_contexts fixture creates 6 isolated browser contexts
- [ ] GameOrchestrator class manages 3 concurrent game pairs
- [ ] test_three_simultaneous_games passes (6 participants, 3 games complete)
- [ ] test_staggered_participant_arrival passes (correct FIFO pairing)
- [ ] All completed games pass exact data parity validation
- [ ] STRESS-01 requirement satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/64-multi-participant-test-infrastructure/64-01-SUMMARY.md`
</output>
