---
phase: 06-ggpo-input-queue-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/static/js/pyodide_multiplayer_game.js
autonomous: true

must_haves:
  truths:
    - "P2P inputs arriving during rollback are queued, not lost"
    - "Queued inputs are processed synchronously at frame start"
    - "Rollback executes as a tight loop without event loop yields between replay frames"
    - "Games remain visually synchronized after rollbacks under artificial delay"
    - "No misprediction triggers new rollback during replay"
  artifacts:
    - path: "interactive_gym/server/static/js/pyodide_multiplayer_game.js"
      provides: "GGPO-style input queue and synchronous rollback"
      contains: "pendingInputPackets"
  key_links:
    - from: "_handleInputPacket"
      to: "pendingInputPackets"
      via: "push to queue instead of direct storeRemoteInput"
      pattern: "pendingInputPackets\\.push"
    - from: "step()"
      to: "_processQueuedInputs()"
      via: "called at frame start before getInputsForFrame"
      pattern: "_processQueuedInputs\\(\\)"
    - from: "performRollback"
      to: "env.step"
      via: "synchronous replay loop (no await between frame steps)"
      pattern: "for.*frame.*env\\.step"
---

<objective>
Implement GGPO-style synchronous input processing to fix rollback divergence.

Purpose: The current implementation processes P2P messages asynchronously via event handlers that can fire during `await` calls in the middle of rollback. This causes inputs to arrive for frames we've already replayed, triggering cascading rollbacks and visual divergence. Per GGPO best practices, inputs must be queued during network reception and processed synchronously at frame start.

Output: Modified `pyodide_multiplayer_game.js` with input queuing and synchronous rollback that eliminates race conditions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@interactive_gym/server/static/js/pyodide_multiplayer_game.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add input packet queue and modify _handleInputPacket to queue only</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
    1. In constructor or class properties, add `pendingInputPackets = []` array to queue incoming P2P input packets.

    2. Modify `_handleInputPacket(buffer)` (around line 3035) to ONLY queue the packet, not process it:
       - Decode the packet (keep existing `decodeInputPacket(buffer)` call)
       - Push the decoded packet to `this.pendingInputPackets` array
       - Keep the metrics update (`this.p2pMetrics.inputsReceivedViaP2P++`)
       - Keep the connection health recording
       - REMOVE the loop that calls `queueRemoteInputWithDelay()` - this will move to _processQueuedInputs

    3. Create new method `_processQueuedInputs()` that:
       - Drains all packets from `this.pendingInputPackets` (set to empty array after copying)
       - For each packet:
         - Convert player index to player ID (existing `this.indexToPlayerId[packet.playerId]`)
         - For each input in packet.inputs, call `this.queueRemoteInputWithDelay(playerId, input.action, input.frame)`
       - This method does NOT detect or trigger rollback - that happens in existing `storeRemoteInput()`

    4. Also queue SocketIO inputs similarly:
       - In the 'pyodide_partner_action' handler (around line 630), instead of calling `queueRemoteInputWithDelay()` directly, push to a `pendingSocketIOInputs` array
       - Add `pendingSocketIOInputs = []` to constructor
       - Update `_processQueuedInputs()` to also drain and process `pendingSocketIOInputs`
  </action>
  <verify>
    - Grep for `pendingInputPackets` in the file - should exist as property and in _handleInputPacket
    - Grep for `_processQueuedInputs` - should exist as method
    - Grep for `queueRemoteInputWithDelay` in `_handleInputPacket` - should NOT exist (moved to _processQueuedInputs)
  </verify>
  <done>
    - `_handleInputPacket` only queues packets, does not call storeRemoteInput
    - `_processQueuedInputs` method exists and drains both P2P and SocketIO queues
    - Both input sources (P2P and SocketIO) are queued for synchronous processing
  </done>
</task>

<task type="auto">
  <name>Task 2: Call _processQueuedInputs at frame start and make rollback synchronous</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
    1. In `step()` method (line ~1251), add call to `_processQueuedInputs()` early in the function:
       - Place AFTER the early returns for missing player/game ID (lines 1267-1275)
       - Place BEFORE `processDelayedInputs()` (line 1316)
       - This ensures all queued network inputs are in the buffer before we check for rollback

    2. Move rollback check and execution BEFORE stepping the current frame:
       - Currently rollback happens AFTER `stepWithActions()` (around line 1414)
       - Move the entire rollback block (lines 1411-1425) to BEFORE the snapshot save (line 1383)
       - This way: process queued inputs -> detect rollback -> execute rollback -> THEN step current frame
       - Update the comment to reflect GGPO order of operations

    3. In `performRollback()` (line ~2493), make the replay loop synchronous:
       - The issue: `await this.pyodide.runPythonAsync()` yields to event loop, allowing new packets to arrive
       - Solution: Batch all replay steps into a single Python call
       - Create a Python code string that loops through all frames from snapshotFrame to currentFrame
       - Pass the actions for each frame as a JSON array
       - Execute ONE `runPythonAsync()` call for the entire replay

       Example structure:
       ```javascript
       // Build replay data
       const replayFrames = [];
       for (let frame = snapshotFrame; frame < currentFrame; frame++) {
           const humanInputs = this.getInputsForFrame(frame, playerIds, false);
           // ... build envActions like current code ...
           replayFrames.push({ frame, actions: envActions });
       }

       // Single Python call for all replay frames
       await this.pyodide.runPythonAsync(`
       _replay_frames = ${JSON.stringify(replayFrames)}
       for _rf in _replay_frames:
           _actions = {int(k) if str(k).isdigit() else k: v for k, v in _rf['actions'].items()}
           env.step(_actions)
       `);

       // Update JS state after replay completes
       this.frameNumber = currentFrame;
       ```

    4. Keep the existing action sequence recording logic but move it OUTSIDE the batched Python call:
       - Before the batched call, compute all actions and record to actionSequence
       - The Python batch handles the actual env.step() calls

    5. Clear `pendingRollbackFrame` at the START of step() (before processing queued inputs) to prevent stale rollbacks.
  </action>
  <verify>
    - Run the game with two browser tabs and `window.debugRemoteInputDelay = 2` set in console
    - Verify rollback log messages appear (ROLLBACK: player=X frame=Y depth=Z)
    - Verify both players see identical game state after rollbacks complete
    - Check console for any errors during replay
  </verify>
  <done>
    - `_processQueuedInputs()` called at frame start in step()
    - Rollback detection and execution happens BEFORE stepping current frame
    - Replay loop executes as single Python batch call (no event loop yields during replay)
    - Games remain synchronized under artificial delay testing
  </done>
</task>

<task type="auto">
  <name>Task 3: Add rollback-in-progress guard to prevent nested rollbacks</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
    1. Add `rollbackInProgress = false` flag to constructor/class properties.

    2. In `_processQueuedInputs()`, check and respect the flag:
       - If `this.rollbackInProgress` is true, DO NOT process inputs (they stay queued)
       - This prevents inputs from triggering new rollbacks while we're still replaying

    3. In `performRollback()`:
       - Set `this.rollbackInProgress = true` at the start (after early returns)
       - Set `this.rollbackInProgress = false` at the end (in finally block or after replay)
       - This guards the entire rollback operation

    4. In `storeRemoteInput()`, skip rollback detection if `rollbackInProgress`:
       - Add check: `if (this.rollbackInProgress) { /* store input but don't set pendingRollbackFrame */ }`
       - This way inputs arriving during rollback are stored (for future use) but don't trigger another rollback

    5. Update `clearGGPOState()` to reset:
       - `this.pendingInputPackets = []`
       - `this.pendingSocketIOInputs = []`
       - `this.rollbackInProgress = false`
  </action>
  <verify>
    - Grep for `rollbackInProgress` - should appear in constructor, performRollback, storeRemoteInput, clearGGPOState
    - Test with `window.debugRemoteInputDelay = 3` (higher delay = more rollback nesting opportunity)
    - Verify no "nested rollback" warnings or errors in console
    - Verify game completes episode without freezing
  </verify>
  <done>
    - `rollbackInProgress` flag prevents nested rollbacks
    - Inputs arriving during rollback are queued but don't trigger new rollbacks
    - Flag is properly reset in clearGGPOState for episode transitions
    - System handles high artificial delay without cascading rollbacks
  </done>
</task>

</tasks>

<verification>
1. Unit verification:
   - `grep -n "pendingInputPackets" pyodide_multiplayer_game.js` shows queue usage
   - `grep -n "_processQueuedInputs" pyodide_multiplayer_game.js` shows method and call site
   - `grep -n "rollbackInProgress" pyodide_multiplayer_game.js` shows guard flag usage

2. Integration verification:
   - Open two browser tabs to same game URL
   - In both consoles, set `window.debugRemoteInputDelay = 2`
   - Play game with both players moving - rollback messages should appear
   - Both players should see identical final game state (no divergence)
   - Complete full episode without errors

3. Stress test:
   - Set `window.debugRemoteInputDelay = 5` (aggressive delay)
   - Play rapid inputs on both clients
   - System should handle rollbacks without freezing or cascading
</verification>

<success_criteria>
1. Incoming P2P/SocketIO inputs are queued in arrays, not processed immediately
2. `_processQueuedInputs()` drains queues synchronously at frame start
3. Rollback check and execution happens BEFORE stepping current frame
4. Replay loop is batched into single Python call (no event loop yields)
5. `rollbackInProgress` guard prevents nested rollback triggers
6. Games remain visually synchronized under artificial delay testing (debugRemoteInputDelay = 2-5)
7. No inputs are lost during rollback replay
</success_criteria>

<output>
After completion, create `.planning/phases/06-ggpo-input-queue-fix/06-01-SUMMARY.md`
</output>
