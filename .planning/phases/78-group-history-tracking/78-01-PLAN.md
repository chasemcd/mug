---
phase: 78-group-history-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/matchmaker.py
  - interactive_gym/server/game_manager.py
autonomous: true

must_haves:
  truths:
    - "A custom matchmaker receives group_history on each MatchCandidate showing who was previously paired"
    - "GroupReunionMatchmaker re-pairs previous partners when both are in the waitroom"
    - "GroupReunionMatchmaker falls back to FIFO when previous partners are not available"
    - "FIFOMatchmaker and existing code paths are unaffected by the new optional field"
    - "First GymScene (no prior groups) works correctly with group_history=None on all candidates"
  artifacts:
    - path: "interactive_gym/server/matchmaker.py"
      provides: "GroupHistory dataclass, MatchCandidate.group_history field, GroupReunionMatchmaker class"
      exports: ["GroupHistory", "GroupReunionMatchmaker"]
      contains: "class GroupReunionMatchmaker"
    - path: "interactive_gym/server/game_manager.py"
      provides: "Group history population when building MatchCandidate objects"
      contains: "group_history="
  key_links:
    - from: "interactive_gym/server/game_manager.py"
      to: "interactive_gym/server/matchmaker.py"
      via: "import GroupHistory, populate group_history field on MatchCandidate"
      pattern: "from interactive_gym\\.server\\.matchmaker import.*GroupHistory"
    - from: "interactive_gym/server/game_manager.py"
      to: "interactive_gym/server/player_pairing_manager.py"
      via: "self.pairing_manager.get_group_members() and get_group_id() called when building MatchCandidate"
      pattern: "pairing_manager\\.get_group_members"
    - from: "interactive_gym/server/matchmaker.py GroupReunionMatchmaker"
      to: "MatchCandidate.group_history"
      via: "find_match() reads arriving.group_history.previous_partners to find reunion candidates"
      pattern: "arriving\\.group_history"
---

<objective>
Add group history tracking to the matchmaker API so custom matchmakers can re-pair previous partners across GymScenes.

Purpose: Completes P2P-03 (server tracks group membership queryable by matchmakers) and P2P-04 (custom matchmakers can query group history for re-pairing). The server already records groups via PlayerGroupManager.create_group() in cleanup_game(). This plan makes that data available to matchmakers by extending MatchCandidate with a group_history field and providing a GroupReunionMatchmaker implementation.

Output: Extended matchmaker.py with GroupHistory dataclass and GroupReunionMatchmaker class; updated game_manager.py that populates group_history on MatchCandidate objects during matchmaking.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/78-group-history-tracking/78-RESEARCH.md

# Key source files to read before implementation
@interactive_gym/server/matchmaker.py
@interactive_gym/server/player_pairing_manager.py
@interactive_gym/server/game_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GroupHistory dataclass, extend MatchCandidate, and implement GroupReunionMatchmaker</name>
  <files>interactive_gym/server/matchmaker.py</files>
  <action>
Extend the existing matchmaker.py with three additions:

1. **GroupHistory dataclass** (add after MatchCandidate class):
```python
@dataclass
class GroupHistory:
    """Group membership history for a participant.

    Provided to matchmakers via MatchCandidate.group_history to enable
    re-pairing decisions. Contains the most recent group information.

    Attributes:
        previous_partners: Subject IDs of other members in the most recent group
        source_scene_id: Scene where the group was last formed
        group_id: Unique identifier for the group
    """
    previous_partners: list[str]
    source_scene_id: str | None = None
    group_id: str | None = None
```

2. **Extend MatchCandidate** - Add an optional `group_history` field:
```python
@dataclass
class MatchCandidate:
    subject_id: str
    rtt_ms: int | None = None
    group_history: GroupHistory | None = None  # Phase 78: group history for re-pairing
```
Replace the `# Future: custom attributes from Phase 56` comment with the actual field. The field defaults to None so all existing code that creates MatchCandidate without group_history continues to work unchanged.

3. **GroupReunionMatchmaker class** (add after FIFOMatchmaker class):
```python
class GroupReunionMatchmaker(Matchmaker):
    """Re-pairs previous partners when possible, falls back to FIFO.

    When a participant arrives who was previously paired with someone
    (group_history is populated), this matchmaker checks if any of their
    previous partners are in the waiting list. If found, it reunites them.

    If no previous partners are waiting (or if the arriving participant
    has no group history), falls back to FIFO matching.

    This is the recommended matchmaker for multi-GymScene experiments
    where the same partners should play together across scenes.

    Example:
        from interactive_gym.server.matchmaker import GroupReunionMatchmaker

        scene_2 = (
            GymScene()
            .scene(scene_id="game_2")
            .matchmaking(matchmaker=GroupReunionMatchmaker())
        )

    Args:
        max_p2p_rtt_ms: Maximum allowed P2P RTT in ms. None disables filtering.
        fallback_to_fifo: If True (default), falls back to FIFO when no
            reunion is possible. If False, waits until previous partners arrive.
    """

    def __init__(
        self,
        max_p2p_rtt_ms: int | None = None,
        fallback_to_fifo: bool = True,
    ):
        super().__init__(max_p2p_rtt_ms=max_p2p_rtt_ms)
        self.fallback_to_fifo = fallback_to_fifo

    def find_match(
        self,
        arriving: MatchCandidate,
        waiting: list[MatchCandidate],
        group_size: int,
    ) -> list[MatchCandidate] | None:
        logger.info(
            f"[GroupReunionMatchmaker] find_match called: "
            f"arriving={arriving.subject_id}, "
            f"waiting={[w.subject_id for w in waiting]}, "
            f"group_size={group_size}, "
            f"has_group_history={arriving.group_history is not None}"
        )

        # Try reunion: check if arriving has previous partners in the waiting list
        if arriving.group_history and arriving.group_history.previous_partners:
            previous_partner_ids = set(arriving.group_history.previous_partners)
            reunited = [w for w in waiting if w.subject_id in previous_partner_ids]

            if len(reunited) + 1 >= group_size:
                matched = reunited[: group_size - 1] + [arriving]
                logger.info(
                    f"[GroupReunionMatchmaker] Reunion match! "
                    f"Returning: {[m.subject_id for m in matched]}"
                )
                return matched
            else:
                logger.info(
                    f"[GroupReunionMatchmaker] Previous partners "
                    f"{previous_partner_ids} not all in waiting list "
                    f"({[w.subject_id for w in reunited]} found). "
                    f"{'Falling back to FIFO.' if self.fallback_to_fifo else 'Waiting.'}"
                )

        # Also check: is arriving participant a previous partner of someone waiting?
        # This handles the case where the arriving participant has no group_history
        # but a waiting participant does (e.g., arriving has None because they're new,
        # but a waiting participant was previously paired with someone who dropped).
        for w in waiting:
            if (
                w.group_history
                and w.group_history.previous_partners
                and arriving.subject_id in w.group_history.previous_partners
            ):
                # The waiting participant wants to reunite with the arriving one
                if group_size == 2:
                    matched = [w, arriving]
                    logger.info(
                        f"[GroupReunionMatchmaker] Reverse reunion match! "
                        f"Waiting {w.subject_id} wanted {arriving.subject_id}. "
                        f"Returning: {[m.subject_id for m in matched]}"
                    )
                    return matched

        # Fallback to FIFO if enabled
        if self.fallback_to_fifo:
            if len(waiting) + 1 >= group_size:
                matched = waiting[: group_size - 1] + [arriving]
                logger.info(
                    f"[GroupReunionMatchmaker] FIFO fallback match. "
                    f"Returning: {[m.subject_id for m in matched]}"
                )
                return matched

        logger.info(
            f"[GroupReunionMatchmaker] No match possible. "
            f"Returning None (wait)."
        )
        return None
```

**Important details:**
- GroupHistory import: No new imports needed; uses existing `dataclass` import.
- The reverse reunion check (checking if a *waiting* participant wants to reunite with the *arriving* one) handles the case where Partner A arrives first with group_history, waits, then Partner B arrives with group_history. When B arrives, B's group_history check finds A. But also handle: if A arrived first and B arrives second, B's check finds A in waiting. The bidirectional check is important.
- `fallback_to_fifo=True` by default matches the Phase 60 design decision (warn and fall through to FIFO).
- The `find_match()` signature remains identical to the ABC -- backward compatible.
  </action>
  <verify>
Run `python -c "from interactive_gym.server.matchmaker import GroupHistory, GroupReunionMatchmaker, MatchCandidate; gh = GroupHistory(previous_partners=['a']); mc = MatchCandidate(subject_id='b', group_history=gh); print('OK:', mc)"` to confirm imports and construction work.

Run `python -c "from interactive_gym.server.matchmaker import FIFOMatchmaker, MatchCandidate; mc = MatchCandidate(subject_id='x'); fm = FIFOMatchmaker(); print('Backward compat OK:', fm.find_match(mc, [], 2))"` to confirm FIFOMatchmaker still works with no group_history.
  </verify>
  <done>
- GroupHistory dataclass exists with previous_partners, source_scene_id, group_id fields
- MatchCandidate has optional group_history field (default None)
- GroupReunionMatchmaker.find_match() returns reunion matches when previous partners are waiting, FIFO fallback when enabled, None when waiting for reunion with fallback disabled
- FIFOMatchmaker unchanged and backward compatible
- All three classes importable from interactive_gym.server.matchmaker
  </done>
</task>

<task type="auto">
  <name>Task 2: Populate group_history on MatchCandidate in GameManager</name>
  <files>interactive_gym/server/game_manager.py</files>
  <action>
Modify `GameManager._add_to_fifo_queue()` to populate `group_history` on MatchCandidate objects when `self.pairing_manager` is available.

1. **Update import** on line 43 to include GroupHistory:
```python
from interactive_gym.server.matchmaker import Matchmaker, MatchCandidate, FIFOMatchmaker, GroupHistory
```

2. **Add a helper method** `_build_match_candidate()` to GameManager (add it as a private method near `_add_to_fifo_queue`):
```python
def _build_match_candidate(self, subject_id: SubjectID) -> MatchCandidate:
    """Build a MatchCandidate with group history if available.

    Phase 78: Attaches group history from PlayerGroupManager so matchmakers
    can make re-pairing decisions.
    """
    group_history = None
    if self.pairing_manager:
        partners = self.pairing_manager.get_group_members(subject_id)
        if partners:
            group_id = self.pairing_manager.get_group_id(subject_id)
            group = self.pairing_manager.groups.get(group_id) if group_id else None
            group_history = GroupHistory(
                previous_partners=partners,
                source_scene_id=group.source_scene_id if group else None,
                group_id=group_id,
            )

    return MatchCandidate(
        subject_id=subject_id,
        rtt_ms=self.get_subject_rtt(subject_id) if self.get_subject_rtt else None,
        group_history=group_history,
    )
```

3. **Refactor `_add_to_fifo_queue()`** to use `_build_match_candidate()` instead of inline MatchCandidate construction. Replace the two MatchCandidate creation sites:

Replace lines ~465-468 (arriving candidate):
```python
# Before:
arriving = MatchCandidate(
    subject_id=subject_id,
    rtt_ms=self.get_subject_rtt(subject_id) if self.get_subject_rtt else None,
)
# After:
arriving = self._build_match_candidate(subject_id)
```

Replace lines ~481-484 (waiting candidates in the for loop):
```python
# Before:
waiting.append(MatchCandidate(
    subject_id=waiting_sid,
    rtt_ms=self.get_subject_rtt(waiting_sid) if self.get_subject_rtt else None,
))
# After:
waiting.append(self._build_match_candidate(waiting_sid))
```

4. **Update the `wait_for_known_group` warning** (~lines 318-323) to reference GroupReunionMatchmaker:
```python
if self.scene.wait_for_known_group:
    logger.warning(
        f"[GroupReunion] wait_for_known_group=True for subject {subject_id}. "
        f"Use GroupReunionMatchmaker instead: "
        f"scene.matchmaking(matchmaker=GroupReunionMatchmaker()). "
        f"Falling back to standard matching."
    )
```

**Important details:**
- `self.pairing_manager` may be None (backward compat) -- the helper checks before accessing.
- `self.pairing_manager.groups` is a ThreadSafeDict, so `.get()` is safe.
- The helper is called inside `self.waiting_games_lock` (already held in `_add_to_fifo_queue`), and `pairing_manager.get_group_members()` / `get_group_id()` do not acquire `pairing_manager.lock` (they are simple dict reads), so no deadlock risk.
- Do NOT change the `cleanup_game()` method -- it already calls `self.pairing_manager.create_group()` correctly.
  </action>
  <verify>
Run `python -c "from interactive_gym.server.game_manager import GameManager; print('Import OK')"` to confirm no import errors.

Run `grep -n 'group_history' interactive_gym/server/game_manager.py` to confirm group_history is populated in the new helper method.

Run `grep -n '_build_match_candidate' interactive_gym/server/game_manager.py` to confirm the helper is defined and called in both arriving and waiting candidate construction.
  </verify>
  <done>
- GameManager._build_match_candidate() helper exists and populates group_history from pairing_manager
- _add_to_fifo_queue() uses _build_match_candidate() for both arriving and waiting candidates
- Import of GroupHistory added to game_manager.py
- wait_for_known_group warning updated to reference GroupReunionMatchmaker
- No changes to cleanup_game() (group recording already works)
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Import check:** `python -c "from interactive_gym.server.matchmaker import GroupHistory, GroupReunionMatchmaker, MatchCandidate, FIFOMatchmaker, Matchmaker; print('All imports OK')"` -- all five classes importable.

2. **Reunion logic check:** `python -c "
from interactive_gym.server.matchmaker import GroupReunionMatchmaker, GroupHistory, MatchCandidate
m = GroupReunionMatchmaker()
# Scenario: A was paired with B before. A arrives, B is waiting.
a = MatchCandidate(subject_id='A', group_history=GroupHistory(previous_partners=['B']))
b = MatchCandidate(subject_id='B', group_history=GroupHistory(previous_partners=['A']))
result = m.find_match(a, [b], 2)
assert result is not None, 'Should match A+B'
assert set(c.subject_id for c in result) == {'A', 'B'}, f'Wrong match: {result}'
print('Reunion match OK')
# Scenario: No previous partners, falls back to FIFO
c = MatchCandidate(subject_id='C')
d = MatchCandidate(subject_id='D')
result2 = m.find_match(c, [d], 2)
assert result2 is not None, 'Should FIFO match C+D'
print('FIFO fallback OK')
# Scenario: fallback_to_fifo=False, no reunion possible
m2 = GroupReunionMatchmaker(fallback_to_fifo=False)
result3 = m2.find_match(c, [d], 2)
assert result3 is None, 'Should return None (wait for reunion)'
print('No-fallback wait OK')
print('All reunion logic checks passed')
"`

3. **Backward compatibility:** `python -c "from interactive_gym.server.matchmaker import MatchCandidate; mc = MatchCandidate(subject_id='x'); assert mc.group_history is None; print('Backward compat OK')"` -- existing code creating MatchCandidate without group_history still works.

4. **GameManager import:** `python -c "from interactive_gym.server.game_manager import GameManager; print('GameManager import OK')"` -- no circular imports or missing references.
</verification>

<success_criteria>
- P2P-03 satisfied: Server tracks group membership across scene transitions (was already recording groups; now queryable via MatchCandidate.group_history)
- P2P-04 satisfied: GroupReunionMatchmaker can query group history and re-pair previous partners
- Backward compatible: FIFOMatchmaker and all existing MatchCandidate usage unchanged
- No new dependencies: Pure Python stdlib (dataclasses)
- Researcher API: `scene.matchmaking(matchmaker=GroupReunionMatchmaker())` enables re-pairing
</success_criteria>

<output>
After completion, create `.planning/phases/78-group-history-tracking/78-01-SUMMARY.md`
</output>
