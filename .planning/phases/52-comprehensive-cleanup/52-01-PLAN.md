---
phase: 52-comprehensive-cleanup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/game_manager.py
  - interactive_gym/server/app.py
autonomous: true

must_haves:
  truths:
    - "cleanup_game() cleans subject_games and subject_rooms for all players in the game"
    - "cleanup_game() is idempotent - calling it twice does not crash"
    - "All exit paths trigger cleanup_game() for GameManager state"
    - "New participants never find stale entries in subject_games"
  artifacts:
    - path: "interactive_gym/server/game_manager.py"
      provides: "Idempotent cleanup_game() with subject-level cleanup"
      contains: "if game_id not in self.games:"
    - path: "interactive_gym/server/app.py"
      provides: "Updated exit handlers calling cleanup_game()"
      contains: "cleanup_game"
  key_links:
    - from: "cleanup_game()"
      to: "subject_games"
      via: "del self.subject_games[subject_id]"
      pattern: "del self\\.subject_games\\[subject_id\\]"
    - from: "handle_p2p_reconnection_timeout"
      to: "cleanup_game()"
      via: "game_manager.cleanup_game"
      pattern: "game_manager\\.cleanup_game"
---

<objective>
Make game cleanup comprehensive and idempotent so that all exit paths clean all state.

Purpose: Fix the root cause of stale game routing where new participants get routed to games that have ended. Currently `cleanup_game()` doesn't clean subject-level mappings (`subject_games`, `subject_rooms`), and some exit paths don't call it at all.

Output: Modified `game_manager.py` with idempotent cleanup and modified `app.py` with consistent cleanup calls on all exit paths.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-comprehensive-cleanup/52-RESEARCH.md
@.planning/phases/51-diagnostic-logging/51-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Make cleanup_game() idempotent and comprehensive</name>
  <files>interactive_gym/server/game_manager.py</files>
  <action>
Modify `cleanup_game()` method to:

1. **Make idempotent** - Add early return if game_id not in self.games:
```python
def cleanup_game(self, game_id: GameID):
    """End a game and clean up ALL associated state.

    Idempotent: safe to call multiple times for the same game_id.
    """
    # Guard: make idempotent
    if game_id not in self.games:
        logger.debug(f"cleanup_game called for already-cleaned game {game_id}")
        return
```

2. **Clean subject-level mappings** - Before calling `_remove_game()`, iterate over all human players and clean their entries from subject_games and subject_rooms:
```python
    game = self.games[game_id]

    # Clean up subject tracking for ALL players in this game
    for subject_id in list(game.human_players.values()):
        if subject_id and subject_id != utils.Available:
            if subject_id in self.subject_games:
                del self.subject_games[subject_id]
            if subject_id in self.subject_rooms:
                del self.subject_rooms[subject_id]
            logger.debug(f"Cleaned subject mappings for {subject_id}")
```

3. **Keep existing logic** - After the new cleanup, continue with the existing pairing_manager, callback, tear_down, and _remove_game() logic.

The full method should be:
- Check if game_id in self.games (early return if not)
- Get game object
- Clean subject_games and subject_rooms for all players
- Record player groups if pairing_manager exists
- Call on_game_end callback if exists
- Call game.tear_down()
- Call _remove_game(game_id)
  </action>
  <verify>
Run: `grep -A 20 "def cleanup_game" interactive_gym/server/game_manager.py` and confirm:
1. Method starts with idempotent guard (if game_id not in self.games: return)
2. Method cleans subject_games entries for all human players
3. Method cleans subject_rooms entries for all human players
  </verify>
  <done>
cleanup_game() is idempotent and cleans subject_games and subject_rooms for all players in the game before calling _remove_game().
  </done>
</task>

<task type="auto">
  <name>Task 2: Ensure all exit paths call cleanup_game()</name>
  <files>interactive_gym/server/app.py</files>
  <action>
Review and update exit paths in app.py to ensure GameManager.cleanup_game() is called:

**1. handle_p2p_reconnection_timeout (line ~2032):**
Currently calls PYODIDE_COORDINATOR cleanup but NOT GameManager.cleanup_game(). Add:
```python
# After PYODIDE_COORDINATOR.remove_game(game_id):
# Clean up GameManager state for both players
for scene_id, game_manager in GAME_MANAGERS.items():
    if game_id in game_manager.games:
        game_manager.cleanup_game(game_id)
        logger.info(f"Cleaned up GameManager state for game {game_id}")
        break
```

**2. handle_p2p_validation_failed (line ~1925):**
Currently manually deletes subject_games entries but doesn't call cleanup_game(). Replace the manual cleanup with:
```python
# After PYODIDE_COORDINATOR.remove_game(game_id):
for scene_id, game_manager in GAME_MANAGERS.items():
    if game_id in game_manager.games:
        game_manager.cleanup_game(game_id)
        logger.info(f"Cleaned up GameManager state for failed P2P validation game {game_id}")
        break
```
Remove the existing manual del subject_games[subject_id] loop since cleanup_game() now handles it.

**3. handle_player_exclusion in pyodide_game_coordinator.py:**
This is called from app.py via mid_game_exclusion handler. After PYODIDE_COORDINATOR.handle_player_exclusion(), add GameManager cleanup:
Find the mid_game_exclusion handler (grep for "@socketio.on.*mid_game_exclusion") and ensure it calls cleanup_game() after the coordinator cleanup.

**4. on_disconnect handler (line ~2463):**
Currently splits between leave_game() (which calls cleanup_game) and remove_subject_quietly() (which does NOT call cleanup_game for non-empty games).

Update remove_subject_quietly() result handling: if there are no players left in the game after removing this subject, cleanup_game() should be called. Check the return value and add cleanup:
```python
# In on_disconnect, after remove_subject_quietly():
# Check if game became empty and needs full cleanup
game_id = game_manager.subject_games.get(subject_id)
if game_id and game_id in game_manager.games:
    game = game_manager.games.get(game_id)
    if game and game.cur_num_human_players() == 0:
        game_manager.cleanup_game(game_id)
```
Wait - actually remove_subject_quietly already handles this with tear_down and _remove_game. The issue is it does this BEFORE deleting subject_games. Check if the order is correct in remove_subject_quietly(). Actually the issue is that cleanup_game() wasn't being called at all - the fix in Task 1 makes cleanup_game() clean subject mappings, so now we just need to ensure cleanup_game() is called. But remove_subject_quietly uses _remove_game directly...

Actually, looking more carefully: remove_subject_quietly() already deletes subject_games/subject_rooms entries AND calls _remove_game() if game is empty. So it's doing proper cleanup. The missing cases are the Pyodide coordinator paths. Focus on those:

Final list of changes:
1. handle_p2p_reconnection_timeout: Add GameManager.cleanup_game() call after coordinator cleanup
2. handle_p2p_validation_failed: Replace manual subject cleanup with cleanup_game() call
3. handle_player_exclusion (in app.py mid_game_exclusion handler): Add cleanup_game() call
  </action>
  <verify>
Run these checks:
1. `grep -n "cleanup_game" interactive_gym/server/app.py | wc -l` - should show increased usage
2. `grep -A 15 "def handle_p2p_reconnection_timeout" interactive_gym/server/app.py` - should show cleanup_game call
3. `grep -A 15 "def handle_p2p_validation_failed" interactive_gym/server/app.py` - should show cleanup_game call, not manual del subject_games
4. Run existing tests: `python -m pytest tests/e2e/test_infrastructure.py -v` to ensure no regressions
  </verify>
  <done>
All exit paths (normal completion, partner disconnect, validation failure, reconnection timeout, mid-game exclusion) trigger GameManager.cleanup_game() to clean subject_games, subject_rooms, and game-level structures.
  </done>
</task>

</tasks>

<verification>
After completing both tasks:

1. **Idempotent test:** The following should not crash:
   - Call cleanup_game("nonexistent-id") - should log and return
   - Call cleanup_game(valid_id) twice - second call should log and return

2. **State cleanup verification:**
   - Start a multiplayer game
   - End it via any exit path (disconnect, timeout, completion)
   - Verify subject_games and subject_rooms are empty for those subjects
   - New join attempt should NOT find stale entries

3. **All tests pass:**
   - `python -m pytest tests/e2e/ -v --headed` should pass all 17 tests
</verification>

<success_criteria>
1. cleanup_game() has idempotent guard (early return if game_id not in games)
2. cleanup_game() deletes subject_games[subject_id] for all players
3. cleanup_game() deletes subject_rooms[subject_id] for all players
4. handle_p2p_reconnection_timeout calls cleanup_game()
5. handle_p2p_validation_failed calls cleanup_game() instead of manual deletion
6. All E2E tests pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/52-comprehensive-cleanup/52-01-SUMMARY.md`
</output>
