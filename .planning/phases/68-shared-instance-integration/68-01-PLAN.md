---
phase: 68-shared-instance-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/static/js/pyodide_remote_game.js
autonomous: true

must_haves:
  truths:
    - "RemoteGame.initialize() reuses window.pyodideInstance when pyodidePreloadStatus is 'ready'"
    - "RemoteGame.initialize() falls back to loadPyodide() when preload did not happen or failed"
    - "MultiplayerPyodideGame inherits the shared instance behavior via super.initialize()"
    - "Game startup skips WASM compilation when Pyodide was pre-loaded"
    - "Packages already installed during preload are not re-installed"
  artifacts:
    - path: "interactive_gym/server/static/js/pyodide_remote_game.js"
      provides: "Modified RemoteGame.initialize() with preload reuse"
      contains: "window.pyodideInstance"
  key_links:
    - from: "interactive_gym/server/static/js/pyodide_remote_game.js"
      to: "window.pyodideInstance"
      via: "conditional check in initialize()"
      pattern: "window\\.pyodidePreloadStatus.*===.*'ready'"
    - from: "interactive_gym/server/static/js/pyodide_remote_game.js"
      to: "window.pyodideInstalledPackages"
      via: "package dedup in initialize()"
      pattern: "window\\.pyodideInstalledPackages"
---

<objective>
Modify RemoteGame.initialize() to reuse the pre-loaded Pyodide instance (window.pyodideInstance)
from Phase 67 instead of calling loadPyodide() every time a game starts.

Purpose: Eliminate the 5-15 second WASM compilation delay at game startup when Pyodide was
already pre-loaded during the compatibility check screen. This satisfies SHARED-01 and SHARED-02.

Output: Modified pyodide_remote_game.js where initialize() checks for existing Pyodide instance
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/67-pyodide-preload-infrastructure/67-01-SUMMARY.md
@interactive_gym/server/static/js/pyodide_remote_game.js
@interactive_gym/server/static/js/index.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Modify RemoteGame.initialize() to reuse pre-loaded Pyodide</name>
  <files>interactive_gym/server/static/js/pyodide_remote_game.js</files>
  <action>
Modify the `initialize()` method (currently lines 48-80) in the `RemoteGame` class to check for
a pre-loaded Pyodide instance before calling `loadPyodide()`.

The modified initialize() should follow this logic:

1. **Check for pre-loaded instance first:**
   - If `window.pyodidePreloadStatus === 'ready'` AND `window.pyodideInstance` is truthy:
     - Set `this.pyodide = window.pyodideInstance`
     - Set `this.micropip = window.pyodideMicropip`
     - Copy `window.pyodideInstalledPackages` into `this.installed_packages`
     - Log: `console.log('[RemoteGame] Reusing pre-loaded Pyodide instance')`
   - Otherwise (fallback path -- preload didn't happen, failed, or still loading):
     - Run the existing code: `this.pyodide = await loadPyodide()`, then
       `await this.pyodide.loadPackage("micropip")`, then
       `this.micropip = this.pyodide.pyimport("micropip")`
     - Log: `console.log('[RemoteGame] Loading Pyodide fresh (no preload available)')`

2. **Install only NEW packages not already installed:**
   - After the above branch, check `this.config.packages_to_install`
   - Filter out any packages already in `this.installed_packages`
   - Only call `await this.micropip.install(newPackages)` for packages not yet installed
   - Append newly installed packages to `this.installed_packages`
   - This handles the case where preload installed some packages but the game scene
     needs additional ones

3. **Keep the rest of initialize() unchanged:**
   - `this.pyodide.globals.set(...)` line stays the same
   - The `runPythonAsync(...)` environment init code stays the same
   - Setting `this.state = "ready"` and `this.pyodideReady = true` stays the same

**Important:** Do NOT modify the `MultiplayerPyodideGame.initialize()` method. It calls
`await super.initialize()` which will automatically get the new behavior. Do NOT modify
`reinitialize_environment()` either -- it already has its own package dedup logic and reuses
the existing pyodide instance.

**Why this approach:** The preload (Phase 67) stored the Pyodide instance, micropip reference,
and installed packages on window globals specifically for this consumption pattern. The fallback
path preserves backward compatibility when preload didn't happen (e.g., non-Pyodide experiments
that later navigate to a Pyodide scene, or preload failure with status='error').
  </action>
  <verify>
1. Read the modified file and confirm:
   - `window.pyodidePreloadStatus === 'ready'` check exists in initialize()
   - `window.pyodideInstance` assignment to `this.pyodide` exists
   - `window.pyodideMicropip` assignment to `this.micropip` exists
   - `window.pyodideInstalledPackages` copied to `this.installed_packages`
   - Fallback path with `loadPyodide()` still exists in else branch
   - Package dedup logic filters already-installed packages
   - No changes to MultiplayerPyodideGame.initialize()
   - No changes to reinitialize_environment()

2. Grep for `loadPyodide()` in pyodide_remote_game.js - should appear exactly once (in the fallback branch)

3. Grep for `window.pyodideInstance` in pyodide_remote_game.js - should appear (in the reuse branch)
  </verify>
  <done>
RemoteGame.initialize() reuses window.pyodideInstance when preload succeeded, falls back
to fresh loadPyodide() otherwise. Package installation is deduplicated against already-installed
packages from preload. MultiplayerPyodideGame inherits this behavior via super.initialize().
  </done>
</task>

<task type="auto">
  <name>Task 2: Add console logging to confirm shared instance path in multiplayer</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Add a single console.log line at the start of `MultiplayerPyodideGame.initialize()` (currently
at line 1736) to make it observable which initialization path was taken. This helps with
debugging and verifying Phase 68 is working correctly.

Before `await super.initialize();` add:
```javascript
console.log('[MultiplayerPyodideGame] Initializing...',
    window.pyodidePreloadStatus === 'ready' ? '(will reuse pre-loaded Pyodide)' : '(will load Pyodide fresh)');
```

Do NOT change any other code in this file. The entire benefit comes from the RemoteGame change
in Task 1 -- this task just adds observability.
  </action>
  <verify>
1. Read MultiplayerPyodideGame.initialize() and confirm:
   - The console.log line is present before `await super.initialize()`
   - No other changes were made to the file
   - The `await super.initialize()` call is unchanged

2. Grep for 'will reuse pre-loaded Pyodide' in pyodide_multiplayer_game.js - should appear once
  </verify>
  <done>
MultiplayerPyodideGame.initialize() logs which Pyodide initialization path will be used,
providing observability for debugging without changing any behavior.
  </done>
</task>

</tasks>

<verification>
1. `window.pyodidePreloadStatus === 'ready'` check exists in RemoteGame.initialize()
2. Fallback `loadPyodide()` path preserved for when preload is unavailable
3. Package dedup prevents reinstalling packages already loaded during preload
4. MultiplayerPyodideGame inherits shared instance via super.initialize() (no direct changes needed)
5. No regressions to reinitialize_environment() (untouched)
6. Console logging provides clear indication of which path was taken
</verification>

<success_criteria>
- SHARED-01: RemoteGame.initialize() checks window.pyodidePreloadStatus and reuses window.pyodideInstance when 'ready'
- SHARED-02: MultiplayerPyodideGame.initialize() calls super.initialize() which inherits the reuse behavior
- Fallback: When preload didn't happen (status != 'ready'), the original loadPyodide() path executes
- Package dedup: Packages installed during preload are not reinstalled at game time
- No changes to existing game loop, step(), reset(), or reinitialize_environment() methods
</success_criteria>

<output>
After completion, create `.planning/phases/68-shared-instance-integration/68-01-SUMMARY.md`
</output>
