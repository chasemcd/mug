---
phase: 34-session-detail
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/admin/static/admin.js
  - interactive_gym/server/admin/static/admin.css
  - interactive_gym/server/admin/templates/dashboard.html
  - interactive_gym/server/admin/aggregator.py
autonomous: true

must_haves:
  truths:
    - "Clicking a session card opens a detail panel"
    - "Detail panel shows session info (game_id, players, episode, connection type, latency)"
    - "Detail panel shows termination reason if session ended abnormally"
    - "Detail panel shows console errors from session participants"
    - "Detail panel can be closed to return to session list"
  artifacts:
    - path: "interactive_gym/server/admin/static/admin.js"
      provides: "Session detail panel open/close, data rendering, console log filtering"
      contains: "showSessionDetail"
    - path: "interactive_gym/server/admin/static/admin.css"
      provides: "Session detail panel styling"
      contains: "session-detail"
    - path: "interactive_gym/server/admin/templates/dashboard.html"
      provides: "Session detail panel container element"
      contains: "session-detail-panel"
    - path: "interactive_gym/server/admin/aggregator.py"
      provides: "Session termination tracking with reason storage"
      contains: "_session_terminations"
  key_links:
    - from: "interactive_gym/server/admin/static/admin.js"
      to: "renderSessionCard click handler"
      via: "onclick attribute calling showSessionDetail(gameId)"
      pattern: "onclick.*showSessionDetail"
    - from: "interactive_gym/server/admin/static/admin.js"
      to: "consoleLogs array"
      via: "filtering by player subject_ids"
      pattern: "filter.*subject_id"
---

<objective>
Add a session detail view that opens when clicking a session card, showing diagnostic information including exclusion/disconnection reasons and console errors from session participants.

Purpose: Enable researchers to quickly diagnose session issues by clicking on active or problem sessions to see detailed information including why a session ended abnormally and any console errors from participants.

Output: Session detail panel with termination reason display and participant-filtered console errors.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-session-list/33-01-SUMMARY.md
@interactive_gym/server/admin/aggregator.py
@interactive_gym/server/admin/static/admin.js
@interactive_gym/server/admin/static/admin.css
@interactive_gym/server/admin/templates/dashboard.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add session termination tracking to aggregator</name>
  <files>interactive_gym/server/admin/aggregator.py</files>
  <action>
Add session termination tracking to AdminEventAggregator:

1. Add new instance variable in __init__:
   ```python
   # Session termination tracking (Phase 34)
   # Maps game_id -> {reason: str, timestamp: float, players: list[str], details: dict}
   self._session_terminations: dict[str, dict] = {}
   ```

2. Add method to record session termination:
   ```python
   def record_session_termination(
       self,
       game_id: str,
       reason: str,
       players: list[str],
       details: dict | None = None
   ) -> None:
       """
       Record session termination with reason for detail view.

       Args:
           game_id: The game ID
           reason: Termination reason (partner_disconnected, focus_loss_timeout,
                   sustained_ping, tab_hidden, exclusion, normal)
           players: List of player subject IDs
           details: Optional additional details (exclusion message, etc.)
       """
       self._session_terminations[game_id] = {
           'reason': reason,
           'timestamp': time.time(),
           'players': players,
           'details': details or {}
       }
       logger.debug(f"Session termination recorded for {game_id}: {reason}")
   ```

3. Add method to get session detail:
   ```python
   def get_session_detail(self, game_id: str) -> dict | None:
       """
       Get detailed information for a specific session.

       Args:
           game_id: The game ID

       Returns:
           Dict with session info, termination reason, and player console logs
       """
       # Get active game state if still running
       game_state = None
       if self.pyodide_coordinator and game_id in self.pyodide_coordinator.games:
           game = self.pyodide_coordinator.games[game_id]
           p2p_health = self._get_p2p_health_for_game(game_id)
           game_state = {
               'game_id': game_id,
               'players': list(game.players.keys()),
               'host_id': game.host_id,
               'is_server_authoritative': game.server_authoritative,
               'created_at': getattr(game, 'created_at', None),
               'p2p_health': p2p_health,
               'session_health': self._compute_session_health(p2p_health)
           }

       # Get termination info if session ended
       termination = self._session_terminations.get(game_id)

       # Get player list from game_state or termination
       players = []
       if game_state:
           players = game_state['players']
       elif termination:
           players = termination.get('players', [])

       # Filter console logs for these players (last 50 per player, errors prioritized)
       player_logs = []
       for log in list(self._console_logs):
           if log.get('subject_id') in players:
               player_logs.append(log)

       # Sort by timestamp descending, prioritize errors
       player_logs.sort(key=lambda x: (
           0 if x.get('level') == 'error' else 1,
           -x.get('timestamp', 0)
       ))
       player_logs = player_logs[:100]  # Limit to 100 logs

       return {
           'game_state': game_state,
           'termination': termination,
           'player_logs': player_logs
       }
   ```

4. Modify _get_multiplayer_games_state to include termination info for recently ended games:
   In the return dict, add after 'current_episode':
   ```python
   'termination': self._session_terminations.get(game_id)
   ```
  </action>
  <verify>
Run Python syntax check:
```bash
python -m py_compile interactive_gym/server/admin/aggregator.py
```
Should complete with no errors.
  </verify>
  <done>
AdminEventAggregator has _session_terminations dict, record_session_termination() method, get_session_detail() method, and multiplayer_games state includes termination info.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add session detail UI panel and interactivity</name>
  <files>interactive_gym/server/admin/templates/dashboard.html, interactive_gym/server/admin/static/admin.js, interactive_gym/server/admin/static/admin.css</files>
  <action>
**In dashboard.html:**

Add session detail panel container before the closing `</div>` of `min-h-screen bg-base-200`:

```html
<!-- Session Detail Panel (Phase 34) -->
<div id="session-detail-overlay" class="session-detail-overlay hidden">
    <div class="session-detail-panel">
        <div class="session-detail-header">
            <h3 class="text-lg font-semibold">Session Details</h3>
            <button onclick="closeSessionDetail()" class="btn btn-ghost btn-sm btn-circle">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
        <div id="session-detail-content" class="session-detail-content">
            <!-- Content populated by JS -->
        </div>
    </div>
</div>
```

**In admin.js:**

1. Add state tracking at top (after `let logParticipantFilter = 'all';`):
```javascript
// Session detail state
let selectedSessionId = null;
```

2. Add showSessionDetail function (before utility functions section):
```javascript
// ============================================
// Session Detail Panel (Phase 34)
// ============================================

function showSessionDetail(gameId) {
    selectedSessionId = gameId;
    const overlay = document.getElementById('session-detail-overlay');
    const content = document.getElementById('session-detail-content');

    if (!overlay || !content) return;

    // Find session in current state
    const session = currentState.multiplayer_games?.find(g => g.game_id === gameId);

    if (!session) {
        content.innerHTML = '<div class="empty-state-sm"><p>Session not found</p></div>';
        overlay.classList.remove('hidden');
        return;
    }

    // Render session detail
    content.innerHTML = renderSessionDetailContent(session);
    overlay.classList.remove('hidden');
}

function closeSessionDetail() {
    selectedSessionId = null;
    const overlay = document.getElementById('session-detail-overlay');
    if (overlay) {
        overlay.classList.add('hidden');
    }
}

function renderSessionDetailContent(session) {
    const health = session.session_health || 'healthy';
    const p2pHealth = session.p2p_health || {};
    const termination = session.termination;

    // Get connection info from first player
    const firstPlayerHealth = Object.values(p2pHealth)[0] || {};
    const connectionType = getConnectionTypeLabel(firstPlayerHealth.connection_type || 'unknown');

    // Calculate latency
    const latencies = Object.values(p2pHealth).map(h => h.latency_ms).filter(l => l != null);
    const avgLatency = latencies.length > 0
        ? Math.round(latencies.reduce((a,b) => a+b, 0) / latencies.length)
        : null;

    // Get console errors for this session's players
    const playerIds = session.players || [];
    const playerErrors = consoleLogs.filter(log =>
        playerIds.includes(log.subject_id) &&
        (log.level === 'error' || log.level === 'warn')
    ).slice(0, 20);

    return `
        <div class="session-detail-section">
            <h4 class="session-detail-section-title">Session Info</h4>
            <div class="session-detail-grid">
                <div class="session-detail-item">
                    <span class="session-detail-label">Game ID</span>
                    <span class="session-detail-value font-mono text-sm">${escapeHtml(session.game_id)}</span>
                </div>
                <div class="session-detail-item">
                    <span class="session-detail-label">Status</span>
                    <span class="session-detail-value session-status-${health}">
                        <span class="health-indicator health-${health}"></span>
                        ${health.charAt(0).toUpperCase() + health.slice(1)}
                    </span>
                </div>
                <div class="session-detail-item">
                    <span class="session-detail-label">Connection</span>
                    <span class="session-detail-value">${connectionType}</span>
                </div>
                <div class="session-detail-item">
                    <span class="session-detail-label">Latency</span>
                    <span class="session-detail-value ${avgLatency && avgLatency > 150 ? 'text-warning' : ''}">
                        ${avgLatency != null ? avgLatency + 'ms' : '--'}
                    </span>
                </div>
                <div class="session-detail-item">
                    <span class="session-detail-label">Episode</span>
                    <span class="session-detail-value">${session.current_episode ?? '--'}</span>
                </div>
                <div class="session-detail-item">
                    <span class="session-detail-label">Mode</span>
                    <span class="session-detail-value">${session.is_server_authoritative ? 'Server Auth' : 'P2P'}</span>
                </div>
            </div>
        </div>

        <div class="session-detail-section">
            <h4 class="session-detail-section-title">Players</h4>
            <div class="session-detail-players">
                ${playerIds.map(player => `
                    <div class="session-detail-player ${player === session.host_id ? 'host' : ''}">
                        <span class="player-id">${escapeHtml(player)}</span>
                        ${player === session.host_id ? '<span class="host-badge">Host</span>' : ''}
                        ${renderPlayerHealth(p2pHealth[player])}
                    </div>
                `).join('')}
            </div>
        </div>

        ${termination ? `
        <div class="session-detail-section session-termination">
            <h4 class="session-detail-section-title">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z" />
                </svg>
                Termination
            </h4>
            <div class="termination-info">
                <div class="termination-reason">${getTerminationReasonLabel(termination.reason)}</div>
                ${termination.details?.message ? `
                    <div class="termination-message">${escapeHtml(termination.details.message)}</div>
                ` : ''}
                <div class="termination-time">Ended: ${formatTime(termination.timestamp)}</div>
            </div>
        </div>
        ` : ''}

        <div class="session-detail-section">
            <h4 class="session-detail-section-title">
                Console Errors & Warnings
                <span class="badge badge-ghost badge-xs">${playerErrors.length}</span>
            </h4>
            ${playerErrors.length > 0 ? `
                <div class="session-detail-logs">
                    ${playerErrors.map(log => `
                        <div class="log-entry log-${log.level}">
                            <span class="log-time">${formatTime(log.timestamp)}</span>
                            <span class="log-level log-level-${log.level}">${log.level.toUpperCase()}</span>
                            <span class="log-subject">${escapeHtml(truncateId(log.subject_id))}</span>
                            <span class="log-message">${escapeHtml(log.message)}</span>
                        </div>
                    `).join('')}
                </div>
            ` : `
                <div class="empty-state-sm">
                    <p class="text-base-content/50 text-sm">No errors or warnings</p>
                </div>
            `}
        </div>
    `;
}

function renderPlayerHealth(health) {
    if (!health) return '<span class="player-health-unknown">No data</span>';

    const status = health.status || 'unknown';
    const latency = health.latency_ms;
    const connType = health.connection_type;

    return `
        <span class="player-health player-health-${status}">
            ${latency != null ? latency + 'ms' : '--'}
            (${getConnectionTypeLabel(connType)})
        </span>
    `;
}

function getTerminationReasonLabel(reason) {
    const labels = {
        'partner_disconnected': 'Partner Disconnected',
        'focus_loss_timeout': 'Focus Loss Timeout',
        'sustained_ping': 'High Latency (Sustained)',
        'tab_hidden': 'Tab Hidden Too Long',
        'exclusion': 'Participant Excluded',
        'custom_callback': 'Custom Exclusion Rule',
        'normal': 'Normal Completion'
    };
    return labels[reason] || reason || 'Unknown';
}
```

3. Modify renderSessionCard to add click handler:
   Change the opening div from:
   ```javascript
   <div class="session-card ${hasProblem ? 'session-problem' : ''}">
   ```
   To:
   ```javascript
   <div class="session-card ${hasProblem ? 'session-problem' : ''}" onclick="showSessionDetail('${escapeHtml(game.game_id)}')" role="button" tabindex="0">
   ```

4. Update the detail panel when state updates (add to updateDashboard function, after updateSessionList call):
```javascript
    // Update session detail panel if open
    if (selectedSessionId) {
        const session = state.multiplayer_games?.find(g => g.game_id === selectedSessionId);
        if (session) {
            const content = document.getElementById('session-detail-content');
            if (content) {
                content.innerHTML = renderSessionDetailContent(session);
            }
        }
    }
```

**In admin.css:**

Add styles for session detail panel (at end of file):

```css
/* ============================================
   Session Detail Panel (Phase 34)
   ============================================ */

.session-detail-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.5);
    z-index: 100;
    display: flex;
    justify-content: flex-end;
    backdrop-filter: blur(2px);
}

.session-detail-overlay.hidden {
    display: none;
}

.session-detail-panel {
    width: 100%;
    max-width: 480px;
    height: 100%;
    background: oklch(var(--b1));
    box-shadow: -4px 0 20px rgba(0, 0, 0, 0.15);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.session-detail-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem 1.25rem;
    border-bottom: 1px solid oklch(var(--b3));
    flex-shrink: 0;
}

.session-detail-content {
    flex: 1;
    overflow-y: auto;
    padding: 1rem 1.25rem;
}

.session-detail-section {
    margin-bottom: 1.5rem;
}

.session-detail-section:last-child {
    margin-bottom: 0;
}

.session-detail-section-title {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: oklch(var(--bc) / 0.6);
    margin-bottom: 0.75rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid oklch(var(--b3));
}

.session-detail-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 0.75rem;
}

.session-detail-item {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
}

.session-detail-label {
    font-size: 0.6875rem;
    color: oklch(var(--bc) / 0.5);
    text-transform: uppercase;
}

.session-detail-value {
    font-size: 0.875rem;
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: 0.375rem;
}

.session-detail-players {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.session-detail-player {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.625rem 0.75rem;
    background: oklch(var(--b2));
    border-radius: 0.375rem;
    font-size: 0.8125rem;
}

.session-detail-player.host {
    background: oklch(var(--p) / 0.1);
}

.session-detail-player .player-id {
    font-family: ui-monospace, monospace;
    font-weight: 500;
}

.player-health {
    font-size: 0.75rem;
    color: oklch(var(--bc) / 0.6);
}

.player-health-healthy { color: oklch(var(--su)); }
.player-health-degraded { color: oklch(var(--wa)); }
.player-health-reconnecting { color: oklch(var(--er)); }
.player-health-unknown { color: oklch(var(--bc) / 0.4); }

/* Termination section */
.session-termination {
    background: oklch(var(--er) / 0.08);
    border-radius: 0.5rem;
    padding: 0.875rem;
    margin-left: -0.5rem;
    margin-right: -0.5rem;
}

.session-termination .session-detail-section-title {
    color: oklch(var(--er));
    border-bottom-color: oklch(var(--er) / 0.2);
}

.termination-info {
    display: flex;
    flex-direction: column;
    gap: 0.375rem;
}

.termination-reason {
    font-weight: 600;
    color: oklch(var(--er));
}

.termination-message {
    font-size: 0.8125rem;
    color: oklch(var(--bc) / 0.7);
    padding: 0.5rem;
    background: oklch(var(--b1));
    border-radius: 0.25rem;
}

.termination-time {
    font-size: 0.75rem;
    color: oklch(var(--bc) / 0.5);
}

/* Session detail logs */
.session-detail-logs {
    max-height: 250px;
    overflow-y: auto;
    background: oklch(var(--b2));
    border-radius: 0.375rem;
}

.session-detail-logs .log-entry {
    font-size: 0.6875rem;
}

/* Make session cards clickable */
.session-card {
    cursor: pointer;
    transition: border-color 0.15s ease, box-shadow 0.15s ease;
}

.session-card:hover {
    border-color: oklch(var(--p) / 0.5);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.session-card:focus {
    outline: 2px solid oklch(var(--p));
    outline-offset: 2px;
}

/* Responsive: full-screen panel on mobile */
@media (max-width: 640px) {
    .session-detail-panel {
        max-width: 100%;
    }
}
```
  </action>
  <verify>
1. Check HTML syntax:
```bash
grep -c "session-detail-overlay" interactive_gym/server/admin/templates/dashboard.html
```
Should return 1 (the new overlay element).

2. Check JS syntax:
```bash
node --check interactive_gym/server/admin/static/admin.js 2>&1 || echo "Syntax error"
```
Should complete without error.

3. Check CSS has new styles:
```bash
grep -c "session-detail-panel" interactive_gym/server/admin/static/admin.css
```
Should return at least 1.
  </verify>
  <done>
Session detail panel appears when clicking a session card, showing session info grid, player list with individual health, termination section (if applicable), and filtered console errors/warnings from session participants.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire up termination recording in server events</name>
  <files>interactive_gym/server/app.py</files>
  <action>
Add termination recording calls to existing game end handlers in app.py.

1. Find the existing `p2p_game_ended` handler and add termination recording.

Search for `@socketio.on('p2p_game_ended')` or similar game end handler.

Add after the handler processes the game end:
```python
# Record termination for admin dashboard (Phase 34)
if ADMIN_AGGREGATOR:
    termination_reason = data.get('termination_reason', 'normal')
    ADMIN_AGGREGATOR.record_session_termination(
        game_id=game_id,
        reason=termination_reason,
        players=list(game.players.keys()) if game else [],
        details={'message': data.get('termination_message')}
    )
```

2. Find the player exclusion handling (likely in `handle_exclusion` or similar) and add:
```python
# Record exclusion termination (Phase 34)
if ADMIN_AGGREGATOR and game_id:
    ADMIN_AGGREGATOR.record_session_termination(
        game_id=game_id,
        reason='exclusion',
        players=[subject_id],  # or list of game players
        details={'message': exclusion_message, 'excluded_player': subject_id}
    )
```

Note: The exact integration depends on how game termination events are currently handled. Look for:
- `p2p_game_ended` SocketIO handler
- `trigger_data_export` SocketIO handler
- Any exclusion notification handlers from Phase 17

The key is to call `ADMIN_AGGREGATOR.record_session_termination()` whenever a game ends for any reason, passing the appropriate reason string.
  </action>
  <verify>
```bash
python -m py_compile interactive_gym/server/app.py
```
Should complete without errors.

```bash
grep -c "record_session_termination" interactive_gym/server/app.py
```
Should return at least 1 (termination recording is wired up).
  </verify>
  <done>
Server events record session terminations with reason codes to AdminEventAggregator when games end due to disconnection, exclusion, focus loss, or normal completion.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Start the server and open admin dashboard
2. If there are active sessions, click on a session card
3. Verify detail panel slides in from the right
4. Verify session info section shows game ID, status, connection type, latency, episode, mode
5. Verify players section shows each player with their health status
6. If session has ended abnormally, verify termination section appears with reason
7. Verify console errors/warnings section shows logs filtered to session participants
8. Click close button or click outside panel to close
9. Verify clicking different sessions updates the detail view
</verification>

<success_criteria>
- [ ] Clicking a session card opens detail panel (DETAIL-01)
- [ ] Detail panel shows session info (game ID, players, episode, connection, latency)
- [ ] Termination reason displayed if session ended abnormally (DETAIL-02, DETAIL-03)
- [ ] Console errors from session participants are filtered and displayed (DETAIL-04)
- [ ] Panel can be closed and reopened
- [ ] Panel updates in real-time when session state changes
</success_criteria>

<output>
After completion, create `.planning/phases/34-session-detail/34-01-SUMMARY.md`
</output>
