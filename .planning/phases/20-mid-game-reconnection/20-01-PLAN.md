---
phase: 20-mid-game-reconnection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/static/js/pyodide_multiplayer_game.js
  - interactive_gym/server/static/js/webrtc_manager.js
  - interactive_gym/server/pyodide_game_coordinator.py
  - interactive_gym/server/app.py
autonomous: true

must_haves:
  truths:
    - "Connection drop detected within 3 seconds of actual disconnection"
    - "Both clients pause simultaneously when either detects disconnection"
    - "Server tracks which game is in reconnection state"
    - "Pause is coordinated via SocketIO (works when P2P is down)"
  artifacts:
    - path: "interactive_gym/server/static/js/pyodide_multiplayer_game.js"
      provides: "Reconnection state machine and pause handling"
      contains: "reconnectionState"
    - path: "interactive_gym/server/static/js/webrtc_manager.js"
      provides: "Connection lost callbacks"
      contains: "onConnectionLost"
    - path: "interactive_gym/server/pyodide_game_coordinator.py"
      provides: "Server-side reconnection tracking"
      contains: "reconnection_in_progress"
    - path: "interactive_gym/server/app.py"
      provides: "Socket handlers for pause coordination"
      contains: "p2p_connection_lost"
  key_links:
    - from: "webrtc_manager.js"
      to: "pyodide_multiplayer_game.js"
      via: "onConnectionLost callback"
      pattern: "this\\.onConnectionLost\\?\\."
    - from: "pyodide_multiplayer_game.js"
      to: "app.py"
      via: "socket.emit p2p_connection_lost"
      pattern: "socket\\.emit.*p2p_connection_lost"
    - from: "app.py"
      to: "pyodide_game_coordinator.py"
      via: "handle_connection_lost method"
      pattern: "PYODIDE_COORDINATOR\\.handle_connection_lost"
---

<objective>
Add connection drop detection and bilateral pause coordination for mid-game P2P disconnection handling.

Purpose: Enable graceful handling of P2P connection drops during gameplay by detecting disconnection via ICE/DataChannel state, coordinating pause across both clients via server, and tracking reconnection state.

Output: Detection callbacks, reconnection state machine, server coordination, pause protocol
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-mid-game-reconnection/20-RESEARCH.md
@.planning/phases/19-waiting-room-validation/19-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add connection drop detection callbacks to WebRTCManager</name>
  <files>interactive_gym/server/static/js/webrtc_manager.js</files>
  <action>
Enhance WebRTCManager to detect connection drops and invoke callbacks:

1. Add new callback properties after existing callbacks (~line 195):
```javascript
// Connection drop callbacks (Phase 20)
this.onConnectionLost = null;       // Called on disconnect detected (after grace period)
this.onConnectionRestored = null;   // Called if connection self-recovers
```

2. Add grace period configuration (~line 186):
```javascript
this.disconnectGracePeriodMs = 3000;  // 3 second grace before declaring lost
this.disconnectGraceId = null;        // Grace period timeout handle
```

3. Modify `oniceconnectionstatechange` handler (~line 324) to use new callbacks:
   - On 'disconnected': Start grace period timer that calls `_checkConnectionAfterGrace()` after 3 seconds
   - On 'failed': Cancel grace period, call `onConnectionLost` immediately (ICE failed is terminal)
   - On 'connected'/'completed': Cancel grace period, reset iceRestartAttempts, call `onConnectionRestored` if was disconnected

4. Add `_startDisconnectGracePeriod()` method after existing `_startDisconnectTimeout()`:
```javascript
_startDisconnectGracePeriod() {
    this._cancelDisconnectGracePeriod();
    this.disconnectGraceId = setTimeout(() => {
        this._checkConnectionAfterGrace();
    }, this.disconnectGracePeriodMs);
}

_cancelDisconnectGracePeriod() {
    if (this.disconnectGraceId) {
        clearTimeout(this.disconnectGraceId);
        this.disconnectGraceId = null;
    }
}

async _checkConnectionAfterGrace() {
    // Verify still disconnected
    if (this.peerConnection?.iceConnectionState !== 'connected' &&
        this.peerConnection?.iceConnectionState !== 'completed') {
        console.log('[WebRTC] Connection lost (grace period elapsed)');
        this.onConnectionLost?.({
            iceState: this.peerConnection?.iceConnectionState,
            dcState: this.dataChannel?.readyState,
            timestamp: Date.now()
        });
    }
}
```

5. Enhance DataChannel `onclose` handler (~line 547) to also trigger `onConnectionLost`:
```javascript
dc.onclose = () => {
    console.log('[WebRTC] DataChannel closed');
    this.onDataChannelClose?.();
    // If DataChannel closes unexpectedly during active game, notify
    if (this.peerConnection?.iceConnectionState === 'connected') {
        this.onConnectionLost?.({
            iceState: this.peerConnection?.iceConnectionState,
            dcState: 'closed',
            timestamp: Date.now()
        });
    }
};
```

6. Update `close()` method (~line 731) to also cancel grace period:
```javascript
// Cancel disconnect grace period
this._cancelDisconnectGracePeriod();
```
  </action>
  <verify>
Grep for new callbacks and methods:
- `grep -n "onConnectionLost" webrtc_manager.js` shows callback property and invocations
- `grep -n "_startDisconnectGracePeriod" webrtc_manager.js` shows method definition
- `grep -n "disconnectGracePeriodMs" webrtc_manager.js` shows config property
  </verify>
  <done>
WebRTCManager detects connection drops via ICE state changes with 3-second grace period, invokes onConnectionLost callback after grace period elapses or on ICE failure, and invokes onConnectionRestored if connection self-recovers.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add reconnection state machine and pause handling to multiplayer game</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Add reconnection state machine to MultiplayerPyodideGame class:

1. Add reconnection state object in constructor after `p2pValidation` (~line 723):
```javascript
// Mid-game reconnection state (Phase 20)
// States: 'connected' -> 'pausing' -> 'paused' -> 'reconnecting' -> 'connected' | 'terminated'
this.reconnectionState = {
    state: 'connected',              // Current reconnection state
    isPaused: false,                 // Game loop paused?
    pauseStartTime: null,            // When pause started
    pauseFrame: null,                // Frame number when paused
    timeoutMs: 30000,                // Configurable timeout (RECON-04)
    timeoutId: null,                 // Timeout handle

    // Event logging (LOG-01, LOG-02, LOG-03)
    disconnections: [],              // [{timestamp, frame, detectingPeer, iceState, dcState}]
    reconnectionAttempts: [],        // [{timestamp, duration, outcome, attempts}]
    totalPauseDuration: 0            // Cumulative ms paused (LOG-03)
};
```

2. Add method to handle connection lost from WebRTCManager (new method after `_initP2PConnection`):
```javascript
/**
 * Handle P2P connection lost (Phase 20 - RECON-01, RECON-02).
 * Called from WebRTCManager callback when connection drop detected.
 */
_onP2PConnectionLost(info) {
    // Skip if already paused or game is done
    if (this.reconnectionState.isPaused || this.state === 'done') {
        return;
    }

    p2pLog.warn('P2P connection lost, requesting bilateral pause', info);

    // Update state
    this.reconnectionState.state = 'pausing';

    // Log disconnection event (LOG-01)
    this.reconnectionState.disconnections.push({
        timestamp: Date.now(),
        frame: this.frameNumber,
        detectingPeer: this.myPlayerId,
        iceState: info.iceState,
        dcState: info.dcState
    });

    // Notify server to coordinate bilateral pause
    socket.emit('p2p_connection_lost', {
        game_id: this.gameId,
        player_id: this.myPlayerId,
        frame_number: this.frameNumber,
        timestamp: Date.now()
    });

    // Apply local pause immediately (server will confirm)
    this._pauseForReconnection(this.frameNumber);
}

/**
 * Pause game for reconnection (Phase 20 - RECON-02).
 * Stops game loop and prepares for reconnection attempt.
 */
_pauseForReconnection(pauseFrame) {
    if (this.reconnectionState.isPaused) {
        return;  // Already paused
    }

    p2pLog.info(`Pausing game for reconnection at frame ${pauseFrame}`);

    this.reconnectionState.isPaused = true;
    this.reconnectionState.pauseStartTime = Date.now();
    this.reconnectionState.pauseFrame = pauseFrame;
    this.reconnectionState.state = 'paused';

    // Pause continuous monitoring if active
    if (this.continuousMonitor) {
        this.continuousMonitor.pause();
    }

    // Note: Overlay will be shown by Plan 02
}

/**
 * Handle server pause command (Phase 20).
 * Server coordinates pause to ensure both clients pause together.
 */
_handleServerPause(data) {
    p2pLog.info('Server requested pause for reconnection', data);

    if (!this.reconnectionState.isPaused) {
        this._pauseForReconnection(data.pause_frame);
    }

    // Start reconnection timeout (RECON-04, RECON-06)
    this._startReconnectionTimeout();
}

/**
 * Start reconnection timeout (Phase 20 - RECON-04).
 */
_startReconnectionTimeout() {
    this._clearReconnectionTimeout();

    this.reconnectionState.timeoutId = setTimeout(() => {
        this._onReconnectionTimeout();
    }, this.reconnectionState.timeoutMs);

    p2pLog.debug(`Reconnection timeout started: ${this.reconnectionState.timeoutMs}ms`);
}

_clearReconnectionTimeout() {
    if (this.reconnectionState.timeoutId) {
        clearTimeout(this.reconnectionState.timeoutId);
        this.reconnectionState.timeoutId = null;
    }
}

/**
 * Handle reconnection timeout (Phase 20 - RECON-06).
 * Game ends cleanly for both players.
 */
_onReconnectionTimeout() {
    p2pLog.warn('Reconnection timeout reached');

    // Calculate pause duration for logging (LOG-02)
    const duration = this.reconnectionState.pauseStartTime ?
        Date.now() - this.reconnectionState.pauseStartTime : 0;

    this.reconnectionState.reconnectionAttempts.push({
        timestamp: Date.now(),
        duration: duration,
        outcome: 'timeout',
        attempts: this.webrtcManager?.iceRestartAttempts || 0
    });

    this.reconnectionState.totalPauseDuration += duration;
    this.reconnectionState.state = 'terminated';

    // Notify server of timeout
    socket.emit('p2p_reconnection_timeout', {
        game_id: this.gameId,
        player_id: this.myPlayerId,
        pause_duration_ms: duration
    });
}
```

3. Wire up WebRTCManager callbacks in `_initP2PConnection()` method (add after existing callback setup ~line 1440):
```javascript
// Connection drop detection (Phase 20)
this.webrtcManager.onConnectionLost = (info) => {
    this._onP2PConnectionLost(info);
};

this.webrtcManager.onConnectionRestored = () => {
    // Connection self-recovered before ICE restart needed
    // Plan 02 will add full resume handling
    p2pLog.info('Connection self-recovered');
};
```

4. Add socket handlers in `setupMultiplayerHandlers()` (add at end of method):
```javascript
// P2P reconnection handlers (Phase 20)
socket.on('p2p_pause', (data) => {
    if (data.game_id === this.gameId) {
        this._handleServerPause(data);
    }
});

socket.on('p2p_resume', (data) => {
    if (data.game_id === this.gameId) {
        // Plan 02 will add full resume implementation
        p2pLog.info('Server requested resume', data);
    }
});

socket.on('p2p_game_ended', (data) => {
    if (data.game_id === this.gameId) {
        this._handleReconnectionGameEnd(data);
    }
});
```

5. Add method to handle game end from reconnection failure:
```javascript
/**
 * Handle game end due to reconnection failure (Phase 20 - RECON-06).
 */
_handleReconnectionGameEnd(data) {
    p2pLog.warn('Game ended due to reconnection failure', data);

    this._clearReconnectionTimeout();
    this.reconnectionState.state = 'terminated';

    // Mark session as partial (reuse Phase 17 pattern)
    this.sessionPartialInfo = {
        reason: 'reconnection_timeout',
        frame: this.frameNumber,
        timestamp: Date.now(),
        reconnectionData: this.getReconnectionData()
    };

    // Transition to done state
    this.state = 'done';
}

/**
 * Get reconnection event data for export (Phase 20 - LOG-01, LOG-02, LOG-03).
 */
getReconnectionData() {
    return {
        disconnections: this.reconnectionState.disconnections,
        reconnectionAttempts: this.reconnectionState.reconnectionAttempts,
        totalPauseDurationMs: this.reconnectionState.totalPauseDuration
    };
}
```

6. Load timeout configuration from scene metadata in `pyodide_game_ready` handler (~line 786):
```javascript
// Reconnection timeout config (Phase 20 - RECON-04)
if (data.scene_metadata?.reconnection_timeout_ms) {
    this.reconnectionState.timeoutMs = data.scene_metadata.reconnection_timeout_ms;
    p2pLog.info(`Reconnection timeout: ${this.reconnectionState.timeoutMs}ms`);
}
```
  </action>
  <verify>
Grep for reconnection state machine components:
- `grep -n "reconnectionState" pyodide_multiplayer_game.js | head -20` shows state object
- `grep -n "_onP2PConnectionLost\|_pauseForReconnection" pyodide_multiplayer_game.js` shows handlers
- `grep -n "p2p_connection_lost\|p2p_pause" pyodide_multiplayer_game.js` shows socket events
  </verify>
  <done>
Client has reconnection state machine tracking pause state, disconnection/reconnection event logging, server pause command handling, and reconnection timeout logic. Game pauses locally when connection lost and waits for server coordination.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add server-side reconnection coordination</name>
  <files>interactive_gym/server/pyodide_game_coordinator.py, interactive_gym/server/app.py</files>
  <action>
Add reconnection tracking to PyodideGameState and coordinator methods:

**In pyodide_game_coordinator.py:**

1. Add reconnection fields to PyodideGameState dataclass (~line 60, after p2p_validation fields):
```python
    # Mid-game reconnection state (Phase 20)
    reconnection_in_progress: bool = False
    reconnection_start_time: float | None = None
    reconnection_timeout_s: float = 30.0  # Configurable (RECON-04)
    reconnection_lost_players: set = dataclasses.field(default_factory=set)
    reconnection_recovered_players: set = dataclasses.field(default_factory=set)
    total_pause_duration_ms: float = 0.0
```

2. Add handle_connection_lost method to PyodideGameCoordinator class (after handle_validation_failure):
```python
    def handle_connection_lost(
        self, game_id: str, player_id: str | int, frame_number: int
    ) -> str | None:
        """
        Handle P2P connection loss from a client (Phase 20 - RECON-01, RECON-02).

        Args:
            game_id: Game identifier
            player_id: Player who detected the disconnection
            frame_number: Frame number when disconnection detected

        Returns:
            'pause' if this triggers bilateral pause
            'already_pausing' if reconnection already in progress
            None if game not found
        """
        with self.lock:
            game = self.games.get(game_id)
            if not game:
                logger.warning(f"Connection lost for non-existent game {game_id}")
                return None

            game.reconnection_lost_players.add(str(player_id))

            if not game.reconnection_in_progress:
                game.reconnection_in_progress = True
                game.reconnection_start_time = time.time()
                game.reconnection_recovered_players = set()

                logger.info(
                    f"P2P reconnection started for game {game_id} "
                    f"(detected by player {player_id} at frame {frame_number})"
                )
                return 'pause'

            logger.debug(
                f"Player {player_id} also detected disconnection in game {game_id}"
            )
            return 'already_pausing'
```

3. Add handle_reconnection_success method:
```python
    def handle_reconnection_success(
        self, game_id: str, player_id: str | int
    ) -> str | None:
        """
        Handle successful P2P reconnection from a client (Phase 20 - RECON-05).

        Returns:
            'resume' if all lost players have recovered
            'waiting' if still waiting for other players
            None if game not found
        """
        with self.lock:
            game = self.games.get(game_id)
            if not game:
                logger.warning(f"Reconnection success for non-existent game {game_id}")
                return None

            if not game.reconnection_in_progress:
                logger.warning(
                    f"Reconnection success but no reconnection in progress for {game_id}"
                )
                return None

            game.reconnection_recovered_players.add(str(player_id))

            # Check if all lost players have recovered
            if game.reconnection_lost_players <= game.reconnection_recovered_players:
                # Calculate pause duration
                pause_duration = (time.time() - game.reconnection_start_time) * 1000
                game.total_pause_duration_ms += pause_duration

                logger.info(
                    f"All players reconnected in game {game_id} "
                    f"(pause duration: {pause_duration:.0f}ms)"
                )

                # Reset reconnection state
                game.reconnection_in_progress = False
                game.reconnection_start_time = None
                game.reconnection_lost_players = set()
                game.reconnection_recovered_players = set()

                return 'resume'

            logger.debug(
                f"Player {player_id} reconnected in game {game_id}, "
                f"waiting for {len(game.reconnection_lost_players - game.reconnection_recovered_players)} more"
            )
            return 'waiting'
```

4. Add handle_reconnection_timeout method:
```python
    def handle_reconnection_timeout(self, game_id: str) -> dict | None:
        """
        Handle reconnection timeout - game ends (Phase 20 - RECON-06).

        Returns reconnection data for logging, or None if game not found.
        """
        with self.lock:
            game = self.games.get(game_id)
            if not game:
                return None

            # Calculate final pause duration
            if game.reconnection_start_time:
                final_pause = (time.time() - game.reconnection_start_time) * 1000
                game.total_pause_duration_ms += final_pause

            logger.warning(
                f"Reconnection timeout for game {game_id} "
                f"(total pause: {game.total_pause_duration_ms:.0f}ms)"
            )

            return {
                'total_pause_duration_ms': game.total_pause_duration_ms,
                'lost_players': list(game.reconnection_lost_players),
                'recovered_players': list(game.reconnection_recovered_players)
            }
```

5. Add get_reconnection_data method:
```python
    def get_reconnection_data(self, game_id: str) -> dict | None:
        """Get reconnection data for a game (Phase 20 - LOG-03)."""
        with self.lock:
            game = self.games.get(game_id)
            if not game:
                return None

            return {
                'in_progress': game.reconnection_in_progress,
                'total_pause_duration_ms': game.total_pause_duration_ms
            }
```

**In app.py:**

6. Add socket handler for p2p_connection_lost (after existing p2p_validation handlers ~line 1410):
```python
@socketio.on("p2p_connection_lost")
def handle_p2p_connection_lost(data):
    """Handle P2P connection loss - coordinate bilateral pause (Phase 20)."""
    global PYODIDE_COORDINATOR

    if PYODIDE_COORDINATOR is None:
        logger.error("PYODIDE_COORDINATOR not initialized")
        return

    game_id = data.get("game_id")
    player_id = data.get("player_id")
    frame_number = data.get("frame_number")

    logger.warning(
        f"P2P connection lost in game {game_id} "
        f"detected by player {player_id} at frame {frame_number}"
    )

    result = PYODIDE_COORDINATOR.handle_connection_lost(game_id, player_id, frame_number)

    if result == 'pause':
        # Emit pause to ALL players via SocketIO (works even when P2P down)
        socketio.emit(
            "p2p_pause",
            {
                "game_id": game_id,
                "pause_frame": frame_number,
                "detecting_player": player_id
            },
            room=game_id
        )
```

7. Add socket handler for p2p_reconnection_success:
```python
@socketio.on("p2p_reconnection_success")
def handle_p2p_reconnection_success(data):
    """Handle successful P2P reconnection (Phase 20)."""
    global PYODIDE_COORDINATOR

    if PYODIDE_COORDINATOR is None:
        return

    game_id = data.get("game_id")
    player_id = data.get("player_id")

    result = PYODIDE_COORDINATOR.handle_reconnection_success(game_id, player_id)

    if result == 'resume':
        logger.info(f"All players reconnected in game {game_id}")
        socketio.emit(
            "p2p_resume",
            {"game_id": game_id},
            room=game_id
        )
```

8. Add socket handler for p2p_reconnection_timeout:
```python
@socketio.on("p2p_reconnection_timeout")
def handle_p2p_reconnection_timeout(data):
    """Handle reconnection timeout - end game cleanly (Phase 20)."""
    global PYODIDE_COORDINATOR

    if PYODIDE_COORDINATOR is None:
        return

    game_id = data.get("game_id")
    player_id = data.get("player_id")

    logger.warning(f"P2P reconnection timeout in game {game_id}")

    # Get reconnection data for logging
    reconnection_data = PYODIDE_COORDINATOR.handle_reconnection_timeout(game_id)

    # Emit game ended to all players
    socketio.emit(
        "p2p_game_ended",
        {
            "game_id": game_id,
            "reason": "reconnection_timeout",
            "reconnection_data": reconnection_data
        },
        room=game_id
    )

    # Clean up game
    PYODIDE_COORDINATOR.remove_game(game_id)
```
  </action>
  <verify>
Verify server-side reconnection handling:
- `grep -n "reconnection_in_progress" pyodide_game_coordinator.py` shows state tracking
- `grep -n "handle_connection_lost\|handle_reconnection_success" pyodide_game_coordinator.py` shows methods
- `grep -n "p2p_connection_lost\|p2p_reconnection" app.py` shows socket handlers
- Check no syntax errors: `python -c "import interactive_gym.server.pyodide_game_coordinator"`
  </verify>
  <done>
Server tracks reconnection state for each game, coordinates bilateral pause via SocketIO when either client detects disconnection, handles reconnection success/timeout, and provides reconnection data for logging.
  </done>
</task>

</tasks>

<verification>
Overall plan verification:
1. Detection: WebRTCManager calls onConnectionLost after 3-second grace period on ICE disconnected/failed
2. Pause: Client emits p2p_connection_lost, server emits p2p_pause to room, both clients pause
3. State tracking: Server tracks reconnection_in_progress, client tracks reconnectionState
4. Timeout: Client sets timeout when paused, emits p2p_reconnection_timeout if elapsed
5. Logging: Disconnection events captured with timestamp, frame, iceState

Manual test (after Plan 02 completes full implementation):
1. Start 2-player game
2. Disconnect one player's network
3. Both clients should pause within 3 seconds
4. If network restored within 30s, game resumes
5. If timeout reached, both clients see game ended
</verification>

<success_criteria>
- RECON-01: Connection drop detected via ICE state change with 3-second grace period
- RECON-02: Both clients pause simultaneously via server-coordinated p2p_pause event
- LOG-01: Disconnection events logged with timestamp, frame, detectingPeer, iceState, dcState
- Server tracks reconnection state and coordinates pause/resume/timeout
</success_criteria>

<output>
After completion, create `.planning/phases/20-mid-game-reconnection/20-01-SUMMARY.md`
</output>
