---
phase: 20-mid-game-reconnection
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - interactive_gym/server/static/js/pyodide_multiplayer_game.js
  - interactive_gym/server/static/js/webrtc_manager.js
  - interactive_gym/scenes/gym_scene.py
autonomous: true

must_haves:
  truths:
    - "Reconnecting overlay appears when paused for reconnection"
    - "ICE restart attempted automatically after pause confirmed"
    - "Gameplay resumes seamlessly when reconnection succeeds"
    - "Reconnection timeout is configurable via GymScene"
    - "Reconnection events exported in session data"
  artifacts:
    - path: "interactive_gym/server/static/js/pyodide_multiplayer_game.js"
      provides: "Overlay UI, ICE restart, resume handling, data export"
      contains: "_showReconnectingOverlay"
    - path: "interactive_gym/server/static/js/webrtc_manager.js"
      provides: "ICE restart with signal forwarding"
      contains: "attemptIceRestart"
    - path: "interactive_gym/scenes/gym_scene.py"
      provides: "reconnection_timeout_ms config"
      contains: "reconnection_timeout_ms"
  key_links:
    - from: "webrtc_manager.js"
      to: "pyodide_multiplayer_game.js"
      via: "ICE restart success callback"
      pattern: "onConnectionRestored"
    - from: "pyodide_multiplayer_game.js"
      to: "app.py"
      via: "socket.emit p2p_reconnection_success"
      pattern: "socket\\.emit.*p2p_reconnection_success"
    - from: "gym_scene.py"
      to: "pyodide_multiplayer_game.js"
      via: "scene_metadata.reconnection_timeout_ms"
      pattern: "reconnection_timeout_ms"
---

<objective>
Add ICE restart recovery, reconnecting overlay UI, resume handling, and data export for mid-game reconnection.

Purpose: Complete the reconnection flow by attempting ICE restart when paused, showing user-facing overlay during reconnection, resuming gameplay when successful, and exporting reconnection event data.

Output: Reconnecting overlay, ICE restart logic, resume flow, config API, data export integration
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-mid-game-reconnection/20-RESEARCH.md
@.planning/phases/20-mid-game-reconnection/20-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add reconnecting overlay UI and resume handling</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Add reconnecting overlay UI and complete the resume flow:

1. Add overlay methods after `_pauseForReconnection` method:
```javascript
/**
 * Show reconnecting overlay (Phase 20 - RECON-03).
 * Displays centered overlay with spinner and status message.
 */
_showReconnectingOverlay() {
    // Remove existing overlay if any
    this._hideReconnectingOverlay();

    const overlay = document.createElement('div');
    overlay.id = 'reconnect-overlay';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        color: white;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    `;
    overlay.innerHTML = `
        <div style="font-size: 24px; margin-bottom: 20px;">
            Connection Lost
        </div>
        <div class="reconnect-spinner" style="
            width: 40px;
            height: 40px;
            border: 4px solid #444;
            border-top: 4px solid #fff;
            border-radius: 50%;
            animation: reconnect-spin 1s linear infinite;
        "></div>
        <div id="reconnect-status" style="margin-top: 20px; font-size: 16px; color: #ccc;">
            Reconnecting...
        </div>
        <style>
            @keyframes reconnect-spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        </style>
    `;
    document.body.appendChild(overlay);
}

/**
 * Hide reconnecting overlay.
 */
_hideReconnectingOverlay() {
    const overlay = document.getElementById('reconnect-overlay');
    if (overlay) {
        overlay.remove();
    }
}

/**
 * Update reconnecting overlay status message.
 */
_updateReconnectingStatus(message) {
    const status = document.getElementById('reconnect-status');
    if (status) {
        status.textContent = message;
    }
}
```

2. Modify `_pauseForReconnection` to show overlay (add at end of method):
```javascript
// Show reconnecting overlay (RECON-03)
this._showReconnectingOverlay();

// Transition to reconnecting state and attempt ICE restart
this.reconnectionState.state = 'reconnecting';
this._attemptReconnection();
```

3. Add reconnection attempt method:
```javascript
/**
 * Attempt to reconnect via ICE restart (Phase 20 - RECON-05).
 */
async _attemptReconnection() {
    if (!this.webrtcManager) {
        p2pLog.error('Cannot attempt reconnection - no WebRTC manager');
        return;
    }

    this._updateReconnectingStatus('Attempting to reconnect...');

    const started = await this.webrtcManager.attemptIceRestart();
    if (started) {
        p2pLog.info('ICE restart initiated');
        this._updateReconnectingStatus('Restoring connection...');
    } else {
        p2pLog.warn('ICE restart failed to start');
        this._updateReconnectingStatus('Connection cannot be restored...');
    }
}
```

4. Add method to handle successful reconnection:
```javascript
/**
 * Handle successful P2P reconnection (Phase 20 - RECON-05).
 * Called when ICE restart succeeds and DataChannel reopens.
 */
_onP2PReconnectionSuccess() {
    if (!this.reconnectionState.isPaused) {
        p2pLog.debug('Reconnection success but not paused - ignoring');
        return;
    }

    p2pLog.info('P2P reconnection successful');

    // Calculate duration for logging (LOG-02)
    const duration = this.reconnectionState.pauseStartTime ?
        Date.now() - this.reconnectionState.pauseStartTime : 0;

    // Log reconnection attempt (LOG-02)
    this.reconnectionState.reconnectionAttempts.push({
        timestamp: Date.now(),
        duration: duration,
        outcome: 'success',
        attempts: this.webrtcManager?.iceRestartAttempts || 0
    });

    // Update total pause duration (LOG-03)
    this.reconnectionState.totalPauseDuration += duration;

    this._updateReconnectingStatus('Connection restored!');

    // Notify server that we've reconnected
    socket.emit('p2p_reconnection_success', {
        game_id: this.gameId,
        player_id: this.myPlayerId,
        duration_ms: duration
    });

    // Server will emit p2p_resume when all players reconnected
}
```

5. Add method to handle server resume command (replace placeholder in setupMultiplayerHandlers):
```javascript
socket.on('p2p_resume', (data) => {
    if (data.game_id === this.gameId) {
        this._handleServerResume(data);
    }
});
```

6. Add resume handler:
```javascript
/**
 * Handle server resume command (Phase 20 - RECON-05).
 * Server coordinates resume to ensure both clients resume together.
 */
_handleServerResume(data) {
    if (!this.reconnectionState.isPaused) {
        p2pLog.debug('Server resume received but not paused');
        return;
    }

    p2pLog.info('Server requested resume - restoring gameplay');

    // Clear timeout first (prevent race condition - Pitfall 4 from research)
    this._clearReconnectionTimeout();

    // Reset reconnection state
    this.reconnectionState.isPaused = false;
    this.reconnectionState.pauseStartTime = null;
    this.reconnectionState.pauseFrame = null;
    this.reconnectionState.state = 'connected';

    // Hide overlay
    this._hideReconnectingOverlay();

    // Resume continuous monitoring if it was active
    if (this.continuousMonitor) {
        this.continuousMonitor.resume();
    }

    p2pLog.info('Gameplay resumed successfully');
}
```

7. Update WebRTCManager callbacks in `_initP2PConnection()` to trigger reconnection success:
```javascript
// Connection restored callback (Phase 20)
this.webrtcManager.onConnectionRestored = () => {
    p2pLog.info('Connection restored');
    // Trigger reconnection success flow
    this._onP2PReconnectionSuccess();
};
```

8. Also handle DataChannel reopen as reconnection signal - add after existing onDataChannelOpen assignment:
```javascript
// Store original callback
const originalOnDataChannelOpen = this.webrtcManager.onDataChannelOpen;
this.webrtcManager.onDataChannelOpen = () => {
    // Call original logic
    originalOnDataChannelOpen?.();

    // If we were reconnecting, this means reconnection succeeded
    if (this.reconnectionState.state === 'reconnecting') {
        p2pLog.info('DataChannel reopened during reconnection');
        this._onP2PReconnectionSuccess();
    }
};
```
  </action>
  <verify>
Grep for overlay and resume handling:
- `grep -n "_showReconnectingOverlay\|_hideReconnectingOverlay" pyodide_multiplayer_game.js` shows overlay methods
- `grep -n "_onP2PReconnectionSuccess\|_handleServerResume" pyodide_multiplayer_game.js` shows success handlers
- `grep -n "p2p_reconnection_success" pyodide_multiplayer_game.js` shows socket emit
  </verify>
  <done>
Reconnecting overlay shows "Connection Lost" with spinner during reconnection attempts. When ICE restart succeeds and DataChannel reopens, client emits p2p_reconnection_success. Server coordinates resume via p2p_resume event. Game loop resumes and overlay hides when server confirms all players reconnected.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ICE restart with proper signaling</name>
  <files>interactive_gym/server/static/js/webrtc_manager.js</files>
  <action>
Add proper ICE restart method that triggers offer/answer renegotiation:

1. Add public `attemptIceRestart()` method after `_handleIceFailure()` (~line 480):
```javascript
/**
 * Attempt ICE restart to recover connection (Phase 20).
 * Creates new offer with iceRestart flag and sends via signaling.
 *
 * @returns {Promise<boolean>} True if restart initiated, false on failure
 */
async attemptIceRestart() {
    if (!this.peerConnection) {
        console.error('[WebRTC] Cannot restart ICE - no peer connection');
        return false;
    }

    if (this.iceRestartAttempts >= this.maxIceRestarts) {
        console.error('[WebRTC] Max ICE restart attempts reached');
        this.onConnectionFailed?.();
        return false;
    }

    this.iceRestartAttempts++;
    console.log(`[WebRTC] ICE restart attempt ${this.iceRestartAttempts}/${this.maxIceRestarts}`);

    try {
        // Request ICE restart
        this.peerConnection.restartIce();

        // Only initiator creates offer (use same deterministic role as initial connection)
        const isInitiator = this._comparePlayerIds(this.myPlayerId, this.targetPeerId) < 0;

        if (isInitiator) {
            // Create new offer with ICE restart flag
            const offer = await this.peerConnection.createOffer({ iceRestart: true });
            await this.peerConnection.setLocalDescription(offer);
            this._sendSignal('offer', this.peerConnection.localDescription);
            console.log('[WebRTC] Sent ICE restart offer');
        }
        // Answerer will respond when they receive the offer

        return true;
    } catch (error) {
        console.error('[WebRTC] ICE restart failed:', error);
        return false;
    }
}
```

2. Modify `_handleIceFailure()` to use the new method:
```javascript
/**
 * Handle ICE failure by attempting restart.
 * @private
 */
async _handleIceFailure() {
    const success = await this.attemptIceRestart();
    if (!success) {
        this.onConnectionFailed?.();
    }
}
```

3. Add method to check if connection is usable after ICE restart (for detecting recovery):
```javascript
/**
 * Check if the connection is in a usable state.
 * @returns {boolean} True if connected and DataChannel is open
 */
isConnectionUsable() {
    return (
        this.peerConnection?.iceConnectionState === 'connected' ||
        this.peerConnection?.iceConnectionState === 'completed'
    ) && this.dataChannel?.readyState === 'open';
}
```

4. Update ICE connection state handler to call `onConnectionRestored` when recovery happens:
Modify the 'connected'/'completed' case in `oniceconnectionstatechange` (~line 338):
```javascript
case 'connected':
case 'completed':
    this._cancelDisconnectTimeout();
    this._cancelDisconnectGracePeriod();
    // Check if this is a recovery (had restart attempts) vs initial connection
    if (this.iceRestartAttempts > 0) {
        console.log('[WebRTC] Connection restored after ICE restart');
        this.onConnectionRestored?.();
    }
    this.iceRestartAttempts = 0;  // Reset counter on successful connection
    break;
```
  </action>
  <verify>
Verify ICE restart implementation:
- `grep -n "attemptIceRestart" webrtc_manager.js` shows public method
- `grep -n "iceRestart: true" webrtc_manager.js` shows restart flag in offer
- `grep -n "onConnectionRestored" webrtc_manager.js` shows callback invocation
  </verify>
  <done>
WebRTCManager has public attemptIceRestart() method that increments attempt counter, calls restartIce(), and (if initiator) creates new offer with iceRestart flag. On successful recovery, onConnectionRestored callback is invoked.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add researcher config and data export integration</name>
  <files>interactive_gym/scenes/gym_scene.py, interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Add reconnection_timeout_ms config to GymScene and integrate reconnection data into export:

**In gym_scene.py:**

1. Add reconnection config attributes to GymScene class (after line ~160, near other multiplayer configs):
```python
        # Mid-game reconnection config (Phase 20)
        self.reconnection_timeout_ms: int = 30000  # Default 30 seconds (RECON-04)
```

2. Add builder method for reconnection config (after continuous_monitoring method ~line 430):
```python
    def reconnection_config(
        self,
        timeout_ms: int = 30000,
    ) -> "GymScene":
        """Configure mid-game reconnection behavior.

        Args:
            timeout_ms: Time in milliseconds to wait for reconnection before
                       ending the game. Default is 30000 (30 seconds).

        Returns:
            self for chaining.
        """
        self.reconnection_timeout_ms = timeout_ms
        return self
```

3. Add reconnection config to scene_metadata in `to_config_dict()` method. Find where scene_metadata is built (search for "continuous_monitoring_enabled") and add:
```python
            "reconnection_timeout_ms": self.reconnection_timeout_ms,
```

**In pyodide_multiplayer_game.js:**

4. Integrate reconnection data into validation export. Find `exportValidationData()` method and add reconnection data:
```javascript
// Add to the returned object in exportValidationData():
    reconnection: this.getReconnectionData(),
```

5. Also include reconnection data in cumulative validation. Find where `cumulativeValidation` is populated (likely in episode end handling) and ensure reconnection data is included:
```javascript
// In the method that builds cumulative validation (likely near end of game handling):
// Add alongside existing validation data:
    reconnectionEvents: this.reconnectionState.disconnections,
    reconnectionAttempts: this.reconnectionState.reconnectionAttempts,
    totalReconnectionPauseMs: this.reconnectionState.totalPauseDuration,
```

6. Also add to sessionPartialInfo when game ends due to reconnection (already added in Plan 01, but ensure it includes all data):
In `_handleReconnectionGameEnd`, the reconnectionData should already be included via `getReconnectionData()`.

7. If there's a `getSessionMetrics()` or similar export method, add reconnection data there too:
```javascript
// Find getSessionMetrics or similar and add:
    reconnection: {
        disconnections: this.reconnectionState.disconnections,
        attempts: this.reconnectionState.reconnectionAttempts,
        totalPauseDurationMs: this.reconnectionState.totalPauseDuration
    },
```
  </action>
  <verify>
Verify config and export integration:
- `grep -n "reconnection_timeout_ms" gym_scene.py` shows attribute and builder method
- `grep -n "reconnection_config" gym_scene.py` shows builder method
- `grep -n "reconnection.*getReconnectionData\|reconnection.*disconnections" pyodide_multiplayer_game.js` shows export integration
  </verify>
  <done>
GymScene has reconnection_config() builder method for setting timeout_ms. Reconnection data (disconnections, attempts, totalPauseDurationMs) is included in validation export and session metrics. Researchers can configure timeout and access reconnection telemetry in exported data.
  </done>
</task>

</tasks>

<verification>
Overall phase verification (after Plan 01 + Plan 02):

**Automated checks:**
1. All requirements mapped to code:
   - RECON-01: `onConnectionLost` callback in webrtc_manager.js
   - RECON-02: `_pauseForReconnection` + server `p2p_pause` coordination
   - RECON-03: `_showReconnectingOverlay` with spinner and status
   - RECON-04: `reconnection_config(timeout_ms=...)` in gym_scene.py
   - RECON-05: `attemptIceRestart` + `_handleServerResume`
   - RECON-06: `_onReconnectionTimeout` + `p2p_game_ended` handler
   - LOG-01: `reconnectionState.disconnections` array
   - LOG-02: `reconnectionState.reconnectionAttempts` array
   - LOG-03: `reconnectionState.totalPauseDuration` field

2. Grep verification:
```bash
# Detection
grep -n "onConnectionLost" webrtc_manager.js
# Pause
grep -n "p2p_pause\|p2p_connection_lost" pyodide_multiplayer_game.js
# Overlay
grep -n "reconnect-overlay" pyodide_multiplayer_game.js
# ICE restart
grep -n "attemptIceRestart" webrtc_manager.js
# Config
grep -n "reconnection_timeout_ms" gym_scene.py
# Export
grep -n "getReconnectionData" pyodide_multiplayer_game.js
```

**Manual test flow:**
1. Start 2-player game with `reconnection_config(timeout_ms=15000)`
2. During gameplay, disconnect Player A's network (airplane mode)
3. Both players should see "Connection Lost" overlay within 3 seconds
4. Reconnect Player A's network within 15 seconds
5. Both players should see game resume
6. After game ends, check exported data includes reconnection metrics

**Alternative test (timeout):**
1. Start 2-player game with `reconnection_config(timeout_ms=5000)`
2. During gameplay, disconnect Player A's network
3. Both players see overlay
4. Wait 5 seconds without reconnecting
5. Both players should see game ended due to timeout
6. Exported data includes timeout in reconnection attempts
</verification>

<success_criteria>
- RECON-03: Reconnecting overlay shows "Connection Lost" with spinner during reconnection
- RECON-04: Timeout configurable via `gym_scene.reconnection_config(timeout_ms=...)`
- RECON-05: Game resumes when both players reconnect via ICE restart
- RECON-06: Game ends cleanly when timeout reached
- LOG-02: Reconnection attempts logged with duration and outcome (success/timeout)
- LOG-03: Total pause duration available in session data export
</success_criteria>

<output>
After completion, create `.planning/phases/20-mid-game-reconnection/20-02-SUMMARY.md`
</output>
