---
phase: 69-server-init-grace
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/app.py
  - interactive_gym/server/static/js/index.js
  - interactive_gym/server/static/js/pyodide_remote_game.js
autonomous: true

must_haves:
  truths:
    - "Server does not disconnect clients during Pyodide loading (fallback path takes 5-15s, currently times out at 16s)"
    - "Client signals loading state to server before main thread blocks"
    - "Normal ping checking resumes after loading completes"
    - "Loading grace has a 60-second safety timeout to prevent unbounded LOADING_CLIENTS growth"
  artifacts:
    - path: "interactive_gym/server/app.py"
      provides: "LOADING_CLIENTS dict, pyodide_loading_start/complete handlers, is_client_in_loading_grace(), grace check in on_disconnect()"
      contains: "LOADING_CLIENTS"
    - path: "interactive_gym/server/static/js/index.js"
      provides: "Loading signals in preloadPyodide()"
      contains: "pyodide_loading_start"
    - path: "interactive_gym/server/static/js/pyodide_remote_game.js"
      provides: "Loading signals in fallback loadPyodide() path"
      contains: "pyodide_loading_start"
  key_links:
    - from: "interactive_gym/server/static/js/index.js"
      to: "interactive_gym/server/app.py"
      via: "socket.emit('pyodide_loading_start') before loadPyodide()"
      pattern: "emit.*pyodide_loading_start"
    - from: "interactive_gym/server/static/js/pyodide_remote_game.js"
      to: "interactive_gym/server/app.py"
      via: "window.socket.emit('pyodide_loading_start') before fallback loadPyodide()"
      pattern: "emit.*pyodide_loading_start"
    - from: "interactive_gym/server/app.py on_disconnect()"
      to: "interactive_gym/server/app.py is_client_in_loading_grace()"
      via: "Early return in disconnect handler when client is loading"
      pattern: "is_client_in_loading_grace"
---

<objective>
Add a server-side grace mechanism so clients are not falsely disconnected during Pyodide WASM compilation. The preloaded path (Phase 67+68) eliminates most loading delays, but the fallback path still blocks the main thread for 5-15 seconds, which can exceed the current Engine.IO ping timeout (8+8=16s) under load.

Purpose: Satisfy GRACE-01, GRACE-02, GRACE-03 requirements -- the safety net for the Pyodide fallback loading path.
Output: Modified app.py with grace tracking + modified client files with loading signals.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/69-server-init-grace/69-RESEARCH.md

Key source files:
@interactive_gym/server/app.py
@interactive_gym/server/static/js/index.js
@interactive_gym/server/static/js/pyodide_remote_game.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Server-side grace period infrastructure</name>
  <files>interactive_gym/server/app.py</files>
  <action>
  Make four changes to app.py:

  1. **Increase ping_timeout** (line ~185): Change `ping_timeout=8` to `ping_timeout=30`. Keep `ping_interval=8`. Update the comment to explain this accommodates Pyodide WASM compilation (5-15s) in the fallback path. Total grace before disconnect becomes 8+30=38 seconds, well beyond worst case. Note: This weakens real disconnect detection from 16s to 38s, but multiplayer games already have P2P WebRTC disconnect detection at 500ms, so this is acceptable.

  2. **Add LOADING_CLIENTS global** near the other globals (around line 128, near PARTICIPANT_SESSIONS): Add `LOADING_CLIENTS: dict[str, float] = {}` mapping subject_id to start timestamp. Add `LOADING_TIMEOUT_S = 60` constant (max loading time before considering client dead).

  3. **Add socket event handlers** for `pyodide_loading_start` and `pyodide_loading_complete`. Place them near the existing `ping` handler (around line 938). Implementation:

  ```python
  @socketio.on("pyodide_loading_start")
  def on_pyodide_loading_start(data):
      subject_id = get_subject_id_from_session_id(flask.request.sid)
      if subject_id:
          LOADING_CLIENTS[subject_id] = time.time()
          logger.info(f"[Grace] {subject_id} starting Pyodide loading")

  @socketio.on("pyodide_loading_complete")
  def on_pyodide_loading_complete(data):
      subject_id = get_subject_id_from_session_id(flask.request.sid)
      if subject_id:
          start_time = LOADING_CLIENTS.pop(subject_id, None)
          if start_time:
              duration = time.time() - start_time
              logger.info(f"[Grace] {subject_id} completed Pyodide loading in {duration:.1f}s")
          else:
              logger.info(f"[Grace] {subject_id} completed Pyodide loading (no start tracked)")
  ```

  4. **Add grace check at the TOP of on_disconnect()** (line ~2666), right after the subject_id lookup and the "No subject_id found" early return (line ~2689). Before the admin dashboard log_activity call. Implementation:

  ```python
  def is_client_in_loading_grace(subject_id: str) -> bool:
      """Check if client is in Pyodide loading grace period (not timed out)."""
      start_time = LOADING_CLIENTS.get(subject_id)
      if start_time is None:
          return False
      if time.time() - start_time > LOADING_TIMEOUT_S:
          LOADING_CLIENTS.pop(subject_id, None)
          logger.warning(f"[Grace] {subject_id} loading grace expired after {LOADING_TIMEOUT_S}s")
          return False
      return True
  ```

  Place `is_client_in_loading_grace` as a module-level function near `get_subject_id_from_session_id`.

  In `on_disconnect()`, after the `subject_id is None` early return, add:

  ```python
  if is_client_in_loading_grace(subject_id):
      logger.warning(
          f"[Grace] {subject_id} disconnected during Pyodide loading. "
          f"Preserving session for reconnection."
      )
      # Save session state using existing pattern (lines 2712-2723)
      session = PARTICIPANT_SESSIONS.get(subject_id)
      if session is not None:
          participant_stager = STAGERS.get(subject_id, None)
          if participant_stager:
              session.stager_state = participant_stager.get_state()
              session.current_scene_id = (
                  participant_stager.current_scene.scene_id
                  if participant_stager.current_scene else None
              )
          session.socket_id = None
          session.is_connected = False
          session.last_updated_at = time.time()
      return  # Skip game cleanup, partner notifications, etc.
  ```

  IMPORTANT: The grace check must come BEFORE the existing admin dashboard logging and game cleanup logic. It's an early return that preserves session state but skips all destructive actions.

  Do NOT modify any other disconnect handler logic. The rest of on_disconnect() stays exactly as-is.
  </action>
  <verify>
  - `python -c "import interactive_gym.server.app"` succeeds (no import errors)
  - Grep for `LOADING_CLIENTS` in app.py returns the global dict, event handlers, and grace check
  - Grep for `ping_timeout=30` in app.py confirms the timeout increase
  - Grep for `is_client_in_loading_grace` in app.py returns the function and its usage in on_disconnect
  </verify>
  <done>
  - ping_timeout increased from 8 to 30 seconds
  - LOADING_CLIENTS dict tracks per-client loading state with timestamps
  - pyodide_loading_start/complete handlers add/remove from LOADING_CLIENTS
  - is_client_in_loading_grace() checks loading state with 60s safety timeout
  - on_disconnect() skips destructive cleanup when client is in loading grace, preserving session for reconnection
  </done>
</task>

<task type="auto">
  <name>Task 2: Client-side loading signals in both Pyodide paths</name>
  <files>interactive_gym/server/static/js/index.js, interactive_gym/server/static/js/pyodide_remote_game.js</files>
  <action>
  Add loading state signals to BOTH places where Pyodide can block the main thread.

  **Path 1: index.js preloadPyodide() (lines ~216-253)**

  Add loading signal BEFORE the blocking `loadPyodide()` call, with a 50ms yield to ensure the emit is sent before the main thread blocks. Modify the function:

  ```javascript
  async function preloadPyodide(pyodideConfig) {
      if (!pyodideConfig || !pyodideConfig.needs_pyodide) {
          window.pyodidePreloadStatus = 'ready';
          return;
      }

      console.log('[PyodidePreload] Starting preload...');
      window.pyodidePreloadStatus = 'loading';
      showPyodideProgress('Loading Python runtime...');

      // Signal server BEFORE blocking the main thread (GRACE-02)
      socket.emit('pyodide_loading_start', {});
      // Yield to event loop so the emit is actually sent before WASM compilation blocks
      await new Promise(resolve => setTimeout(resolve, 50));

      try {
          const pyodide = await loadPyodide();
          // ... existing micropip + package install code unchanged ...

          window.pyodidePreloadStatus = 'ready';
          hidePyodideProgress();
          console.log('[PyodidePreload] Complete');

          // Signal server loading is done (GRACE-03)
          socket.emit('pyodide_loading_complete', {});

      } catch (error) {
          console.error('[PyodidePreload] Failed:', error);
          window.pyodidePreloadStatus = 'error';
          showPyodideProgress('Loading failed - will retry when game starts');
          // Signal server loading is done (even on error) to clear grace state
          socket.emit('pyodide_loading_complete', { error: true });
      }
  }
  ```

  Key points:
  - `socket.emit('pyodide_loading_start', {})` goes BEFORE `loadPyodide()`
  - `await new Promise(resolve => setTimeout(resolve, 50))` yields to ensure emit is sent
  - `socket.emit('pyodide_loading_complete', {})` goes AFTER all loading succeeds
  - Error path also sends `pyodide_loading_complete` with `{ error: true }` to clear grace state
  - The `socket` variable is already available in index.js scope (defined at line 12)

  **Path 2: pyodide_remote_game.js RemoteGame.initialize() fallback (lines ~56-61)**

  The fallback `else` branch runs when preload did not happen. Add signals around the blocking call. The socket is accessible via `window.socket`:

  ```javascript
  } else {
      console.log('[RemoteGame] Loading Pyodide fresh (no preload available)');
      // Signal server BEFORE blocking the main thread (GRACE-02)
      if (window.socket) {
          window.socket.emit('pyodide_loading_start', {});
          // Yield to event loop so the emit is sent before WASM compilation blocks
          await new Promise(resolve => setTimeout(resolve, 50));
      }

      this.pyodide = await loadPyodide();

      await this.pyodide.loadPackage("micropip");
      this.micropip = this.pyodide.pyimport("micropip");

      // Signal server loading is done (GRACE-03)
      if (window.socket) {
          window.socket.emit('pyodide_loading_complete', {});
      }
  }
  ```

  Key points:
  - Guard with `if (window.socket)` since RemoteGame is a module and socket may not exist in non-multiplayer contexts
  - Same 50ms yield pattern as index.js
  - `pyodide_loading_complete` emitted AFTER loadPackage("micropip") completes (micropip loading also blocks)
  - Do NOT add signals to the preloaded path (the `if` branch) -- it doesn't block the main thread

  IMPORTANT: Do NOT wrap the fallback path in try/catch for the signals. If loadPyodide() fails in the fallback path, the error should propagate naturally (existing behavior). The LOADING_CLIENTS entry will be cleaned up by the 60-second safety timeout on the server.
  </action>
  <verify>
  - Grep for `pyodide_loading_start` in index.js returns the emit call
  - Grep for `pyodide_loading_start` in pyodide_remote_game.js returns the emit call
  - Grep for `pyodide_loading_complete` in index.js returns 2 occurrences (success + error paths)
  - Grep for `pyodide_loading_complete` in pyodide_remote_game.js returns 1 occurrence
  - Grep for `setTimeout.*50` in both files confirms the yield before blocking calls
  </verify>
  <done>
  - preloadPyodide() in index.js emits pyodide_loading_start before loadPyodide() with 50ms yield
  - preloadPyodide() in index.js emits pyodide_loading_complete on success and error
  - RemoteGame.initialize() fallback path emits pyodide_loading_start before loadPyodide() with 50ms yield
  - RemoteGame.initialize() fallback path emits pyodide_loading_complete after micropip loaded
  - Both paths guard socket access appropriately
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. `python -c "import interactive_gym.server.app"` -- no import errors
2. Grep confirms all three requirements are wired:
   - GRACE-01: `is_client_in_loading_grace` used in `on_disconnect()`
   - GRACE-02: `pyodide_loading_start` emitted from both client paths
   - GRACE-03: `pyodide_loading_complete` emitted from both client paths, server handler removes from LOADING_CLIENTS
3. `ping_timeout=30` is set in SocketIO config
4. No existing tests broken (if test suite available): `python -m pytest tests/ -x --timeout=60 -q` (skip if no relevant unit tests)
</verification>

<success_criteria>
- Server ping_timeout increased from 8s to 30s (total grace: 38s, well beyond 15s worst-case Pyodide load)
- Client signals loading state to server via pyodide_loading_start/complete events
- Server tracks per-client loading state with timestamps in LOADING_CLIENTS dict
- Disconnect handler skips destructive cleanup when client is in loading grace period
- 60-second safety timeout prevents unbounded LOADING_CLIENTS growth
- Both Pyodide loading paths (preload in index.js, fallback in RemoteGame) send signals
- All three GRACE requirements (GRACE-01, GRACE-02, GRACE-03) satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/69-server-init-grace/69-01-SUMMARY.md`
</output>
