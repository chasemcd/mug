---
phase: 02-p2p-transport
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - interactive_gym/server/static/js/pyodide_multiplayer_game.js
autonomous: true

must_haves:
  truths:
    - "Local inputs are sent over P2P DataChannel with redundancy"
    - "Each P2P input packet includes last 3 inputs for loss recovery"
    - "Periodic ping messages measure RTT every 500ms"
    - "Ping interval is cleaned up when game ends"
  artifacts:
    - path: "interactive_gym/server/static/js/pyodide_multiplayer_game.js"
      provides: "P2PInputSender class, step() integration, ping interval"
      contains: "P2PInputSender"
  key_links:
    - from: "step()"
      to: "p2pInputSender.recordAndSend()"
      via: "Called after socket.emit for parallel P2P sending"
      pattern: "this\\.p2pInputSender\\.recordAndSend"
    - from: "onDataChannelOpen"
      to: "P2PInputSender constructor"
      via: "Initialize sender when connection opens"
      pattern: "new P2PInputSender"
---

<objective>
Add P2P input sending with redundancy and periodic ping for RTT measurement. Integrate into the game loop.

Purpose: Complete the P2P transport layer by sending local inputs over DataChannel in parallel with SocketIO. Redundant sending handles packet loss without retransmission.
Output: P2PInputSender class, integration into step() and onDataChannelOpen, ping interval with cleanup.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-p2p-transport/02-RESEARCH.md
@.planning/phases/02-p2p-transport/02-01-SUMMARY.md
@.planning/phases/02-p2p-transport/02-02-SUMMARY.md
@interactive_gym/server/static/js/pyodide_multiplayer_game.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add P2PInputSender class</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Add the P2PInputSender class after the ConnectionHealthMonitor class (before MultiplayerPyodideGame):

```javascript
/**
 * Manages sending local inputs over P2P DataChannel with redundancy.
 * Each packet includes the last N inputs to handle packet loss.
 */
class P2PInputSender {
    /**
     * @param {WebRTCManager} webrtcManager - The WebRTC connection manager
     * @param {number} myPlayerId - This player's ID
     * @param {number} redundancyCount - Number of inputs to include per packet (default: 3)
     */
    constructor(webrtcManager, myPlayerId, redundancyCount = 3) {
        this.webrtcManager = webrtcManager;
        this.myPlayerId = myPlayerId;
        this.redundancyCount = redundancyCount;

        // Track recent inputs for redundant sending
        // [{frame, action}, ...] - most recent at end
        this.recentInputs = [];
        this.maxRecentInputs = 10;  // Keep larger buffer than redundancy needs

        // Buffer congestion threshold (bytes)
        this.bufferThreshold = 16384;
    }

    /**
     * Record a local input and send it (with redundancy) to peer.
     * @param {number} action - The action taken
     * @param {number} targetFrame - The frame this input is scheduled for
     * @returns {boolean} True if sent, false if skipped (buffer congested or not ready)
     */
    recordAndSend(action, targetFrame) {
        // Record this input
        this.recentInputs.push({ frame: targetFrame, action: action });

        // Trim to max size
        if (this.recentInputs.length > this.maxRecentInputs) {
            this.recentInputs.shift();
        }

        // Check if channel is ready
        if (!this.webrtcManager?.isReady()) {
            return false;
        }

        // Check buffer congestion
        const dc = this.webrtcManager.dataChannel;
        if (dc && dc.bufferedAmount > this.bufferThreshold) {
            console.warn('[P2P] Buffer congested, skipping input packet');
            return false;
        }

        // Build redundant input set (current + last N-1)
        const inputsToSend = this.recentInputs.slice(-this.redundancyCount);

        // Encode and send
        const packet = encodeInputPacket(
            this.myPlayerId,
            targetFrame,
            inputsToSend
        );

        return this.webrtcManager.send(packet);
    }

    /**
     * Clear recorded inputs (call on episode reset).
     */
    reset() {
        this.recentInputs = [];
    }
}
```

The redundancyCount of 3 means each packet includes the current input plus the 2 previous inputs. If any packet is lost, the next packet will still include that input.
  </action>
  <verify>
Search for `class P2PInputSender` and `recordAndSend` in the file.
  </verify>
  <done>
P2PInputSender class exists with constructor, recordAndSend(), and reset() methods.
recordAndSend includes last N inputs for redundancy.
Buffer congestion check prevents overflow.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate P2PInputSender into step() and onDataChannelOpen</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Make two changes:

1. In the constructor, add new instance properties (in the P2P WebRTC connection section around line 130):
```javascript
// P2P input sending
this.p2pInputSender = null;
this.connectionHealth = null;
this.pingIntervalId = null;
```

2. Update the onDataChannelOpen callback in _initP2PConnection() to initialize P2P components:

Find the existing callback (around line 2159):
```javascript
this.webrtcManager.onDataChannelOpen = () => {
    console.log('[MultiplayerPyodide] P2P DataChannel OPEN');
    this.p2pConnected = true;

    // Send a test message to verify connection
    this._sendP2PTestMessage();
};
```

Replace it with:
```javascript
this.webrtcManager.onDataChannelOpen = () => {
    console.log('[MultiplayerPyodide] P2P DataChannel OPEN');
    this.p2pConnected = true;

    // Initialize P2P input sending
    this.p2pInputSender = new P2PInputSender(
        this.webrtcManager,
        this.myPlayerId,
        3  // redundancy count
    );

    // Initialize connection health monitoring
    this.connectionHealth = new ConnectionHealthMonitor();

    // Start periodic ping for RTT measurement
    this._startPingInterval();

    // Send a test message to verify connection (legacy)
    this._sendP2PTestMessage();
};
```

3. In the step() method, add P2P input sending after the socket.emit call.

Find the socket.emit block (around line 811):
```javascript
socket.emit('pyodide_player_action', {
    game_id: this.gameId,
    player_id: this.myPlayerId,
    action: myCurrentAction,
    frame_number: targetFrame,
    timestamp: Date.now(),
    sync_epoch: this.syncEpoch
});
```

Add immediately after:
```javascript
// Also send via P2P DataChannel (parallel to SocketIO)
if (this.p2pConnected && this.p2pInputSender) {
    this.p2pInputSender.recordAndSend(myCurrentAction, targetFrame);
}
```

This sends inputs over BOTH channels. Phase 3 will add logic to prefer P2P when healthy and fall back to SocketIO when P2P fails.
  </action>
  <verify>
Search for `new P2PInputSender` in the file (should be in onDataChannelOpen).
Search for `p2pInputSender.recordAndSend` in the file (should be in step()).
  </verify>
  <done>
P2PInputSender is instantiated when DataChannel opens.
ConnectionHealthMonitor is instantiated when DataChannel opens.
step() calls p2pInputSender.recordAndSend after socket.emit.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add ping interval and cleanup</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Add the _startPingInterval method to MultiplayerPyodideGame class (after _handlePong):

```javascript
_startPingInterval() {
    /**
     * Start periodic ping for RTT measurement.
     * Pings every 500ms while P2P connection is active.
     */
    if (this.pingIntervalId) {
        clearInterval(this.pingIntervalId);
    }

    this.pingIntervalId = setInterval(() => {
        if (this.webrtcManager?.isReady() && this.connectionHealth) {
            const ping = encodePing();
            this.webrtcManager.send(ping);
            this.connectionHealth.rttTracker.lastPingTime = performance.now();
        }
    }, 500);  // Every 500ms

    console.log('[P2P] Started ping interval (500ms)');
}

_stopPingInterval() {
    /**
     * Stop the ping interval.
     */
    if (this.pingIntervalId) {
        clearInterval(this.pingIntervalId);
        this.pingIntervalId = null;
        console.log('[P2P] Stopped ping interval');
    }
}
```

Also update the onDataChannelClose callback to stop the ping interval:

Find the existing callback (around line 2171):
```javascript
this.webrtcManager.onDataChannelClose = () => {
    console.log('[MultiplayerPyodide] P2P DataChannel CLOSED');
    this.p2pConnected = false;
};
```

Update to:
```javascript
this.webrtcManager.onDataChannelClose = () => {
    console.log('[MultiplayerPyodide] P2P DataChannel CLOSED');
    this.p2pConnected = false;
    this._stopPingInterval();
};
```

And update the onConnectionFailed callback:
```javascript
this.webrtcManager.onConnectionFailed = () => {
    console.error('[MultiplayerPyodide] P2P connection FAILED');
    this.p2pConnected = false;
    this._stopPingInterval();
};
```

Finally, update the clearGGPOState method to reset the P2PInputSender (search for `clearGGPOState` method and add at the end of the method):
```javascript
// Reset P2P input sender for new episode
if (this.p2pInputSender) {
    this.p2pInputSender.reset();
}
```
  </action>
  <verify>
Search for `_startPingInterval` and `_stopPingInterval` in the file.
Verify `_stopPingInterval` is called in onDataChannelClose.
Search for `p2pInputSender.reset()` in clearGGPOState.
  </verify>
  <done>
_startPingInterval sends ping every 500ms via webrtcManager.
_stopPingInterval clears the interval.
DataChannel close and connection failure stop the ping interval.
P2PInputSender is reset on episode reset (clearGGPOState).
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. P2PInputSender class exists with recordAndSend() and reset() methods
2. onDataChannelOpen creates P2PInputSender, ConnectionHealthMonitor, and starts ping interval
3. step() calls p2pInputSender.recordAndSend() after socket.emit
4. _startPingInterval sends pings every 500ms
5. _stopPingInterval is called on DataChannel close and connection failure
6. clearGGPOState calls p2pInputSender.reset()
7. No JavaScript syntax errors

To verify end-to-end:
1. Start a multiplayer game with two browser clients
2. Open DevTools on both
3. Confirm "[P2P] Started ping interval (500ms)" appears
4. Confirm periodic "[P2P] RTT: Xms" logs appear (every ~60 frames)
5. Confirm "[P2P] Received input packet" logs appear
</verification>

<success_criteria>
- Local inputs are sent via P2P with redundancy (last 3 inputs per packet)
- Ping messages are sent every 500ms
- RTT is tracked and logged
- Cleanup happens on connection close
- P2PInputSender resets between episodes
</success_criteria>

<output>
After completion, create `.planning/phases/02-p2p-transport/02-03-SUMMARY.md`
</output>
