---
phase: 02-p2p-transport
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - interactive_gym/server/static/js/pyodide_multiplayer_game.js
autonomous: true

must_haves:
  truths:
    - "Binary P2P messages are routed to correct handler by message type"
    - "Received inputs are stored in GGPO input buffer via storeRemoteInput"
    - "Ping messages trigger immediate pong response"
    - "RTT is calculated from pong responses"
  artifacts:
    - path: "interactive_gym/server/static/js/pyodide_multiplayer_game.js"
      provides: "RTTTracker class, ConnectionHealthMonitor class, binary message handlers"
      contains: "RTTTracker"
  key_links:
    - from: "_handleBinaryMessage"
      to: "_handleInputPacket"
      via: "Switch on message type byte"
      pattern: "case P2P_MSG_INPUT"
    - from: "_handleInputPacket"
      to: "storeRemoteInput"
      via: "Loop over packet inputs"
      pattern: "this\\.storeRemoteInput"
---

<objective>
Add P2P message receiving infrastructure: RTT tracking, connection health monitoring, and binary message handlers that integrate with existing GGPO input buffer.

Purpose: Enable the client to receive and process P2P input packets from the peer, measure RTT for connection quality, and monitor connection health.
Output: RTTTracker class, ConnectionHealthMonitor class, and message handlers integrated into MultiplayerPyodideGame.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-p2p-transport/02-RESEARCH.md
@.planning/phases/02-p2p-transport/02-01-SUMMARY.md
@interactive_gym/server/static/js/pyodide_multiplayer_game.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RTTTracker and ConnectionHealthMonitor classes</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Add two classes after the message encoding functions (before the MultiplayerPyodideGame class):

```javascript
/**
 * Tracks round-trip time measurements from ping/pong exchanges.
 */
class RTTTracker {
    constructor() {
        this.rttSamples = [];
        this.maxSamples = 10;
        this.lastPingTime = 0;
        this.pingInterval = 500;  // ms between pings
    }

    /**
     * Check if enough time has passed to send another ping.
     * @returns {boolean}
     */
    shouldPing() {
        return performance.now() - this.lastPingTime >= this.pingInterval;
    }

    /**
     * Record an RTT sample from a pong response.
     * @param {number} sentTime - The timestamp echoed back in the pong
     */
    recordRTT(sentTime) {
        const rtt = performance.now() - sentTime;
        this.rttSamples.push(rtt);
        if (this.rttSamples.length > this.maxSamples) {
            this.rttSamples.shift();
        }
    }

    /**
     * Get the average RTT across recent samples.
     * @returns {number|null} Average RTT in ms, or null if no samples
     */
    getAverageRTT() {
        if (this.rttSamples.length === 0) return null;
        return this.rttSamples.reduce((a, b) => a + b, 0) / this.rttSamples.length;
    }

    /**
     * Get estimated one-way latency (half of RTT).
     * @returns {number|null} Latency in ms, or null if no samples
     */
    getLatency() {
        const rtt = this.getAverageRTT();
        return rtt !== null ? rtt / 2 : null;
    }
}

/**
 * Monitors P2P connection health based on packet reception patterns and latency.
 */
class ConnectionHealthMonitor {
    constructor() {
        this.rttTracker = new RTTTracker();
        this.lastReceivedFrame = -1;
        this.packetsReceived = 0;
        this.gapCount = 0;  // Count of detected frame gaps

        // Health thresholds
        this.warningLatencyMs = 100;
        this.criticalLatencyMs = 200;
    }

    /**
     * Record that we received an input for a frame.
     * @param {number} frame - The frame number received
     */
    recordReceivedInput(frame) {
        this.packetsReceived++;

        // Detect gaps (indicates packet loss, though redundancy may cover it)
        if (this.lastReceivedFrame >= 0 && frame > this.lastReceivedFrame + 1) {
            this.gapCount++;
        }
        this.lastReceivedFrame = Math.max(this.lastReceivedFrame, frame);
    }

    /**
     * Get current connection health status.
     * @returns {{rtt: number|null, latency: number|null, packetsReceived: number, gapCount: number, status: string}}
     */
    getHealthStatus() {
        const latency = this.rttTracker.getLatency();

        let status = 'good';
        if (latency !== null) {
            if (latency > this.criticalLatencyMs) {
                status = 'critical';
            } else if (latency > this.warningLatencyMs) {
                status = 'warning';
            }
        }

        return {
            rtt: this.rttTracker.getAverageRTT(),
            latency: latency,
            packetsReceived: this.packetsReceived,
            gapCount: this.gapCount,
            status: status
        };
    }
}
```

These classes are lightweight and don't depend on MultiplayerPyodideGame - they can be instantiated when the P2P connection opens.
  </action>
  <verify>
Search for `class RTTTracker` and `class ConnectionHealthMonitor` in the file.
  </verify>
  <done>
RTTTracker class exists with shouldPing(), recordRTT(), getAverageRTT(), getLatency() methods.
ConnectionHealthMonitor class exists with recordReceivedInput() and getHealthStatus() methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite _handleP2PMessage for binary message routing</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Replace the existing `_handleP2PMessage` method in the MultiplayerPyodideGame class with a new version that routes binary messages by type:

```javascript
_handleP2PMessage(data) {
    /**
     * Handle incoming P2P DataChannel messages.
     * Routes to appropriate handler based on message type.
     */

    // Handle ArrayBuffer (binary protocol)
    if (data instanceof ArrayBuffer) {
        this._handleBinaryMessage(data);
        return;
    }

    // Handle string (JSON - legacy test messages)
    if (typeof data === 'string') {
        try {
            const message = JSON.parse(data);
            this._handleJsonMessage(message);
        } catch (e) {
            console.error('[P2P] Failed to parse JSON message:', e);
        }
        return;
    }

    console.warn('[P2P] Unknown message data type:', typeof data);
}

_handleBinaryMessage(buffer) {
    /**
     * Route binary messages by type byte.
     */
    const messageType = getMessageType(buffer);

    switch (messageType) {
        case P2P_MSG_INPUT:
            this._handleInputPacket(buffer);
            break;
        case P2P_MSG_PING:
            this._handlePing(buffer);
            break;
        case P2P_MSG_PONG:
            this._handlePong(buffer);
            break;
        case P2P_MSG_KEEPALIVE:
            // Just receiving it confirms connection is alive
            break;
        default:
            console.warn('[P2P] Unknown binary message type:', messageType);
    }
}

_handleJsonMessage(message) {
    /**
     * Handle JSON messages (test messages from Phase 1).
     */
    if (message.type === 'test') {
        const latency = Date.now() - message.timestamp;
        console.log(`[P2P] Received test from player ${message.from}, latency: ${latency}ms`);
    } else {
        console.log('[P2P] Received JSON message:', message.type);
    }
}
```

This replaces the Phase 1 implementation which only handled test messages. The JSON path is preserved for backward compatibility with test messages.
  </action>
  <verify>
Search for `_handleBinaryMessage` and `case P2P_MSG_INPUT` in the file.
  </verify>
  <done>
_handleP2PMessage routes to _handleBinaryMessage for ArrayBuffer data.
_handleBinaryMessage switches on message type and calls appropriate handler.
Legacy JSON test message handling is preserved.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add input packet and ping/pong handlers</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Add the handler methods to the MultiplayerPyodideGame class (after _handleJsonMessage):

```javascript
_handleInputPacket(buffer) {
    /**
     * Process received input packet and store inputs in GGPO buffer.
     */
    const packet = decodeInputPacket(buffer);
    if (!packet) {
        console.warn('[P2P] Failed to decode input packet');
        return;
    }

    // Store all inputs from the packet (handles redundancy - duplicates are ignored by storeRemoteInput)
    for (const input of packet.inputs) {
        this.storeRemoteInput(packet.playerId, input.action, input.frame);
    }

    // Update connection health monitor
    if (this.connectionHealth) {
        this.connectionHealth.recordReceivedInput(packet.currentFrame);
    }

    // Log occasionally for debugging
    if (this.frameNumber % 60 === 0) {
        console.log(`[P2P] Received input packet: player=${packet.playerId}, frame=${packet.currentFrame}, inputs=${packet.inputs.length}`);
    }
}

_handlePing(buffer) {
    /**
     * Respond to ping with pong (echo timestamp back).
     */
    const view = new DataView(buffer);
    const timestamp = view.getFloat64(1, false);

    // Echo back as pong
    const pong = encodePong(timestamp);
    if (this.webrtcManager?.isReady()) {
        this.webrtcManager.send(pong);
    }
}

_handlePong(buffer) {
    /**
     * Process pong response and update RTT tracking.
     */
    const view = new DataView(buffer);
    const sentTime = view.getFloat64(1, false);

    // Record RTT sample
    if (this.connectionHealth) {
        this.connectionHealth.rttTracker.recordRTT(sentTime);
    }

    // Calculate and log RTT
    const rtt = performance.now() - sentTime;
    if (this.frameNumber % 60 === 0) {
        const avgRtt = this.connectionHealth?.rttTracker.getAverageRTT();
        console.log(`[P2P] RTT: ${rtt.toFixed(1)}ms (avg: ${avgRtt?.toFixed(1) ?? 'N/A'}ms)`);
    }
}
```

Important: The _handleInputPacket uses the existing storeRemoteInput method which already handles:
- Duplicate detection (won't store same player+frame twice)
- Late input detection (triggers rollback if needed)
- Input buffer management

This is the key integration point - received P2P inputs go into the same buffer as SocketIO-relayed inputs.
  </action>
  <verify>
Search for `_handleInputPacket`, `_handlePing`, `_handlePong` in the file.
Verify _handleInputPacket calls `this.storeRemoteInput`.
  </verify>
  <done>
_handleInputPacket decodes packet and stores all inputs via storeRemoteInput.
_handlePing extracts timestamp and sends pong response.
_handlePong records RTT sample in connectionHealth.rttTracker.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. RTTTracker and ConnectionHealthMonitor classes exist before the MultiplayerPyodideGame class
2. _handleP2PMessage correctly routes ArrayBuffer to _handleBinaryMessage
3. _handleBinaryMessage switches on P2P_MSG_INPUT, P2P_MSG_PING, P2P_MSG_PONG
4. _handleInputPacket calls storeRemoteInput for each input in packet
5. _handlePing sends pong response via webrtcManager
6. _handlePong records RTT via connectionHealth.rttTracker
7. No JavaScript syntax errors
</verification>

<success_criteria>
- Binary P2P messages are parsed and routed correctly
- Input packets are stored in GGPO buffer (storeRemoteInput called)
- Ping/pong RTT measurement works
- ConnectionHealthMonitor tracks packet reception and RTT
</success_criteria>

<output>
After completion, create `.planning/phases/02-p2p-transport/02-02-SUMMARY.md`
</output>
