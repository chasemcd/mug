---
phase: 02-p2p-transport
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/static/js/pyodide_multiplayer_game.js
autonomous: true

must_haves:
  truths:
    - "Input packets can be encoded into compact binary format"
    - "Input packets can be decoded back to frame/action data"
    - "Ping/pong messages can be encoded for RTT measurement"
  artifacts:
    - path: "interactive_gym/server/static/js/pyodide_multiplayer_game.js"
      provides: "Binary message encoding/decoding functions"
      contains: "encodeInputPacket"
  key_links:
    - from: "encodeInputPacket"
      to: "decodeInputPacket"
      via: "Inverse operations - encode creates ArrayBuffer that decode parses"
      pattern: "DataView\\.setUint|DataView\\.getUint"
---

<objective>
Add binary message encoding/decoding functions for P2P input packets and ping/pong messages.

Purpose: Enable compact, efficient binary transmission of game inputs over WebRTC DataChannel. Binary format is 3-4x smaller than JSON.
Output: Functions for encoding/decoding input packets (with redundancy support) and ping/pong messages.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-p2p-transport/02-RESEARCH.md
@interactive_gym/server/static/js/pyodide_multiplayer_game.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add binary input packet encode/decode functions</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Add module-level functions at the top of the file (after imports, before the class):

```javascript
// ========== P2P Binary Message Protocol ==========
// Message Types
const P2P_MSG_INPUT = 0x01;
const P2P_MSG_PING = 0x02;
const P2P_MSG_PONG = 0x03;
const P2P_MSG_KEEPALIVE = 0x04;

/**
 * Encode an input packet for P2P transmission.
 * Format: 9 bytes header + 5 bytes per input
 *   Header:
 *     Byte 0: Message type (0x01)
 *     Bytes 1-2: Player ID (uint16)
 *     Bytes 3-6: Current frame (uint32)
 *     Byte 7: Input count (1-5)
 *     Byte 8: Reserved/flags
 *   Each input:
 *     Bytes 0-3: Frame number (uint32)
 *     Byte 4: Action value (uint8)
 *
 * @param {number} playerId - Player ID (0-65535)
 * @param {number} currentFrame - Current simulation frame
 * @param {Array<{frame: number, action: number}>} inputs - Inputs to send (oldest first)
 * @returns {ArrayBuffer} Encoded packet
 */
function encodeInputPacket(playerId, currentFrame, inputs) {
    const inputCount = Math.min(inputs.length, 5);
    const buffer = new ArrayBuffer(9 + inputCount * 5);
    const view = new DataView(buffer);

    view.setUint8(0, P2P_MSG_INPUT);
    view.setUint16(1, playerId, false);  // big-endian
    view.setUint32(3, currentFrame, false);
    view.setUint8(7, inputCount);
    view.setUint8(8, 0);  // reserved

    for (let i = 0; i < inputCount; i++) {
        const offset = 9 + i * 5;
        view.setUint32(offset, inputs[i].frame, false);
        view.setUint8(offset + 4, inputs[i].action);
    }

    return buffer;
}

/**
 * Decode a binary input packet.
 *
 * @param {ArrayBuffer} buffer - Received packet
 * @returns {{playerId: number, currentFrame: number, inputs: Array<{frame: number, action: number}>}|null}
 */
function decodeInputPacket(buffer) {
    const view = new DataView(buffer);

    const type = view.getUint8(0);
    if (type !== P2P_MSG_INPUT) return null;

    const playerId = view.getUint16(1, false);
    const currentFrame = view.getUint32(3, false);
    const inputCount = view.getUint8(7);

    const inputs = [];
    for (let i = 0; i < inputCount; i++) {
        const offset = 9 + i * 5;
        inputs.push({
            frame: view.getUint32(offset, false),
            action: view.getUint8(offset + 4)
        });
    }

    return { playerId, currentFrame, inputs };
}
```

Use big-endian (false) consistently for all multi-byte values. This matches network byte order convention.
  </action>
  <verify>
Search for `encodeInputPacket` and `decodeInputPacket` in the file to confirm they exist.
Run a simple test: In browser console, verify `decodeInputPacket(encodeInputPacket(1, 100, [{frame: 100, action: 3}]))` returns expected values.
  </verify>
  <done>
encodeInputPacket and decodeInputPacket functions exist at module level.
They correctly handle the binary format with player ID, frame number, and 1-5 inputs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ping/pong encode functions</name>
  <files>interactive_gym/server/static/js/pyodide_multiplayer_game.js</files>
  <action>
Add ping/pong encoding functions after the input packet functions:

```javascript
/**
 * Encode a ping message for RTT measurement.
 * Format: 9 bytes
 *   Byte 0: Message type (0x02)
 *   Bytes 1-8: Timestamp (float64, performance.now())
 *
 * @returns {ArrayBuffer} Encoded ping
 */
function encodePing() {
    const buffer = new ArrayBuffer(9);
    const view = new DataView(buffer);
    view.setUint8(0, P2P_MSG_PING);
    view.setFloat64(1, performance.now(), false);
    return buffer;
}

/**
 * Encode a pong response (echo back the original timestamp).
 *
 * @param {number} originalTimestamp - Timestamp from received ping
 * @returns {ArrayBuffer} Encoded pong
 */
function encodePong(originalTimestamp) {
    const buffer = new ArrayBuffer(9);
    const view = new DataView(buffer);
    view.setUint8(0, P2P_MSG_PONG);
    view.setFloat64(1, originalTimestamp, false);
    return buffer;
}

/**
 * Get the message type from a binary message.
 *
 * @param {ArrayBuffer} buffer - Received message
 * @returns {number} Message type byte
 */
function getMessageType(buffer) {
    const view = new DataView(buffer);
    return view.getUint8(0);
}
```

The ping/pong pattern: sender calls encodePing() with current time, receiver extracts timestamp and echoes it back via encodePong(). Sender computes RTT = performance.now() - echoed timestamp.
  </action>
  <verify>
Search for `encodePing`, `encodePong`, `getMessageType` in the file.
Verify constants P2P_MSG_PING (0x02) and P2P_MSG_PONG (0x03) are defined.
  </verify>
  <done>
encodePing, encodePong, and getMessageType functions exist.
Message type constants (P2P_MSG_INPUT, P2P_MSG_PING, P2P_MSG_PONG, P2P_MSG_KEEPALIVE) are defined.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. File contains message type constants: `P2P_MSG_INPUT = 0x01`, `P2P_MSG_PING = 0x02`, `P2P_MSG_PONG = 0x03`
2. Functions encodeInputPacket, decodeInputPacket, encodePing, encodePong, getMessageType all exist
3. No syntax errors in the JavaScript file
</verification>

<success_criteria>
- Binary message encoding/decoding functions are implemented
- Input packets support 1-5 inputs for redundancy
- Ping/pong messages support RTT measurement via timestamp echo
- All functions use consistent big-endian byte order
</success_criteria>

<output>
After completion, create `.planning/phases/02-p2p-transport/02-01-SUMMARY.md`
</output>
