---
phase: 80-pre-game-countdown
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - interactive_gym/server/game_manager.py
  - interactive_gym/server/static/js/index.js
autonomous: true

must_haves:
  truths:
    - "After matchmaker forms a match, all matched players see 'Players found!' with a 3-2-1 countdown on the waiting room screen"
    - "Countdown is visible simultaneously to all matched players (server-triggered)"
    - "Game scene transition and gameplay start only after countdown completes, synced across all players"
    - "Existing single-player and non-multiplayer flows are unaffected (no regression)"
  artifacts:
    - path: "interactive_gym/server/game_manager.py"
      provides: "Server-side countdown delay between match formation and game start"
      contains: "match_found_countdown"
    - path: "interactive_gym/server/static/js/index.js"
      provides: "Client-side countdown display handler"
      contains: "match_found_countdown"
  key_links:
    - from: "interactive_gym/server/game_manager.py"
      to: "interactive_gym/server/static/js/index.js"
      via: "socketio emit match_found_countdown"
      pattern: "emit.*match_found_countdown"
    - from: "interactive_gym/server/game_manager.py"
      to: "interactive_gym/server/static/js/index.js"
      via: "socketio emit start_game (unchanged, fires after delay)"
      pattern: "emit.*start_game"
---

<objective>
Add a 3-second "Players found!" countdown on the waiting room screen after matchmaking forms a match, before transitioning to the game.

Purpose: Give players a brief heads-up that a match was found so they can prepare for gameplay. The countdown is server-triggered so all matched players see it simultaneously.

Output: Modified game_manager.py (server-side delay + new event) and index.js (countdown display handler).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

Key source files:
@interactive_gym/server/game_manager.py
@interactive_gym/server/static/js/index.js
@interactive_gym/server/static/js/ui_utils.js
@interactive_gym/server/static/templates/index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Server-side countdown delay between match and game start</name>
  <files>interactive_gym/server/game_manager.py</files>
  <action>
Modify the two methods that call `self.start_game(game)` after match formation to insert a 3-second countdown delay:

1. In `_create_game_for_match()` (line ~929): Replace the direct `self.start_game(game)` call with a countdown sequence:
   - Emit `match_found_countdown` event to the game room (`room=game.game_id`) with payload `{"countdown_seconds": 3, "message": "Players found!"}`
   - Log the countdown start: `logger.info(f"[Countdown] Starting 3s countdown for game {game.game_id}")`
   - Use `eventlet.sleep(3)` to wait 3 seconds (this is the standard async sleep in the codebase -- do NOT use `time.sleep` which blocks the greenlet pool)
   - Then call `self.start_game(game)` as before

2. In `_create_game_for_match_internal()` (line ~820): Apply the same pattern -- emit `match_found_countdown`, sleep 3, then `start_game`.

IMPORTANT: The `eventlet.sleep(3)` call happens INSIDE the request context for `_create_game_for_match` (called during `join_game` handler). This blocks the arriving player's request greenlet for 3 seconds, which is fine -- the request is done except for starting the game. However, to avoid holding the `waiting_games_lock` during the sleep, make sure `start_game` (and the countdown delay) happen AFTER the lock is released. Looking at the call chain: `_add_to_fifo_queue` holds `self.waiting_games_lock` and calls `_create_game_for_match` inside the lock. To avoid blocking other matchmaking for 3 seconds, refactor the approach:

Instead of sleeping inline, use `self.sio.start_background_task()` to run the countdown+start in a background greenlet:

```python
def _start_game_with_countdown(self, game):
    """Emit countdown event, wait 3 seconds, then start the game."""
    logger.info(f"[Countdown] Starting 3s pre-game countdown for game {game.game_id}")
    self.sio.emit(
        "match_found_countdown",
        {"countdown_seconds": 3, "message": "Players found!"},
        room=game.game_id,
    )
    eventlet.sleep(3)
    logger.info(f"[Countdown] Countdown complete, starting game {game.game_id}")
    self.start_game(game)
```

Then in both `_create_game_for_match()` and `_create_game_for_match_internal()`, replace `self.start_game(game)` with `self.sio.start_background_task(self._start_game_with_countdown, game)`.

Place the new method near `start_game()` (around line 1111).

This ensures:
- The lock is released immediately after match formation
- The countdown runs in a background greenlet
- All matched players see the countdown simultaneously (emit to game room)
- After 3 seconds, `start_game` fires as normal

Single-player flows are unaffected because single-player games (group_size=1) go through `_create_game_for_match` the same way, BUT the matchmaker immediately matches them (no waiting room shown). The countdown will technically fire for single-player too. To skip the countdown for single-player games, add a guard: only run the countdown if `self._get_group_size() > 1`. Otherwise, call `self.start_game(game)` directly (no delay).

```python
def _start_game_with_countdown(self, game):
    """Emit countdown event, wait 3 seconds, then start the game.

    Only applies to multiplayer games (group_size > 1). Single-player
    games start immediately with no countdown.
    """
    group_size = self._get_group_size()
    if group_size <= 1:
        logger.info(f"[Countdown] Skipping countdown for single-player game {game.game_id}")
        self.start_game(game)
        return

    logger.info(f"[Countdown] Starting 3s pre-game countdown for game {game.game_id}")
    self.sio.emit(
        "match_found_countdown",
        {"countdown_seconds": 3, "message": "Players found!"},
        room=game.game_id,
    )
    eventlet.sleep(3)
    logger.info(f"[Countdown] Countdown complete, starting game {game.game_id}")
    self.start_game(game)
```
  </action>
  <verify>
    1. `grep -n "match_found_countdown" interactive_gym/server/game_manager.py` shows the new event emit
    2. `grep -n "_start_game_with_countdown" interactive_gym/server/game_manager.py` shows the new method and its two call sites
    3. `grep -n "start_background_task.*_start_game_with_countdown" interactive_gym/server/game_manager.py` shows background task usage
    4. `grep -n "group_size <= 1" interactive_gym/server/game_manager.py` shows single-player guard
    5. No direct `self.start_game(game)` calls remain in `_create_game_for_match` or `_create_game_for_match_internal` (they should all go through `_start_game_with_countdown`)
  </verify>
  <done>
    - `_start_game_with_countdown` method exists near `start_game()`
    - Both `_create_game_for_match()` and `_create_game_for_match_internal()` call `self.sio.start_background_task(self._start_game_with_countdown, game)` instead of `self.start_game(game)`
    - Single-player guard skips countdown when group_size <= 1
    - `match_found_countdown` event emitted to game room with countdown_seconds and message
  </done>
</task>

<task type="auto">
  <name>Task 2: Client-side countdown display on waiting room screen</name>
  <files>interactive_gym/server/static/js/index.js</files>
  <action>
Add a new socket event handler for `match_found_countdown` in index.js. Place it near the existing `waiting_room` handler (around line 904).

The handler should:

1. Clear the waiting room timer interval (same as `start_game` handler does):
   ```javascript
   if (waitroomInterval) {
       clearInterval(waitroomInterval);
   }
   ```

2. Display the countdown on the existing `#waitroomText` element (no new DOM elements needed). Show "Players found!" message with a 3-2-1 countdown:
   ```javascript
   socket.on('match_found_countdown', function(data) {
       console.log("[Countdown] Match found! Starting", data.countdown_seconds, "second countdown");

       // Stop the waiting room timer
       if (waitroomInterval) {
           clearInterval(waitroomInterval);
       }

       var remaining = data.countdown_seconds;
       var message = data.message || "Players found!";

       // Show initial countdown state
       $("#waitroomText").text(message + " Starting in " + remaining + "...");
       $("#waitroomText").show();

       // Countdown interval
       var countdownInterval = setInterval(function() {
           remaining--;
           if (remaining > 0) {
               $("#waitroomText").text(message + " Starting in " + remaining + "...");
           } else {
               clearInterval(countdownInterval);
               $("#waitroomText").text(message + " Starting now!");
           }
       }, 1000);
   });
   ```

IMPORTANT notes:
- Do NOT hide the waitroomText or show the gameContainer here. The existing `start_game` handler (line 840) already handles the transition to game view. The countdown just updates the text on the waiting room screen.
- Do NOT add any new HTML elements or CSS. The `#waitroomText` element already exists and is styled.
- The countdown is purely cosmetic -- the server controls the actual timing. Even if the client countdown finishes slightly before or after the server's 3-second sleep, the `start_game` event from the server is what triggers the actual game transition.
  </action>
  <verify>
    1. `grep -n "match_found_countdown" interactive_gym/server/static/js/index.js` shows the new handler
    2. `grep -n "clearInterval(waitroomInterval)" interactive_gym/server/static/js/index.js` shows the timer is cleared in the countdown handler
    3. `grep -c "match_found_countdown" interactive_gym/server/static/js/index.js` returns 1 (one handler)
    4. No new HTML elements or CSS added to index.html
    5. The existing `start_game` handler is unchanged
  </verify>
  <done>
    - `match_found_countdown` socket handler exists in index.js
    - Handler clears waitroomInterval
    - Handler updates #waitroomText with "Players found! Starting in 3/2/1..." countdown
    - Existing `start_game` handler is completely unchanged
    - No new DOM elements or CSS files modified
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify with E2E test run</name>
  <files></files>
  <action>
Run the existing multiplayer E2E test to verify no regressions. The test exercises the full flow: matchmaking -> waiting room -> game start -> episode completion.

```bash
cd /Users/chasemcd/Repositories/interactive-gym
python -m pytest tests/e2e/test_multiplayer_basic.py -v --timeout=300
```

The test should still pass. The 3-second countdown delay will add ~3 seconds to the test runtime, which is within the 300-second timeout.

If the test fails, diagnose from console logs -- look for:
- `[Countdown]` log messages from game_manager.py
- `[Countdown]` console.log from index.js
- Whether `start_game` event still fires after the delay

Also run the scene isolation test (Phase 79) to verify post-game behavior is unaffected:

```bash
python -m pytest tests/e2e/test_scene_isolation.py -v --timeout=300
```

If both pass, the implementation is verified.
  </action>
  <verify>
    1. `test_two_players_connect_and_complete_episode` passes
    2. `test_scene_isolation.py` passes (if it exists and is relevant)
    3. No timeout failures (the 3s countdown adds minimal overhead vs 300s timeout)
  </verify>
  <done>
    - Existing E2E tests pass with no regressions
    - The countdown delay does not cause test timeouts
  </done>
</task>

</tasks>

<verification>
Phase-level verification:

1. **CD-01 (3-second countdown overlay on waiting room screen after match formed):**
   - Server emits `match_found_countdown` after match â†’ client displays countdown on `#waitroomText`
   - Verify: Console logs show `[Countdown]` entries on both server and client

2. **CD-02 ("Players found!" message with 3-2-1 countdown visible to all matched players):**
   - Server emits to `room=game.game_id` so all players in the game room receive it
   - Verify: Both players' `#waitroomText` shows "Players found! Starting in 3/2/1..."

3. **CD-03 (Game start remains synced across all players after countdown completes):**
   - Server sleeps 3s then calls `start_game()` which emits to game room
   - Verify: E2E test passes (both players start game after countdown)

4. **No regression (single-player unaffected):**
   - `_start_game_with_countdown` checks `group_size <= 1` and skips countdown
   - Verify: Single-player scenes (if any in test configs) still work
</verification>

<success_criteria>
- `match_found_countdown` event emitted by server after match formation (multiplayer only)
- Client displays "Players found! Starting in 3... 2... 1..." on waiting room screen
- `start_game` fires 3 seconds after `match_found_countdown`
- E2E multiplayer test passes with no regressions
- Single-player games skip countdown entirely
</success_criteria>

<output>
After completion, create `.planning/phases/80-pre-game-countdown/80-01-SUMMARY.md`
</output>
