<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PyodideWorker Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 40px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            color: #333;
        }
        #controls {
            margin: 20px 0;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 4px;
            margin-right: 10px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        #log {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            max-height: 600px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .log-ping { color: #4ec9b0; }
        .log-progress { color: #dcdcaa; }
        .log-success { color: #6a9955; }
        .log-error { color: #f14c4c; }
        .log-info { color: #9cdcfe; }
        .log-result { color: #ce9178; }
        #status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-weight: bold;
        }
        .status-idle { background: #e9ecef; color: #6c757d; }
        .status-running { background: #fff3cd; color: #856404; }
        .status-success { background: #d4edda; color: #155724; }
        .status-error { background: #f8d7da; color: #721c24; }
    </style>
</head>
<body>
    <h1>PyodideWorker Test</h1>
    <p>Tests that Pyodide loads in a Web Worker without blocking the main thread.</p>

    <div id="status" class="status-idle">Ready to test</div>

    <div id="controls">
        <button id="run-test">Run Test</button>
        <button id="run-remotegame-test">Test RemoteGame Operations</button>
        <button id="clear-log">Clear Log</button>
    </div>

    <div id="log"></div>

    <script type="module">
        import { PyodideWorker } from '/static/js/PyodideWorker.js';

        const logEl = document.getElementById('log');
        const statusEl = document.getElementById('status');
        const runBtn = document.getElementById('run-test');
        const runRemoteGameBtn = document.getElementById('run-remotegame-test');
        const clearBtn = document.getElementById('clear-log');

        let testRunning = false;

        function log(message, className = '') {
            const timestamp = new Date().toISOString().split('T')[1].slice(0, -1);
            const line = document.createElement('div');
            line.className = className;
            line.textContent = `[${timestamp}] ${message}`;
            logEl.appendChild(line);
            logEl.scrollTop = logEl.scrollHeight;
        }

        function setStatus(message, state) {
            statusEl.textContent = message;
            statusEl.className = `status-${state}`;
        }

        clearBtn.onclick = () => {
            logEl.innerHTML = '';
        };

        runBtn.onclick = async () => {
            if (testRunning) return;
            testRunning = true;
            runBtn.disabled = true;
            runRemoteGameBtn.disabled = true;
            logEl.innerHTML = '';

            try {
                await runTests();
            } catch (err) {
                log(`TEST FAILED: ${err.message}`, 'log-error');
                if (err.stack) {
                    log(err.stack, 'log-error');
                }
                setStatus('Test failed', 'error');
            } finally {
                testRunning = false;
                runBtn.disabled = false;
                runRemoteGameBtn.disabled = false;
            }
        };

        runRemoteGameBtn.onclick = async () => {
            if (testRunning) return;
            testRunning = true;
            runBtn.disabled = true;
            runRemoteGameBtn.disabled = true;
            logEl.innerHTML = '';

            try {
                await testRemoteGameOperations();
            } catch (err) {
                log(`TEST FAILED: ${err.message}`, 'log-error');
                if (err.stack) {
                    log(err.stack, 'log-error');
                }
                setStatus('RemoteGame test failed', 'error');
            } finally {
                testRunning = false;
                runBtn.disabled = false;
                runRemoteGameBtn.disabled = false;
            }
        };

        async function runTests() {
            setStatus('Running tests...', 'running');

            // ========== Test 1: Non-blocking initialization ==========
            log('=== Test 1: Non-blocking Initialization ===', 'log-info');
            log('Starting ping interval to verify main thread is responsive...');

            let pings = 0;
            const pingInterval = setInterval(() => {
                pings++;
                log(`ping ${pings}`, 'log-ping');
            }, 500);

            log('Creating PyodideWorker...');
            const worker = new PyodideWorker({
                onProgress: (stage, message, timestamp) => {
                    log(`[Progress] ${stage}: ${message}`, 'log-progress');
                }
            });

            const initStart = performance.now();
            log('Calling worker.init() - main thread should NOT block...');

            await worker.init();

            const initDuration = ((performance.now() - initStart) / 1000).toFixed(2);
            clearInterval(pingInterval);

            log(`Pyodide ready! Init took ${initDuration}s`, 'log-success');
            log(`Non-blocking verified: ${pings} pings during init`, 'log-success');

            if (pings < 5) {
                throw new Error(`Expected at least 5 pings during init, got ${pings}. Main thread may be blocked.`);
            }

            // ========== Test 2: Error handling before ready ==========
            log('');
            log('=== Test 2: Error Handling ===', 'log-info');

            // Create a new worker but don't init it
            log('Testing step() before init (should reject)...');
            const uninitWorker = new PyodideWorker({});
            try {
                await uninitWorker.step({});
                throw new Error('step() should have rejected when not ready');
            } catch (err) {
                if (err.message.includes('not ready')) {
                    log(`Correctly rejected: "${err.message}"`, 'log-success');
                } else {
                    throw err;
                }
            }

            // ========== Test 3: Functional verification ==========
            log('');
            log('=== Test 3: Functional Verification ===', 'log-info');

            // Init a simple environment
            log('Initializing simple environment...');
            const envCode = `
# Simple mock environment for testing
class SimpleEnv:
    def __init__(self):
        self.step_count = 0

    def step(self, actions):
        self.step_count += 1
        obs = {'step': self.step_count}
        rewards = {0: 1.0}
        terminateds = {'__all__': self.step_count >= 3}
        truncateds = {'__all__': False}
        infos = {}
        return obs, rewards, terminateds, truncateds, infos

    def reset(self, seed=None):
        self.step_count = 0
        obs = {'step': 0}
        infos = {'seed': seed}
        return obs, infos

    def render(self):
        return [
            [{'type': 'rect', 'x': 0, 'y': 0, 'w': 10, 'h': 10, 'color': '#ff0000'}]
        ]

env = SimpleEnv()
`;
            await worker.initEnv(envCode);
            log('Environment initialized!', 'log-success');

            // Test reset
            log('Testing reset()...');
            const resetResult = await worker.reset(12345);
            log(`Reset result: obs=${JSON.stringify(resetResult.obs)}, seed=${resetResult.infos?.seed}`, 'log-result');

            if (resetResult.obs.step !== 0) {
                throw new Error(`Expected obs.step=0 after reset, got ${resetResult.obs.step}`);
            }
            log('Reset works correctly!', 'log-success');

            // Test step
            log('Testing step()...');
            const stepResult = await worker.step({ 0: 1 });
            log(`Step result: obs=${JSON.stringify(stepResult.obs)}, rewards=${JSON.stringify(stepResult.rewards)}`, 'log-result');

            if (stepResult.obs.step !== 1) {
                throw new Error(`Expected obs.step=1 after step, got ${stepResult.obs.step}`);
            }
            if (stepResult.rewards[0] !== 1.0) {
                throw new Error(`Expected rewards[0]=1.0, got ${stepResult.rewards[0]}`);
            }
            log('Step works correctly!', 'log-success');

            // Test multiple steps
            log('Testing multiple steps...');
            await worker.step({ 0: 1 });
            const finalStep = await worker.step({ 0: 1 });
            log(`Final step: obs=${JSON.stringify(finalStep.obs)}, terminateds=${JSON.stringify(finalStep.terminateds)}`, 'log-result');

            // JS Map iteration can have issues, check for termination
            const terminated = finalStep.terminateds['__all__'] ||
                              (finalStep.terminateds.get && finalStep.terminateds.get('__all__'));
            if (!terminated) {
                log(`Warning: Expected terminated=true after 3 steps, got ${JSON.stringify(finalStep.terminateds)}`, 'log-error');
            } else {
                log('Episode termination works correctly!', 'log-success');
            }

            // Test render state
            if (finalStep.render_state && finalStep.render_state.length > 0) {
                log(`Render state has ${finalStep.render_state.length} layer(s)`, 'log-success');
            }

            // ========== Test 4: Clean shutdown ==========
            log('');
            log('=== Test 4: Clean Shutdown ===', 'log-info');
            log('Calling destroy()...');
            worker.destroy();

            if (worker.worker !== null) {
                throw new Error('Worker should be null after destroy');
            }
            log('Worker destroyed successfully!', 'log-success');

            // ========== Summary ==========
            log('');
            log('========================================', 'log-success');
            log('ALL TESTS PASSED!', 'log-success');
            log('========================================', 'log-success');
            log('');
            log('Summary:', 'log-info');
            log(`  - WORKER-01: Pyodide loads in Worker (init completed)`);
            log(`  - WORKER-02: Main thread responsive (${pings} pings during ${initDuration}s init)`);
            log(`  - WORKER-03: READY event works (step/reset only after init)`);

            setStatus('All tests passed!', 'success');
        }

        // ========== RemoteGame Operations Test ==========
        // Tests the exact Worker operations that RemoteGame uses:
        // initEnv with on_game_step_code, reset with obs normalization, step with full normalization

        async function testRemoteGameOperations() {
            setStatus('Running RemoteGame operations test...', 'running');

            log('=== Testing RemoteGame-like Operations ===', 'log-info');
            log('This test exercises the exact sequence RemoteGame uses.');
            log('');

            // Start ping interval to verify non-blocking behavior throughout
            let pings = 0;
            const pingInterval = setInterval(() => {
                pings++;
                log(`ping ${pings}`, 'log-ping');
            }, 500);

            // Create fresh worker
            const worker = new PyodideWorker({
                onProgress: (stage, msg) => log(`[Progress:${stage}] ${msg}`, 'log-progress')
            });

            log('Initializing Worker (pings should continue)...', 'log-info');
            await worker.init();
            log(`Worker initialized (${pings} pings so far - non-blocking confirmed)`, 'log-success');

            // Install gymnasium (like RemoteGame would)
            log('');
            log('=== Installing gymnasium package ===', 'log-info');
            await worker.installPackages(['gymnasium']);
            log('gymnasium installed!', 'log-success');

            // Test initEnv with on_game_step_code (like RemoteGame does)
            log('');
            log('=== Testing initEnv with on_game_step_code ===', 'log-info');

            const envCode = `
import gymnasium
env = gymnasium.make("CartPole-v1", render_mode="rgb_array")
print("Environment created!")
            `;

            // Pass on_game_step_code in globals - Worker should extract and store it
            await worker.initEnv(envCode, {
                on_game_step_code: '# Pre-step code would go here\npass'
            });
            log('Environment initialized with on_game_step_code', 'log-success');

            const pingsAtInitEnd = pings;
            log(`Pings during init+install+initEnv: ${pingsAtInitEnd}`, 'log-info');

            // Test reset - verify obs normalization to dict with "human" key
            log('');
            log('=== Testing reset() with obs normalization ===', 'log-info');

            const resetResult = await worker.reset();
            const resetObsKeys = resetResult.obs instanceof Map
                ? Array.from(resetResult.obs.keys())
                : Object.keys(resetResult.obs);

            log(`Reset result: obs keys = [${resetObsKeys}]`, 'log-result');

            const resetHasHuman = resetResult.obs instanceof Map
                ? resetResult.obs.has('human')
                : resetResult.obs.hasOwnProperty('human');

            log(`  - Has "human" key: ${resetHasHuman}`, resetHasHuman ? 'log-success' : 'log-error');
            log(`  - render_state present: ${resetResult.render_state !== undefined}`, 'log-result');

            if (!resetHasHuman) {
                throw new Error('Expected reset obs to have "human" key after normalization');
            }

            // Test step - verify rewards/terminateds/truncateds normalization
            log('');
            log('=== Testing step() with full normalization ===', 'log-info');

            const stepResult = await worker.step({ 0: 1 });

            const getKeys = (obj) => obj instanceof Map
                ? Array.from(obj.keys())
                : Object.keys(obj);
            const hasKey = (obj, key) => obj instanceof Map
                ? obj.has(key)
                : obj.hasOwnProperty(key);

            log(`Step result:`, 'log-result');
            log(`  - obs keys: [${getKeys(stepResult.obs)}]`, 'log-result');
            log(`  - rewards keys: [${getKeys(stepResult.rewards)}]`, 'log-result');
            log(`  - terminateds keys: [${getKeys(stepResult.terminateds)}]`, 'log-result');
            log(`  - truncateds keys: [${getKeys(stepResult.truncateds)}]`, 'log-result');

            // Verify all are normalized to dicts with expected keys
            const hasHumanKeys =
                hasKey(stepResult.obs, 'human') &&
                hasKey(stepResult.rewards, 'human') &&
                hasKey(stepResult.terminateds, 'human') &&
                hasKey(stepResult.truncateds, 'human');

            log(`All results normalized to dicts with "human" key: ${hasHumanKeys}`,
                hasHumanKeys ? 'log-success' : 'log-error');

            if (!hasHumanKeys) {
                throw new Error('Expected all step results to have "human" key after normalization');
            }

            // Run a few more steps to ensure stability
            log('');
            log('=== Running multiple steps for stability ===', 'log-info');

            for (let i = 0; i < 3; i++) {
                const r = await worker.step({ 0: Math.floor(Math.random() * 2) });
                const reward = r.rewards instanceof Map ? r.rewards.get('human') : r.rewards.human;
                const terminated = r.terminateds instanceof Map ? r.terminateds.get('human') : r.terminateds.human;
                log(`Step ${i+2}: reward=${reward}, terminated=${terminated}`, 'log-result');
            }

            // Verify non-blocking throughout
            clearInterval(pingInterval);
            log('');
            log(`Total pings during entire test: ${pings}`, 'log-info');

            if (pings < 3) {
                throw new Error(`Expected at least 3 pings during test, got ${pings}. Main thread may have been blocked.`);
            }
            log(`Non-blocking verified: ${pings} pings continued throughout all operations`, 'log-success');

            // Cleanup
            worker.destroy();
            log('Worker destroyed', 'log-success');

            log('');
            log('========================================', 'log-success');
            log('REMOTEGAME OPERATIONS TEST PASSED!', 'log-success');
            log('========================================', 'log-success');
            log('');
            log('Summary:', 'log-info');
            log(`  - REMOTE-01: initEnv accepts on_game_step_code in globals`);
            log(`  - REMOTE-02: reset() returns obs as dict with "human" key`);
            log(`  - REMOTE-03: step() returns rewards/terminateds/truncateds as dicts with "human" key`);
            log(`  - REMOTE-04: render_state passes through from Python`);
            log(`  - REMOTE-05: Non-blocking during all operations (${pings} pings)`);

            setStatus('RemoteGame operations test passed!', 'success');

            return hasHumanKeys;
        }
    </script>
</body>
</html>
